/* Autogenerated by AndroMDA (SessionBean.vsl) - do not edit */
## Include global definitions. ##
#parse("templates/EJBglobals.vm")
##
#set ($viewtype = $class.findTaggedValue("@andromda.ejb.viewType"))
#if (!$viewtype)
#set ($viewtype = "both")
#end

##################################################################################
##                         The actual template starts here                      ##
##################################################################################
package $packagename;

/**
 * Autogenerated EJB implementation class for the $servicename session bean.
$class.getDocumentation(" * ")
 *
#if ($class.abstract)
 * @ejb.bean generate="false"
#else
 * @ejb.bean generate="true"
#end
 *     name="$servicename"
 *     type="$servicetype"
 *     view-type="$viewtype"
 *     jndi-name = "${ejbRefName}/Remote"
 *     local-jndi-name = "${ejbRefName}/Local"
 *
 * @ejb.interface 
 *     local-class="${packagename}.${servicename}Local"
 *     remote-class="${packagename}.${servicename}"
 * @ejb.home 
 *     local-class="${packagename}.${servicename}LocalHome"
 *     remote-class="${packagename}.${servicename}Home"
 *
## Generate environment entries for all static, readonly attributes stereotyped
## as <<EnvEntry>>
#foreach($att in $class.staticAttributes)
#if ($att.hasStereotype("EnvEntry"))
#set ($value = $att.defaultValue)
## Add string delimiters if they are not already present
#if (!$value.startsWith('"') || !$value.endsWith('"'))
#set ($value = '"' + $value + '"')
#end
 * @ejb.env-entry 
 *     name = "$att.name"
 *     type = "$att.type.fullyQualifiedName"
 *     value = $value
 *
#end
#end
#foreach ( $dep in $class.dependencies )
#if ($dep.hasStereotype("EntityRef") || $dep.hasStereotype("ServiceRef"))
#set ($superclass = $dep.targetElement)
#set ($viewtype = "")
#set ($viewtype = $superclass.findTaggedValue("@andromda.ejb.viewType"))
#if ($viewtype == "")
#set ($viewtype = ${superclass.type.viewType})
#end
 *
 * @ejb.ejb-ref 
 *     ejb-name="${superclass.name}" 
 *     view-type="$viewtype" 
 *     ref-name="ejb/${superclass.name}BeanRef"
#end
#if ($dep.hasStereotype("ResourceRef"))
#set ($superclass = $dep.targetElement)
#set ($jndiRef = $dep.findTaggedValue("@andromda.ejb.resource-ref.jndi-name"))
#set ($resAuth = $dep.findTaggedValue("@andromda.ejb.resource-ref.res-auth"))
#if (!$resAuth)
#set ($resAuth = "Container")
#end
#set ($resName = $dep.name)
#if (!$resName)
#set ($resName = $superclass.name)
#end
 *
 * @ejb.resource-ref 
 *     res-ref-name="resource/$resName" 
 *     res-type="${superclass.fullyQualifiedName}" 
 *     res-auth="$resAuth"
#if ($jndiRef)
 *
 * @jboss.resource-ref 
 *     res-ref-name = "resource/$resName" 
 *     jndi-name = "$jndiRef" 
#end
#end
#end
#copyTaggedValues($class " " [ "@andromda.ejb.viewType", "@andromda.ejb.transactionType" ])
 *
 */
public abstract class ${servicename}Bean 
       extends $beanparentclass
       implements javax.ejb.SessionBean
{
    // ----------- constant definitions --------------------
#foreach($att in $class.staticAttributes)
#if (!$att.hasStereotype("EnvEntry"))
#set ($attType = $att.type.fullyQualifiedName)
#set ($ATT_NAME = $att.name)
    private static final $attType $ATT_NAME = $att.defaultValue;
#end
#end
    
    // -- accessors for environment entries and constants --
#foreach($att in $class.staticAttributes)
#set($attType = $att.type.fullyQualifiedName)
#set ($visibility = $att.visibility)

    /**
#if($att.hasStereotype("EnvEntry"))
     * Get the ${att.name} environment entry
#else
#set ($ATT_NAME = $att.name)
     * Get the {@link #$ATT_NAME} constant
#end
$att.getDocumentation("     * ")
     *
## Only expose the method to the component interface if it is public.
#if($visibility == "public")
     * @ejb.interface-method
#end
     */
    $visibility $attType ${att.getterName}(){
#if($att.hasStereotype("EnvEntry"))
        javax.naming.InitialContext initialContext = null;
        try {
            initialContext = new javax.naming.InitialContext();
            return (${attType}) initialContext.lookup("java:comp/env/$att.name");
        } catch (javax.naming.NamingException cause) {
            RuntimeException ex = new IllegalStateException(
                "Cannot access environment entry \"$att.name\".");
            // In order to set the exception cause on JDK 1.4
            // and stay JDK 1.3 compatible nonetheless, we need
            // a bit of reflection magic here...
            try {
                java.lang.reflect.Method initCause =
                  ex.getClass().getMethod("initCause", 
                                        new Class[] {Throwable.class});
                initCause.invoke(ex, new Object[] { cause });
            } catch (Throwable t) {
               // Ignore any errors here - we simply make do without the cause
            }
            throw ex;
        } finally {
            try {
                if (initialContext != null) { initialContext.close(); }
            } catch (javax.naming.NamingException ignore) {
                // Silently ignore naming exceptions at cleanup time
            }
        }
#else
        return $ATT_NAME;
#end
    }
#end

#set ($instanceAttributes = $class.type.instanceAttributes)
#if(!${instanceAttributes.isEmpty()})
    // --------------- attributes ---------------------
#foreach ( $att in $instanceAttributes)
#set($attType = $att.type.fullyQualifiedName)    
#set ($transactionType = $att.findTaggedValue("@andromda.ejb.transactionType", true))
#set ($visibility = $att.visibility)
    /** The ${att.name} property */
    private ${attType} $att.name;
    
    /**
     * Get the ${att.name} property
$att.getDocumentation("     * ")
     *
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
#if($visibility == "public")
     * @ejb.interface-method 
#end
     */
    $visibility $attType ${att.getterName}() {
       return $att.name;
    }

## Only generate a setter if the attribute is not read-only
## Note: It's no use to generate final fields for read-only attributes because
## the fields are likely to be initialized in ejbActivate() or a similiar 
## method and not in the constructor.
#if (!$att.readOnly)
    /**
     * Set the ${att.name} property
     * @param value the new value
#if($visibility == "public")
     * @ejb.interface-method 
#end     
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
     */
    $visibility void ${att.setterName}($attType value) {
       this.$att.name = value;
    }
    
#end
#end
#end
    // ---------------- business methods  ----------------------

#foreach ( $op in $class.operations)
#if (!$op.hasStereotype("CreateMethod"))
#set ($transactionType = $op.findTaggedValue("@andromda.ejb.transactionType", true))
#set ($msig = $op.signature)
#set ($visibility = $op.visibility)
#set($exceptions = "")
#set ($exceptions = $op.findTaggedValue("@andromda.java.throws"))
#if ($exceptions == "")
#set ($exceptions = $defaultException.fullyQualifiedName)
#end
   /**
$op.getDocumentation("    * ")
## Only public methods have transactions and are exported to the interfaces
#if ($visibility == "public")
    * @ejb.interface-method
#if ($transactionType)
    * @ejb.transaction type="$transactionType"
#end
#end
    */
#set ($returntype = $op.type.fullyQualifiedName)
#if ($exceptions == "")
    $visibility abstract $returntype ${msig};    
#else
    $visibility abstract $returntype ${msig}
        throws $exceptions;
#end

#end
#end

    // ---------------- create methods --------------------
## Handle explicitly defined create methods. Since we can't know 
## what the user intended to do with the arbitrary parameters to these methods,
## we generate an abstract ejbCreate() and delegate the implementation to the user.
#foreach ( $op in $class.operations)
#if ($op.hasStereotype("CreateMethod"))
#set ($transactionType = $op.findTaggedValue("@andromda.ejb.transactionType", true))

    /**
$op.getDocumentation("    * ")
     * 
     * @ejb.create-method
#if ($transactionType)
     * @ejb.transaction type="$transactionType"
#end
     */
    public abstract void ejbCreate($op.typedParameterList);
    
    public void ejbPostCreate($op.typedParameterList) {
    }
#end
#end
## Default create method with no arguments.

   /**
## Only expose the method to the interface for concrete EJBs
#if (!$class.abstract)
    * @ejb.create-method
    * @ejb.transaction type="Required"
#end
    */
    public void ejbCreate()
           throws javax.ejb.CreateException
    {}

    public void ejbPostCreate()
           throws javax.ejb.CreateException
    {}

## Autogenerated create method with all attributes. Only present for stateful beans.
#set ($allAttributes = $class.allInstanceAttributes)
#if (${allAttributes.isEmpty()} == false)
    /**
     * Create method with all attribute values.
#set ($inheritedAttributes = $class.inheritedInstanceAttributes)
#foreach($att in $allAttributes)
     * @param $att.name Value for the ${att.name} property
#end
     * @ejb.create-method
     * @ejb.transaction type="Required"
     */
    public void ejbCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
#if(!${inheritedAttributes.isEmpty()})
        // Call ejbCreate method for the super type
        super.ejbCreate($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
#foreach ( $att in $class.instanceAttributes)
## Don't use a setter here - we may have none if the attribute is marked readonly
        this.${att.name} = ${att.name};
#end
    }

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws javax.ejb.CreateException
    {
#if(!${inheritedAttributes.isEmpty()})
        // Call postCreate method for the super type
        super.ejbPostCreate($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
    }
#end

    // ---------------- accessor methods for bean references ---------------

#foreach ( $dep in $class.dependencies )
#set ($viewtype = "")
#if ($dep.hasStereotype("EntityRef") || $dep.hasStereotype("ServiceRef"))
#set ($referencedClass = $dep.targetElement)
#set ($viewtype = $superclass.findTaggedValue("@andromda.ejb.viewType"))
#if ($viewtype == "")
#set ($viewtype = ${referencedClass.viewType})
#end
#if ($viewtype == "local")
#set ($homeInterfaceName = "${referencedClass.name}LocalHome")
#set ($fqHomeInterfaceName = "${referencedClass.fullyQualifiedName}LocalHome")
    /**
     * Get the local home interface of the ${referencedClass.name} bean.
     * The home interface is obtained from the initial context 
     * by looking up the bean reference name.
     * @return local home interface for ${referencedClass.name}. 
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            // Local homes shouldn't be narrowed, as there is no RMI involved.
            ${fqHomeInterfaceName} home = 
                (${fqHomeInterfaceName}) initialContext.lookup("java:/comp/env/ejb/${referencedClass.name}BeanRef");
            return home;
        } finally {
            initialContext.close();
        }
    }
#end
#if ($viewtype == "remote")
#set ($homeInterfaceName = "${referencedClass.name}Home")
#set ($fqHomeInterfaceName = "${referencedClass.fullyQualifiedName}Home")
    /**
     * Get the remote home interface of the ${referencedClass.name} bean.
     * The home interface is obtained from the initial context 
     * by looking up the bean reference name.
     * @return remote home interface for ${referencedClass.name}. Lookup using bean ref name.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            Object home = 
                 initialContext.lookup("java:/comp/env/ejb/${referencedClass.name}BeanRef");
            return ($fqHomeInterfaceName) 
                   javax.rmi.PortableRemoteObject.narrow(home, 
                   ${fqHomeInterfaceName}.class);
        } finally {
            initialContext.close();
        }
    }
#end
#end
#if ($dep.hasStereotype("ResourceRef"))
#set ($referencedClass = $dep.targetElement)
#set ($resClassName = "$referencedClass.fullyQualifiedName}")
#set ($resName = $dep.name)
#if (!$resName)
#set ($resName = $referencedClass.name)
#end
    /**
     * Get the ${resName} resource. 
     * The resource is obtained by looking up
     * <code>java:/comp/env/resource/$resName</code> in JNDI
     * @return the ${resName} resource
     */
    protected static ${resClassName} get${str.upperCaseFirstLetter($resName)}() throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext = 
            new javax.naming.InitialContext();
        try {
            Object resource = 
                 initialContext.lookup("java:/comp/env/resource/$resName");
            return ($resClassName) resource;
        } finally {
            initialContext.close();
        }
    }
#end
#end
}
