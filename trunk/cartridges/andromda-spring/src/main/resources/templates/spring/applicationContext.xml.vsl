<?xml version="1.0" encoding="$xmlEncoding"?>
<!-- Generated by applicationContext.xml.vsl in andromda-spring-cartridge#if($dateTimeGeneratedText) on $springUtils.date#end. Do not modify by hand!. -->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:lang="http://www.springframework.org/schema/lang"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-${springVersion}.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-${springVersion}.xsd">

    <!-- ========================= GENERAL DEFINITIONS ========================= -->

    <!-- Message source for this context, loaded from localized "${messageBundlePath}_xx" files -->
    <bean id="$messageSourceBeanName" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
        <property name="basename"><value>$messageBundlePath</value></property>
    </bean>

    <!-- applicationContext merge-point -->
##    <!-- daosEnabled=$daosEnabled recordType=$recordType daos=$daos entities=$entities $entities.size() -->
#set ($daosEnabled = $daosEnabled && !$entities.empty)
#set ($daosEnabled = $stringUtils.isNotBlank($daos) && $recordType.equalsIgnoreCase("dao") && !$entities.empty)
## only generate this stuff if 'daos' has been defined in a namespace
#if (!$hibernateEntityAnnotations)
    <bean id="${beanNamePrefix}hibernateMappingLocations" class="org.springframework.beans.factory.config.ListFactoryBean">
        <property name="sourceList">
            <list>
                <!-- applicationContext hibernateMappingLocations merge-point -->
#foreach($entity in $entities)
#if ($entity.requiresHibernateMapping)
                <value>classpath:${entity.packagePath}/${entity.entityName}.hbm.xml</value>
#end
#end
            </list>
         </property>
    </bean>

#else
    <bean id="hibernateAnnotatedClasses" class="org.springframework.beans.factory.config.ListFactoryBean">
        <property name="sourceList">
            <list>
                <!-- applicationContext hibernateAnnotatedClasses merge-point -->
#foreach($entity in $entities)
                <value>${entity.packageName}.${entity.entityName}Impl</value>
#end
            </list>
         </property>
    </bean>

#end
    <bean id="${beanNamePrefix}hibernateProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
        <property name="properties">
            <props>
#if ($stringUtils.isNotBlank($hibernatePoolSize))
                <prop key="hibernate.pool.size">$hibernatePoolSize</prop>
#end
#if ($stringUtils.isNotBlank($hibernateTransactionManagerStrategy))
                <prop key="hibernate.transaction.manager.strategy">$hibernateTransactionManagerStrategy</prop>
#end
#if ($stringUtils.isNotBlank($hibernateUserTransactionName))
                <prop key="hibernate.jta.UserTransaction">$hibernateUserTransactionName</prop>
#end
#if ($stringUtils.isNotBlank($hibernateTransactionManagerLookup))
                <prop key="hibernate.transaction.manager_lookup_class">$hibernateTransactionManagerLookup</prop>
#end
#if ($stringUtils.isNotBlank($hibernateUseOuterJoin))
                <prop key="hibernate.use_outer_join">$hibernateUseOuterJoin</prop>
#end
#if ($stringUtils.isNotBlank($hibernateShowSql))
                <prop key="hibernate.show_sql">$hibernateShowSql</prop>
#end
#if ($stringUtils.isNotBlank($hibernateJndiName))
                <prop key="hibernate.session_factory_name">$hibernateJndiName</prop>
#end
#if ($stringUtils.isNotBlank($hibernateDialect))
                <prop key="hibernate.dialect">$hibernateDialect</prop>
#end
#if ($stringUtils.isNotBlank($hibernateDefaultSchema))
                <prop key="hibernate.default_schema">$hibernateDefaultSchema</prop>
#end
#if ($stringUtils.isNotBlank($hibernateMaxFetchDepth))
                <prop key="hibernate.max_fetch_depth">$hibernateMaxFetchDepth</prop>
#end
#if ($stringUtils.isNotBlank($hibernateJdbcFetchSize))
                <prop key="hibernate.jdbc.fetch_size">$hibernateJdbcFetchSize</prop>
#end
#if ($stringUtils.isNotBlank($hibernateDefaultBatchFetchSize))
                <prop key="hibernate.default_batch_fetch_size">$hibernateDefaultBatchFetchSize</prop>
#end
#if ($stringUtils.isNotBlank($hibernateJdbcBatchSize))
                <prop key="hibernate.jdbc.batch_size">$hibernateJdbcBatchSize</prop>
#end
#if ($stringUtils.isNotBlank($hibernateJdbcUseScrollableResultSet))
                <prop key="hibernate.jdbc.use_scrollable_resultset">$hibernateJdbcUseScrollableResultSet</prop>
#end
#if ($stringUtils.isNotBlank($hibernateJdbcUseStreamsForBinary))
                <prop key="hibernate.use_streams_for_binary">$hibernateJdbcUseStreamsForBinary</prop>
#end
#if ($stringUtils.isNotBlank($hibernateHbm2DDLAuto))
                <prop key="hibernate.hbm2ddl.auto">$hibernateHbm2DDLAuto</prop>
#end
#if ($stringUtils.isNotBlank($hibernateQuerySubstitutions))
                <prop key="hibernate.query.substitutions">$hibernateQuerySubstitutions</prop>
#end
#if ($enableCaching)
                <prop key="hibernate.cache.use_query_cache">$enableCaching</prop>
#end
#if ($stringUtils.isNotBlank($hibernateCacheProvider))
                <prop key="hibernate.cache.provider_class">$hibernateCacheProvider</prop>
#end
#if ($stringUtils.isNotBlank($hibernateQueryCacheFactory))
                <prop key="hibernate.cache.query_cache_factory">$hibernateQueryCacheFactory</prop>
#end
#if ($stringUtils.isNotBlank($hibernateConnectionReleaseMode))
                <prop key="hibernate.connection.release_mode">$hibernateConnectionReleaseMode</prop>
#end
#if ($stringUtils.isNotBlank($hibernateTransactionFactoryClass))
                <prop key="transaction.factory_class">$hibernateTransactionFactoryClass</prop>
#end
                <!-- applicationContext hibernateProperties merge-point -->
            </props>
        </property>
    </bean>

    <!-- Hibernate SessionFactory -->
    <bean id="${beanNamePrefix}sessionFactory" class="$sessionFactory">
        <property name="dataSource" ref="${beanNamePrefix}dataSource"/>
#if ($hibernateEntityAnnotations)
#if (!$hibernateUtils.version4)
        <property name="configurationClass">
            <value>org.hibernate.cfg.AnnotationConfiguration</value>
        </property>
#end
        <property name="annotatedClasses" ref="hibernateAnnotatedClasses"/>
#else
        <property name="mappingLocations" ref="${beanNamePrefix}hibernateMappingLocations"/>
#end
        <property name="hibernateProperties" ref="${beanNamePrefix}hibernateProperties"/>
        <!-- applicationContext sessionFactory merge-point -->
    </bean>

#if (!$hibernateUtils.version4)
    <!-- The Hibernate interceptor -->
    <bean id="${beanNamePrefix}hibernateInterceptor" class="${hibernateUtils.springHibernatePackage}.HibernateInterceptor">
        <property name="sessionFactory" ref="${beanNamePrefix}sessionFactory"/>
#if ($stringUtils.isNotBlank($hibernateInterceptorFlushMode))
        <property name="flushMode" value="$hibernateInterceptorFlushMode"/>
#end
        <!-- applicationContext hibernateInterceptor merge-point -->
    </bean>

#elseif ($hibernateUtils.version4)
    <bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>
 
    <!-- Translates Hibernate exceptions to Spring Data Access Exceptions -->
    <bean class="org.springframework.orm.hibernate4.HibernateExceptionTranslator"/>
#end

#if ($daosEnabled)
#foreach($entity in $entities)
#if($implementationLanguage == "groovy" && $entity.daoImplementationRequired)
#set($propertyPrefix="lang:")
    <lang:groovy id="$entity.fullyQualifiedDaoImplementationName" script-source="classpath:${entity.packagePath}/${entity.daoImplementationName}.groovy">
#else
#set($propertyPrefix="")
    <bean id="$entity.fullyQualifiedDaoImplementationName" class="$entity.fullyQualifiedDaoImplementationName">
#end
        <${propertyPrefix}property name="sessionFactory" ref="${beanNamePrefix}sessionFactory"/>
## Because of a bug in Spring with circular references (and using AOP proxies),
## we need to use the lookup-method as a work-a-round for dependencies
#if(!$daoInheritanceEnabled)
#foreach($entityRef in $entity.entityReferences)
        <${propertyPrefix}lookup-method name="$entityRef.daoGetterName" bean="$entityRef.targetElement.getBeanName(false)"/>
#end
#else
#foreach($entityRef in $entity.allEntityReferences)
        <${propertyPrefix}lookup-method name="$entityRef.daoGetterName" bean="$entityRef.targetElement.getBeanName(false)"/>
#end
#end
        <!-- $entity.name entity property merge-point -->
#if($implementationLanguage == "groovy" && $entity.daoImplementationRequired)
    </lang:groovy>
#else
    </bean>
#end

    <!-- $entity.name Entity Proxy with inner $entity.name Entity implementation -->
    <bean id="$entity.getBeanName(false)" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="$entity.fullyQualifiedDaoImplementationName"/>
#if ($daosEnabled)
        <property name="proxyInterfaces" value="$entity.fullyQualifiedDaoName"/>
#end
#if (!$hibernateUtils.version4)
        <property name="interceptorNames">
            <list>
                <value>${beanNamePrefix}hibernateInterceptor</value>
            </list>
        </property>
#end
    </bean>

#end
#end
    <!-- ========================= Start of SERVICE DEFINITIONS ========================= -->

#set ($enableSpringTransactions = ($enableSpringTransactionsWhenEjbsEnabled.equalsIgnoreCase("true") || !$ejbsEnabled) && !$services.empty && $springUtils.publicServicesPresent($services))
#if ($enableSpringTransactions)
    <!-- Service Transactional Interceptor -->
    <bean id="${beanNamePrefix}serviceTransactionInterceptor" class="org.springframework.transaction.interceptor.TransactionInterceptor">
        <property name="transactionManager" ref="${beanNamePrefix}transactionManager"/>
        <property name="transactionAttributeSource">
            <value>
#foreach ($service in $services)
#if (!$service.private)
#foreach ($operation in $springUtils.filterUniqueByName($service.implementationOperations))
#if(!$operation.visibility.equalsIgnoreCase("private") && !$operation.visibility.equalsIgnoreCase("protected"))
                ${service.fullyQualifiedName}.${operation.name}=${operation.transactionType}
#end
#end
#end
#end
            </value>
        </property>
    <!-- applicationContext serviceTransactionInterceptor merge-point -->
    </bean>

#end
##    <!-- $services.size() services -->
#foreach($service in $services)
#if($implementationLanguage == "groovy")
#set($propertyPrefix="lang:")
    <lang:groovy id="$service.fullyQualifiedImplementationName" script-source="classpath:${service.packagePath}/${service.implementationName}.groovy">
#else
#set($propertyPrefix="")
    <bean id="$service.fullyQualifiedImplementationName" class="$service.fullyQualifiedImplementationName" #if ($stringUtils.isNotBlank($service.initMethodName))init-method="$service.initMethodName" #end#if ($stringUtils.isNotBlank($service.destroyMethodName))destroy-method="$service.destroyMethodName" #end>
#end
#if ($daosEnabled)
#foreach($entityRef in $service.allEntityReferences)
        <${propertyPrefix}property name="$entityRef.daoName" ref="$entityRef.targetElement.getBeanName(false)"/>
#end
#end
##    <!-- $service.allServiceReferences.size() ServiceReferences -->
## Because of a bug in Spring with circular references (and using AOP proxies),
## we need to use the lookup-method as a work-around for dependencies
#foreach($serviceRef in $service.allServiceReferences)
        <${propertyPrefix}lookup-method name="$serviceRef.getterName" bean="$serviceRef.targetElement.beanName"/>
#end
##    <!-- $service.allMessagingDestinations.size() MessagingDestinations -->
#foreach($destination in $service.allMessagingDestinations)
        <${propertyPrefix}property name="$destination.templateBeanName" ref="$destination.templateBeanName"/>
#end
##    <!-- $service.operations.size() service operations -->
#foreach ($operation in $service.operations)
#if ($operation.incomingMessageOperation)
## Set this as lookup methods (otherwise we'll have a circular refrence back to the container listener)
        <${propertyPrefix}lookup-method name="get$stringUtils.capitalize($operation.messageListenerContainerReferenceName)" bean="$operation.messageListenerContainerBeanName"/>
#end
#end
        <!-- $service.name service property merge-point -->
#if($implementationLanguage == "groovy")
    </lang:groovy>
#else
    </bean>
#end

    <!-- $service.name Service Proxy with inner $service.name Service Implementation -->
    <bean id="$service.getBeanName(false)" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="$service.fullyQualifiedImplementationName"/>
        <property name="proxyInterfaces" value="$service.fullyQualifiedName"/>
        <property name="interceptorNames">
            <list>
#if ($serviceSecurity && !$service.private)
                <value>${beanNamePrefix}serviceSecurityInterceptor</value>
#end
#if ($enableSpringTransactions)
                <value>${beanNamePrefix}serviceTransactionInterceptor</value>
#end
#if ((!$entities.empty || !$service.allEntityReferences.empty) && $service.hibernateInterceptorEnabled && !$hibernateUtils.version4)
                <value>${beanNamePrefix}hibernateInterceptor</value>
#end
#foreach($interceptor in $service.interceptors)
                <value>$interceptor</value>
#end
            </list>
        </property>
    </bean>

#end
    <!-- ========================= End of SERVICE DEFINITIONS ========================= -->

#if ($serviceSecurity)
    <!-- ================= Start of SERVICE SPRING SECURITY DEFINITIONS ================ -->

    <bean id="${beanNamePrefix}serviceSecurityInterceptor" class="$serviceSecurityInterceptor">
        <property name="accessDecisionManager"><ref bean="${beanNamePrefix}serviceAccessDecisionManager"/></property>
#if ($stringUtils.isNotBlank($securityAuthenticationManager))
        <property name="authenticationManager"><ref bean="$securityAuthenticationManager"/></property>
#end
#if ($stringUtils.isNotBlank($securityRunAsManager))
        <property name="runAsManager"><ref bean="$securityRunAsManager"/></property>
#end
        <property name="objectDefinitionSource">
            <value>
#foreach($service in $services)
#set($serviceImplementsInterfaces = !$service.interfaceAbstractions.empty)
#foreach ($operation in $springUtils.filterUniqueByName($service.implementationOperations))
#if (!$operation.roles.empty)
                ${service.fullyQualifiedName}.${operation.name}=#foreach($role in $operation.roles)#if($securityRolePrefix && !$role.name.startsWith("$securityRolePrefix"))$securityRolePrefix#end$role.name#if($velocityHasNext), #end#end

##advise service roles to implemented interface methods
#elseif($serviceImplementsInterfaces)
                ${service.fullyQualifiedName}.${operation.name}=#foreach($role in $service.roles)#if($securityRolePrefix && !$role.name.startsWith("$securityRolePrefix"))$securityRolePrefix#end$role.name#if($velocityHasNext), #end#end

#end
#end
#end
            </value>
        </property>
    </bean>

    <bean id="${beanNamePrefix}serviceAccessDecisionManager" class="$serviceAccessDecisionManager">
        <property name="allowIfAllAbstainDecisions" value="false"/>
        <property name="decisionVoters">
            <list>
                <ref local="${beanNamePrefix}serviceDecisionVoter"/>
            </list>
        </property>
    </bean>

    <bean id="${beanNamePrefix}serviceDecisionVoter" class="$serviceDecisionVoter">
        <property name="rolePrefix" value="$securityRolePrefix"/>
    </bean>

    <!-- ================== End of SERVICE SPRING SECURITY DEFINITIONS ================= -->

#end
</beans>
