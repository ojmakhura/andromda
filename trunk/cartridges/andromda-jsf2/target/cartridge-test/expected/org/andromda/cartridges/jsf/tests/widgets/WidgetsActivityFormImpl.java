// license-header java merge-point
// Generated by andromda-jsf cartridge (forms\FormImpl.java.vsl) on 07/30/2011 09:32:38-0300
package org.andromda.cartridges.jsf.tests.widgets;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.faces.application.FacesMessage;
import javax.faces.event.ActionEvent;
import javax.faces.event.FacesEvent;
import javax.faces.event.ValueChangeEvent;
import javax.faces.model.SelectItem;
import org.apache.commons.beanutils.PropertyUtils;

/**
 * 
 */
public class WidgetsActivityFormImpl
    implements Serializable
{
    /**
     * Default constructor
     */
    public WidgetsActivityFormImpl()
    {
        // - setup the default java.util.Date.toString() formatter
        final DateFormat dateFormatter = new SimpleDateFormat("EEE MMM dd hh:mm:ss zzz yyyy");
        dateFormatter.setLenient(true);
        this.dateTimeFormatters.put(null, dateFormatter);
    }

    private transient FacesEvent event;

    /**
     * @param eventIn
     */
    public void setEvent(FacesEvent eventIn)
    {
        this.event = eventIn;
    }

    /**
     * @return ValueChangeEvent
     */
    public ValueChangeEvent getValueChangeEvent()
    {
        return this.event instanceof ValueChangeEvent
            ? (ValueChangeEvent)this.event : null;
    }

    /**
     * @return ActionEvent
     */
    public ActionEvent getActionEvent()
    {
        return this.event instanceof ActionEvent
            ? (ActionEvent)this.event : null;
    }

    // Action widgets-activity-preloading formFields

    private String textFieldTest;

    /**
     * 
     * @return textFieldTest 
     */
    public String getTextFieldTest()
    {
        return this.textFieldTest;
    }

    /**
     * Keeps track of whether or not the value of textFieldTest has
     * be populated at least once.
     */
    private boolean textFieldTestSet = false;

    /**
     * Resets the value of the textFieldTestSet to false
     */
    public void resetTextFieldTestSet()
    {
        this.textFieldTestSet = false;
    }

    /**
     * Indicates whether or not the value for textFieldTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTextFieldTestSet()
    {
        return this.textFieldTestSet;
    }

    /**
     * 
     * @param textFieldTestIn 
     */
    public void setTextFieldTest(String textFieldTestIn)
    {
        this.textFieldTest = textFieldTestIn;
        this.textFieldTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] textFieldTestValueList;

    /**
     * Stores the labels
     */
    private Object[] textFieldTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTextFieldTestBackingList()
    {
        Object[] values = this.textFieldTestValueList;
        Object[] labels = this.textFieldTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return textFieldTestValueList
     */
    public Object[] getTextFieldTestValueList()
    {
        return this.textFieldTestValueList;
    }

    /**
     * @param textFieldTestValueListIn
     */
    public void setTextFieldTestValueList(Object[] textFieldTestValueListIn)
    {
        this.textFieldTestValueList = textFieldTestValueListIn;
    }

    /**
     * @return textFieldTestLabelList Object[]
     */
    public Object[] getTextFieldTestLabelList()
    {
        return this.textFieldTestLabelList;
    }

    /**
     * @param textFieldTestLabelListIn
     */
    public void setTextFieldTestLabelList(Object[] textFieldTestLabelListIn)
    {
        this.textFieldTestLabelList = textFieldTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTextFieldTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.textFieldTestValueList = null;
        this.textFieldTestLabelList = null;
        if (items != null)
        {
            this.textFieldTestValueList = new Object[items.size()];
            this.textFieldTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.textFieldTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.textFieldTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.textFieldTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String passwordFieldTest;

    /**
     * 
     * @return passwordFieldTest 
     */
    public String getPasswordFieldTest()
    {
        return this.passwordFieldTest;
    }

    /**
     * Keeps track of whether or not the value of passwordFieldTest has
     * be populated at least once.
     */
    private boolean passwordFieldTestSet = false;

    /**
     * Resets the value of the passwordFieldTestSet to false
     */
    public void resetPasswordFieldTestSet()
    {
        this.passwordFieldTestSet = false;
    }

    /**
     * Indicates whether or not the value for passwordFieldTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isPasswordFieldTestSet()
    {
        return this.passwordFieldTestSet;
    }

    /**
     * 
     * @param passwordFieldTestIn 
     */
    public void setPasswordFieldTest(String passwordFieldTestIn)
    {
        this.passwordFieldTest = passwordFieldTestIn;
        this.passwordFieldTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] passwordFieldTestValueList;

    /**
     * Stores the labels
     */
    private Object[] passwordFieldTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getPasswordFieldTestBackingList()
    {
        Object[] values = this.passwordFieldTestValueList;
        Object[] labels = this.passwordFieldTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return passwordFieldTestValueList
     */
    public Object[] getPasswordFieldTestValueList()
    {
        return this.passwordFieldTestValueList;
    }

    /**
     * @param passwordFieldTestValueListIn
     */
    public void setPasswordFieldTestValueList(Object[] passwordFieldTestValueListIn)
    {
        this.passwordFieldTestValueList = passwordFieldTestValueListIn;
    }

    /**
     * @return passwordFieldTestLabelList Object[]
     */
    public Object[] getPasswordFieldTestLabelList()
    {
        return this.passwordFieldTestLabelList;
    }

    /**
     * @param passwordFieldTestLabelListIn
     */
    public void setPasswordFieldTestLabelList(Object[] passwordFieldTestLabelListIn)
    {
        this.passwordFieldTestLabelList = passwordFieldTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setPasswordFieldTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.passwordFieldTestValueList = null;
        this.passwordFieldTestLabelList = null;
        if (items != null)
        {
            this.passwordFieldTestValueList = new Object[items.size()];
            this.passwordFieldTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.passwordFieldTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.passwordFieldTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.passwordFieldTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String textAreaTest;

    /**
     * 
     * @return textAreaTest 
     */
    public String getTextAreaTest()
    {
        return this.textAreaTest;
    }

    /**
     * Keeps track of whether or not the value of textAreaTest has
     * be populated at least once.
     */
    private boolean textAreaTestSet = false;

    /**
     * Resets the value of the textAreaTestSet to false
     */
    public void resetTextAreaTestSet()
    {
        this.textAreaTestSet = false;
    }

    /**
     * Indicates whether or not the value for textAreaTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTextAreaTestSet()
    {
        return this.textAreaTestSet;
    }

    /**
     * 
     * @param textAreaTestIn 
     */
    public void setTextAreaTest(String textAreaTestIn)
    {
        this.textAreaTest = textAreaTestIn;
        this.textAreaTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] textAreaTestValueList;

    /**
     * Stores the labels
     */
    private Object[] textAreaTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTextAreaTestBackingList()
    {
        Object[] values = this.textAreaTestValueList;
        Object[] labels = this.textAreaTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return textAreaTestValueList
     */
    public Object[] getTextAreaTestValueList()
    {
        return this.textAreaTestValueList;
    }

    /**
     * @param textAreaTestValueListIn
     */
    public void setTextAreaTestValueList(Object[] textAreaTestValueListIn)
    {
        this.textAreaTestValueList = textAreaTestValueListIn;
    }

    /**
     * @return textAreaTestLabelList Object[]
     */
    public Object[] getTextAreaTestLabelList()
    {
        return this.textAreaTestLabelList;
    }

    /**
     * @param textAreaTestLabelListIn
     */
    public void setTextAreaTestLabelList(Object[] textAreaTestLabelListIn)
    {
        this.textAreaTestLabelList = textAreaTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTextAreaTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.textAreaTestValueList = null;
        this.textAreaTestLabelList = null;
        if (items != null)
        {
            this.textAreaTestValueList = new Object[items.size()];
            this.textAreaTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.textAreaTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.textAreaTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.textAreaTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private boolean checkboxTest;

    /**
     * 
     * @return checkboxTest 
     */
    public boolean isCheckboxTest()
    {
        return this.checkboxTest;
    }

    /**
     * Keeps track of whether or not the value of checkboxTest has
     * be populated at least once.
     */
    private boolean checkboxTestSet = false;

    /**
     * Resets the value of the checkboxTestSet to false
     */
    public void resetCheckboxTestSet()
    {
        this.checkboxTestSet = false;
    }

    /**
     * Indicates whether or not the value for checkboxTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isCheckboxTestSet()
    {
        return this.checkboxTestSet;
    }

    /**
     * 
     * @param checkboxTestIn 
     */
    public void setCheckboxTest(boolean checkboxTestIn)
    {
        this.checkboxTest = checkboxTestIn;
        this.checkboxTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] checkboxTestValueList;

    /**
     * Stores the labels
     */
    private Object[] checkboxTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getCheckboxTestBackingList()
    {
        Object[] values = this.checkboxTestValueList;
        Object[] labels = this.checkboxTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return checkboxTestValueList
     */
    public Object[] getCheckboxTestValueList()
    {
        return this.checkboxTestValueList;
    }

    /**
     * @param checkboxTestValueListIn
     */
    public void setCheckboxTestValueList(Object[] checkboxTestValueListIn)
    {
        this.checkboxTestValueList = checkboxTestValueListIn;
    }

    /**
     * @return checkboxTestLabelList Object[]
     */
    public Object[] getCheckboxTestLabelList()
    {
        return this.checkboxTestLabelList;
    }

    /**
     * @param checkboxTestLabelListIn
     */
    public void setCheckboxTestLabelList(Object[] checkboxTestLabelListIn)
    {
        this.checkboxTestLabelList = checkboxTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setCheckboxTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.checkboxTestValueList = null;
        this.checkboxTestLabelList = null;
        if (items != null)
        {
            this.checkboxTestValueList = new Object[items.size()];
            this.checkboxTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.checkboxTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.checkboxTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.checkboxTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String radioButtonsTest;

    /**
     * 
     * @return radioButtonsTest 
     */
    public String getRadioButtonsTest()
    {
        return this.radioButtonsTest;
    }

    /**
     * Keeps track of whether or not the value of radioButtonsTest has
     * be populated at least once.
     */
    private boolean radioButtonsTestSet = false;

    /**
     * Resets the value of the radioButtonsTestSet to false
     */
    public void resetRadioButtonsTestSet()
    {
        this.radioButtonsTestSet = false;
    }

    /**
     * Indicates whether or not the value for radioButtonsTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isRadioButtonsTestSet()
    {
        return this.radioButtonsTestSet;
    }

    /**
     * 
     * @param radioButtonsTestIn 
     */
    public void setRadioButtonsTest(String radioButtonsTestIn)
    {
        this.radioButtonsTest = radioButtonsTestIn;
        this.radioButtonsTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] radioButtonsTestValueList;

    /**
     * Stores the labels
     */
    private Object[] radioButtonsTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getRadioButtonsTestBackingList()
    {
        Object[] values = this.radioButtonsTestValueList;
        Object[] labels = this.radioButtonsTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return radioButtonsTestValueList
     */
    public Object[] getRadioButtonsTestValueList()
    {
        return this.radioButtonsTestValueList;
    }

    /**
     * @param radioButtonsTestValueListIn
     */
    public void setRadioButtonsTestValueList(Object[] radioButtonsTestValueListIn)
    {
        this.radioButtonsTestValueList = radioButtonsTestValueListIn;
    }

    /**
     * @return radioButtonsTestLabelList Object[]
     */
    public Object[] getRadioButtonsTestLabelList()
    {
        return this.radioButtonsTestLabelList;
    }

    /**
     * @param radioButtonsTestLabelListIn
     */
    public void setRadioButtonsTestLabelList(Object[] radioButtonsTestLabelListIn)
    {
        this.radioButtonsTestLabelList = radioButtonsTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setRadioButtonsTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.radioButtonsTestValueList = null;
        this.radioButtonsTestLabelList = null;
        if (items != null)
        {
            this.radioButtonsTestValueList = new Object[items.size()];
            this.radioButtonsTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.radioButtonsTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.radioButtonsTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.radioButtonsTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String radioButtonsTest2;

    /**
     * 
     * @return radioButtonsTest2 
     */
    public String getRadioButtonsTest2()
    {
        return this.radioButtonsTest2;
    }

    /**
     * Keeps track of whether or not the value of radioButtonsTest2 has
     * be populated at least once.
     */
    private boolean radioButtonsTest2Set = false;

    /**
     * Resets the value of the radioButtonsTest2Set to false
     */
    public void resetRadioButtonsTest2Set()
    {
        this.radioButtonsTest2Set = false;
    }

    /**
     * Indicates whether or not the value for radioButtonsTest2 has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isRadioButtonsTest2Set()
    {
        return this.radioButtonsTest2Set;
    }

    /**
     * 
     * @param radioButtonsTest2In 
     */
    public void setRadioButtonsTest2(String radioButtonsTest2In)
    {
        this.radioButtonsTest2 = radioButtonsTest2In;
        this.radioButtonsTest2Set = true;
    }

    /**
     * Stores the values.
     */
    private Object[] radioButtonsTest2ValueList;

    /**
     * Stores the labels
     */
    private Object[] radioButtonsTest2LabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getRadioButtonsTest2BackingList()
    {
        Object[] values = this.radioButtonsTest2ValueList;
        Object[] labels = this.radioButtonsTest2LabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return radioButtonsTest2ValueList
     */
    public Object[] getRadioButtonsTest2ValueList()
    {
        return this.radioButtonsTest2ValueList;
    }

    /**
     * @param radioButtonsTest2ValueListIn
     */
    public void setRadioButtonsTest2ValueList(Object[] radioButtonsTest2ValueListIn)
    {
        this.radioButtonsTest2ValueList = radioButtonsTest2ValueListIn;
    }

    /**
     * @return radioButtonsTest2LabelList Object[]
     */
    public Object[] getRadioButtonsTest2LabelList()
    {
        return this.radioButtonsTest2LabelList;
    }

    /**
     * @param radioButtonsTest2LabelListIn
     */
    public void setRadioButtonsTest2LabelList(Object[] radioButtonsTest2LabelListIn)
    {
        this.radioButtonsTest2LabelList = radioButtonsTest2LabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setRadioButtonsTest2BackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.radioButtonsTest2ValueList = null;
        this.radioButtonsTest2LabelList = null;
        if (items != null)
        {
            this.radioButtonsTest2ValueList = new Object[items.size()];
            this.radioButtonsTest2LabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.radioButtonsTest2ValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.radioButtonsTest2LabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.radioButtonsTest2LabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String radioButtonsTest3;

    /**
     * 
     * @return radioButtonsTest3 
     */
    public String getRadioButtonsTest3()
    {
        return this.radioButtonsTest3;
    }

    /**
     * Keeps track of whether or not the value of radioButtonsTest3 has
     * be populated at least once.
     */
    private boolean radioButtonsTest3Set = false;

    /**
     * Resets the value of the radioButtonsTest3Set to false
     */
    public void resetRadioButtonsTest3Set()
    {
        this.radioButtonsTest3Set = false;
    }

    /**
     * Indicates whether or not the value for radioButtonsTest3 has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isRadioButtonsTest3Set()
    {
        return this.radioButtonsTest3Set;
    }

    /**
     * 
     * @param radioButtonsTest3In 
     */
    public void setRadioButtonsTest3(String radioButtonsTest3In)
    {
        this.radioButtonsTest3 = radioButtonsTest3In;
        this.radioButtonsTest3Set = true;
    }

    /**
     * Stores the values.
     */
    private Object[] radioButtonsTest3ValueList;

    /**
     * Stores the labels
     */
    private Object[] radioButtonsTest3LabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getRadioButtonsTest3BackingList()
    {
        Object[] values = this.radioButtonsTest3ValueList;
        Object[] labels = this.radioButtonsTest3LabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return radioButtonsTest3ValueList
     */
    public Object[] getRadioButtonsTest3ValueList()
    {
        return this.radioButtonsTest3ValueList;
    }

    /**
     * @param radioButtonsTest3ValueListIn
     */
    public void setRadioButtonsTest3ValueList(Object[] radioButtonsTest3ValueListIn)
    {
        this.radioButtonsTest3ValueList = radioButtonsTest3ValueListIn;
    }

    /**
     * @return radioButtonsTest3LabelList Object[]
     */
    public Object[] getRadioButtonsTest3LabelList()
    {
        return this.radioButtonsTest3LabelList;
    }

    /**
     * @param radioButtonsTest3LabelListIn
     */
    public void setRadioButtonsTest3LabelList(Object[] radioButtonsTest3LabelListIn)
    {
        this.radioButtonsTest3LabelList = radioButtonsTest3LabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setRadioButtonsTest3BackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.radioButtonsTest3ValueList = null;
        this.radioButtonsTest3LabelList = null;
        if (items != null)
        {
            this.radioButtonsTest3ValueList = new Object[items.size()];
            this.radioButtonsTest3LabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.radioButtonsTest3ValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.radioButtonsTest3LabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.radioButtonsTest3LabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String selectTest;

    /**
     * 
     * @return selectTest 
     */
    public String getSelectTest()
    {
        return this.selectTest;
    }

    /**
     * Keeps track of whether or not the value of selectTest has
     * be populated at least once.
     */
    private boolean selectTestSet = false;

    /**
     * Resets the value of the selectTestSet to false
     */
    public void resetSelectTestSet()
    {
        this.selectTestSet = false;
    }

    /**
     * Indicates whether or not the value for selectTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isSelectTestSet()
    {
        return this.selectTestSet;
    }

    /**
     * 
     * @param selectTestIn 
     */
    public void setSelectTest(String selectTestIn)
    {
        this.selectTest = selectTestIn;
        this.selectTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] selectTestValueList;

    /**
     * Stores the labels
     */
    private Object[] selectTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getSelectTestBackingList()
    {
        Object[] values = this.selectTestValueList;
        Object[] labels = this.selectTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return selectTestValueList
     */
    public Object[] getSelectTestValueList()
    {
        return this.selectTestValueList;
    }

    /**
     * @param selectTestValueListIn
     */
    public void setSelectTestValueList(Object[] selectTestValueListIn)
    {
        this.selectTestValueList = selectTestValueListIn;
    }

    /**
     * @return selectTestLabelList Object[]
     */
    public Object[] getSelectTestLabelList()
    {
        return this.selectTestLabelList;
    }

    /**
     * @param selectTestLabelListIn
     */
    public void setSelectTestLabelList(Object[] selectTestLabelListIn)
    {
        this.selectTestLabelList = selectTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setSelectTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.selectTestValueList = null;
        this.selectTestLabelList = null;
        if (items != null)
        {
            this.selectTestValueList = new Object[items.size()];
            this.selectTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.selectTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.selectTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.selectTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String hiddenTest;

    /**
     * 
     * @return hiddenTest 
     */
    public String getHiddenTest()
    {
        return this.hiddenTest;
    }

    /**
     * Keeps track of whether or not the value of hiddenTest has
     * be populated at least once.
     */
    private boolean hiddenTestSet = false;

    /**
     * Resets the value of the hiddenTestSet to false
     */
    public void resetHiddenTestSet()
    {
        this.hiddenTestSet = false;
    }

    /**
     * Indicates whether or not the value for hiddenTest has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isHiddenTestSet()
    {
        return this.hiddenTestSet;
    }

    /**
     * 
     * @param hiddenTestIn 
     */
    public void setHiddenTest(String hiddenTestIn)
    {
        this.hiddenTest = hiddenTestIn;
        this.hiddenTestSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] hiddenTestValueList;

    /**
     * Stores the labels
     */
    private Object[] hiddenTestLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getHiddenTestBackingList()
    {
        Object[] values = this.hiddenTestValueList;
        Object[] labels = this.hiddenTestLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return hiddenTestValueList
     */
    public Object[] getHiddenTestValueList()
    {
        return this.hiddenTestValueList;
    }

    /**
     * @param hiddenTestValueListIn
     */
    public void setHiddenTestValueList(Object[] hiddenTestValueListIn)
    {
        this.hiddenTestValueList = hiddenTestValueListIn;
    }

    /**
     * @return hiddenTestLabelList Object[]
     */
    public Object[] getHiddenTestLabelList()
    {
        return this.hiddenTestLabelList;
    }

    /**
     * @param hiddenTestLabelListIn
     */
    public void setHiddenTestLabelList(Object[] hiddenTestLabelListIn)
    {
        this.hiddenTestLabelList = hiddenTestLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setHiddenTestBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.hiddenTestValueList = null;
        this.hiddenTestLabelList = null;
        if (items != null)
        {
            this.hiddenTestValueList = new Object[items.size()];
            this.hiddenTestLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.hiddenTestValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.hiddenTestLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.hiddenTestLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String textFieldTest2;

    /**
     * 
     * @return textFieldTest2 
     */
    public String getTextFieldTest2()
    {
        return this.textFieldTest2;
    }

    /**
     * Keeps track of whether or not the value of textFieldTest2 has
     * be populated at least once.
     */
    private boolean textFieldTest2Set = false;

    /**
     * Resets the value of the textFieldTest2Set to false
     */
    public void resetTextFieldTest2Set()
    {
        this.textFieldTest2Set = false;
    }

    /**
     * Indicates whether or not the value for textFieldTest2 has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTextFieldTest2Set()
    {
        return this.textFieldTest2Set;
    }

    /**
     * 
     * @param textFieldTest2In 
     */
    public void setTextFieldTest2(String textFieldTest2In)
    {
        this.textFieldTest2 = textFieldTest2In;
        this.textFieldTest2Set = true;
    }

    /**
     * Stores the values.
     */
    private Object[] textFieldTest2ValueList;

    /**
     * Stores the labels
     */
    private Object[] textFieldTest2LabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTextFieldTest2BackingList()
    {
        Object[] values = this.textFieldTest2ValueList;
        Object[] labels = this.textFieldTest2LabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return textFieldTest2ValueList
     */
    public Object[] getTextFieldTest2ValueList()
    {
        return this.textFieldTest2ValueList;
    }

    /**
     * @param textFieldTest2ValueListIn
     */
    public void setTextFieldTest2ValueList(Object[] textFieldTest2ValueListIn)
    {
        this.textFieldTest2ValueList = textFieldTest2ValueListIn;
    }

    /**
     * @return textFieldTest2LabelList Object[]
     */
    public Object[] getTextFieldTest2LabelList()
    {
        return this.textFieldTest2LabelList;
    }

    /**
     * @param textFieldTest2LabelListIn
     */
    public void setTextFieldTest2LabelList(Object[] textFieldTest2LabelListIn)
    {
        this.textFieldTest2LabelList = textFieldTest2LabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTextFieldTest2BackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.textFieldTest2ValueList = null;
        this.textFieldTest2LabelList = null;
        if (items != null)
        {
            this.textFieldTest2ValueList = new Object[items.size()];
            this.textFieldTest2LabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.textFieldTest2ValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.textFieldTest2LabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.textFieldTest2LabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    /**
     * Resets all the "isSet" flags.
     */
     public void resetIsSetFlags()
     {
         this.resetTextFieldTestSet();
         this.resetPasswordFieldTestSet();
         this.resetTextAreaTestSet();
         this.resetCheckboxTestSet();
         this.resetRadioButtonsTestSet();
         this.resetRadioButtonsTest2Set();
         this.resetRadioButtonsTest3Set();
         this.resetSelectTestSet();
         this.resetHiddenTestSet();
         this.resetTextFieldTest2Set();
     }

    /**
     * Stores any date or time formatters for this form.
     */
    private final Map<String, DateFormat> dateTimeFormatters =
        new HashMap<String, DateFormat>();

    /**
     * Gets any date and time formatters (keyed by property name)
     * for this form.
     *
     * @return the Map containing any date and time formatters.
     */
    public Map<String, DateFormat> getDateTimeFormatters()
    {
        return this.dateTimeFormatters;
    }

    /**
     * The current collection of messages stored within this form.
     */
    private transient Map<String, FacesMessage> jsfMessages =
        new LinkedHashMap<String, FacesMessage>();


    /**
     * Adds a {@link FacesMessage} message to the current messages
     * stored within this form.
     *
     * @param jsfMessage the faces message to add.
     */
    public void addJsfMessages(FacesMessage jsfMessage)
    {
        if (this.jsfMessages != null)
        {
            this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
        }
    }

    /**
     * Gets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @return the current Faces messages.
     */
    public Collection<FacesMessage> getJsfMessages()
    {
        if (this.jsfMessages == null)
        {
            this.jsfMessages = new LinkedHashMap<String, FacesMessage>();
        }
        return this.jsfMessages.values();
    }

    /**
     * Sets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @param messages a collection of the current Faces messages.
     */
    public void setJsfMessages(final Collection<FacesMessage> messages)
    {
        if (messages != null)
        {
            for (final FacesMessage jsfMessage: messages)
            {
                this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
            }
        }
    }

    /**
     * Clear the current {@link FacesMessage} message
     * instances stored within this form.
     */
    public void clearJsfMessages()
    {
        this.jsfMessages.clear();
    }

    /**
     * The faces message title (used on a view).
     */
    private String jsfMessagesTitle;

    /**
     * The optional faces message title to set (used on a view).  If not set, the default title
     * will be used.
     *
     * @param jsfMessagesTitleIn the title to use for the messages on the view.
     */
    public void setJsfMessagesTitle(final String jsfMessagesTitleIn)
    {
        this.jsfMessagesTitle = jsfMessagesTitleIn;
    }

    /**
     * Gets the faces messages title to use.
     *
     * @return the faces messages title.
     */
    public String getJsfMessagesTitle()
    {
        return this.jsfMessagesTitle;
    }

    /**
     * Gets the maximum severity of the messages stored in this form.
     *
     * @return the maximum severity or null if no messages are present and/or severity isn't set.
     */
    public FacesMessage.Severity getMaximumMessageSeverity()
    {
        FacesMessage.Severity maxSeverity = null;
        for (final FacesMessage message : this.getJsfMessages())
        {
            final FacesMessage.Severity severity = message.getSeverity();
            if (maxSeverity == null || (severity != null && severity.getOrdinal() > maxSeverity.getOrdinal()))
            {
                maxSeverity = severity;
            }
        }
        return maxSeverity;
    }

    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = 3682388922795319145L;
}