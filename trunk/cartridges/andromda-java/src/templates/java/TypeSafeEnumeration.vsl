#if ($umlUtils.shouldOutput($enumeration))
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: TypeSafeEnumeration.vsl in andromda-java-cartridge.
// Model Class:  $enumeration.validationName
// Metafacade:   org.andromda.metafacades.uml.Enumeration
#foreach ($stereotype in $enumeration.stereotypes)
// Stereotype:  ${stereotype}
#end
//
## -- start -- set the map and list types as template parameters if required
#set ($valuesTemplateType = "")
#set ($literalsTemplateType = "")
#set ($namesTemplateType = "<String>")
#set ($valueListTemplateType = "")
#if ($enableTemplating)
#set ($valueListTemplateType = "<$enumeration.name>")
#if ($stringUtils.isNotBlank($enumeration.literalType.fullyQualifiedName))
#if ($enumeration.literalType.primitive)
#set ($valuesTemplateType = "<${enumeration.literalType.wrapperName}, ${enumeration.name}>")
#set ($literalsTemplateType = "<${enumeration.literalType.wrapperName}>")
#else
#set ($valuesTemplateType = "<${enumeration.literalType.fullyQualifiedName}, ${enumeration.name}>")
#set ($literalsTemplateType = "<${enumeration.literalType.fullyQualifiedName}>")
#end
#set ($namesTemplateType = "<String>")
#end
#if(!$enableTemplating)
#set ($cast = "($enumeration.name)")
#else
#set ($cast = "")
#set ($valuesTemplateType = "<String, ${enumeration.name}>")
#set ($literalsTemplateType = "<String>")
#end
#end
#set ($hasMemberVariables = !(${enumeration.memberVariables.empty()}))
#set ($members = "")
##  -- end --
#if ($stringUtils.isNotBlank($enumeration.packageName))
package $enumeration.packageName;
#end

#if ($XMLBindingAnnotations)
import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlType;
#end
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
#if ($serializable)
import java.io.Serializable;
#end

/**
$enumeration.getDocumentation(" * ")
 */
#if ($XMLBindingAnnotations)
@XmlEnum
@XmlType(name="$enumeration.name")
#end
public enum $enumeration.name
{
#set ($nbLiterals = ${enumeration.literals.size()})
#set ($i = 0)
#foreach ($literal in $enumeration.literals)
#set ($i = $i + 1)
#if ($i == $nbLiterals)
#set ($separator = ";")
#else
#set ($separator = ",")
#end
#set ($quote='"')
#set ($arguments = "($quote${literal.name}$quote)")
#if ($stringUtils.isNotBlank($literal.documentation))
    /** 
$literal.getDocumentation("     * ")
     */
#else
    /** 
     * TODO: Missing Documentation for $literal.name
     */
#end
#if ($XMLBindingAnnotations)
    @XmlEnumValue("$literal.name")
#end
    $literal.name$arguments$separator
#end

#set ($nbMembers = ${enumeration.memberVariables.size()})
#set ($i = 0)
#foreach ($member in $enumeration.memberVariables)
#set ($i = $i + 1)
#if ($i != $nbMembers)
#set ($separator = ", ")
#else
#set ($separator = "")
#end
#set ($members = "${members} ${member.type.fullyQualifiedName} ${member.name}${separator}")
#if ($stringUtils.isNotBlank($member.documentation))
    /**
$member.getDocumentation("     * ")
     */
#end
    private ${member.type.fullyQualifiedName} $member.name;

#end
#if ($serializable)
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = ${enumeration.serialVersionUID}L;

#end
#set ($literalTypeName = "String")
#if ($stringUtils.isNotBlank($enumeration.literalType.fullyQualifiedName))
#set ($literalTypeName = $enumeration.literalType.fullyQualifiedName)
#end
    private final $literalTypeName value;

    /**
     * The constructor with enumeration literal value allowing
     * super classes to access it.
     */
    private ${enumeration.name}($literalTypeName valueIn)
    {
        this.value = valueIn;
    }

#if (!$enumeration.memberVariables.empty)
## From EJB3 cartridge. Need valueIn to avoid compiler error - initialized final static attribute
    /**
     * $enumeration.name constructor with list of member variables
     */
    private ${enumeration.name}($literalTypeName valueIn#foreach ($memberVariable in $enumeration.memberVariables)
        , ${memberVariable.type.fullyQualifiedName} ${memberVariable.name}#end)
    {
        this.value = valueIn;
#foreach ($memberVariable in $enumeration.memberVariables)
        ${memberVariable.setterName}(${memberVariable.name});
#end
    }
#end

    /**
     * @see Object#toString()
     */
#if ($enableAnnotations)
    @Override
#end
    public String toString()
    {
        return String.valueOf(this.value);
    }

#foreach ($member in $enumeration.memberVariables)
#if ($stringUtils.isNotBlank($member.documentation))
    /**
$member.getDocumentation("     * ")
     */
#end
    public $member.type.fullyQualifiedName ${member.getterName}()
    {
        return $member.name;
    }

#end
    /**
     * Retrieves an instance of $enumeration.name from <code>its name</code>.
     *
     * @param name the name to create the $enumeration.name from.
     * @return The enumeration literal named after the 'name' argument
     */
    public static $enumeration.name fromString(String name)
    {
        return ${enumeration.name}.valueOf(name);
    }

    /**
     * Returns a enumeration literal String <code>value</code>.
     * Required by JAXB2 enumeration implementation
     *
     * @return $literalTypeName with corresponding value
     */
    public $literalTypeName value() {
        return name();
    }

    /**
     * Returns an instance of $enumeration.name from String <code>value</code>.
     * Required by JAXB2 enumeration implementation
     *
     * @param value the value to create the $enumeration.name from.
     * @return static Enumeration with corresponding value
     */
    public static $enumeration.name fromValue(String value) {
        for (${enumeration.name} enumName: ${enumeration.name}.values()) {
            if (enumName.getValue().equals(value)) {
                return enumName;
            }
        }
        throw new IllegalArgumentException(value.toString());
    }

    /**
     * Gets the underlying value of this type safe enumeration.
     * This method is necessary to comply with DaoBase implementation.
     * @return The name of this literal.
     */
    public $literalTypeName getValue()
    {
        return this.name();
    }

    /**
     * Returns an unmodifiable list containing the literals that are known by this enumeration.
     *
     * @return A List containing the actual literals defined by this enumeration, this list
     *         can not be modified.
     */
    public static List${literalsTemplateType} literals()
    {
        return ${enumeration.name}.literals;
    }

    /**
     * Returns an unmodifiable list containing the names of the literals that are known
     * by this enumeration.
     *
     * @return A List containing the actual names of the literals defined by this
     *         enumeration, this list can not be modified.
     */
    public static List${namesTemplateType} names()
    {
        return ${enumeration.name}.names;
    }

    private static final Map${valuesTemplateType} VALUES = new LinkedHashMap${valuesTemplateType}($enumeration.literals.size(), 1);
    private static List${literalsTemplateType} literals = new ArrayList${literalsTemplateType}($enumeration.literals.size());
    private static List${namesTemplateType} names = new ArrayList${namesTemplateType}($enumeration.literals.size());
    private static List${valueListTemplateType} valueList = new ArrayList${valueListTemplateType}($enumeration.literals.size());

    /**
     * Initializes the values.
     */
    static
    {
#foreach ($literal in $enumeration.literals)
#set ($value = "${literal.name}.value")
#if($literal.type.primitive)
#set ($value = "new ${literal.type.wrapperName}(${literal.name}.value)")
#end
        VALUES.put($value, $literal.name);
        ${enumeration.name}.valueList.add($literal.name);
        ${enumeration.name}.literals.add($value);
        ${enumeration.name}.names.add("$literal.name");
#end
        ${enumeration.name}.valueList = Collections.unmodifiableList(valueList);
        ${enumeration.name}.literals = Collections.unmodifiableList(literals);
        ${enumeration.name}.names = Collections.unmodifiableList(names);
    }
}
#end