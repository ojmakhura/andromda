#if ($umlUtils.shouldOutput($enumeration))
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: TypeSafeEnumeration.vsl in andromda-java-cartridge.
// Model Class:  $enumeration.validationName
// Metafacade:   org.andromda.metafacades.uml.Enumeration
#foreach ($stereotype in $enumeration.stereotypes)
// Stereotype:  ${stereotype.name}
#end
//
## -- start -- set the map and list types as template parameters if required
#set ($valuesTemplateType = "")
#set ($literalsTemplateType = "")
#set ($literalTypeName = "String")
## This only applies to enumerations modeled as Class <<Enumeration>>. Standard enum literals are always Strings.
#if ($stringUtils.isNotBlank($enumeration.literalType.fullyQualifiedName))
#set ($literalTypeName = $enumeration.literalType.fullyQualifiedName)
#if ($enumeration.literalType.primitive && $enableTemplating)
#set ($valuesTemplateType = "<${enumeration.literalType.wrapperName}, ${enumeration.name}>")
#set ($literalsTemplateType = "<${enumeration.literalType.wrapperName}>")
#end
#end
#set ($namesTemplateType = "<String>")
#set ($valueListTemplateType = "")
#if ($enableTemplating)
#set ($valueListTemplateType = "<$enumeration.name>")
#if ($stringUtils.isNotBlank($enumeration.literalType.fullyQualifiedName))
#if ($enumeration.literalType.primitive)
#set ($valuesTemplateType = "<${enumeration.literalType.wrapperName}, ${enumeration.name}>")
#set ($literalsTemplateType = "<${enumeration.literalType.wrapperName}>")
#else
#set ($valuesTemplateType = "<${enumeration.literalType.fullyQualifiedName}, ${enumeration.name}>")
#set ($literalsTemplateType = "<${enumeration.literalType.fullyQualifiedName}>")
#end
#set ($namesTemplateType = "<String>")
#end
#else
##set ($cast = "")
#set ($valuesTemplateType = "")
#set ($literalsTemplateType = "")
##else
##set ($cast = "($enumeration.name)")
#end
#set ($hasMemberVariables = !(${enumeration.memberVariables.empty()}))
#set ($members = "")
##  -- end --
#if ($stringUtils.isNotBlank($enumeration.packageName))
package $enumeration.packageName;
#end

#if ($XMLBindingAnnotations)
import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlType;
#end
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
$enumeration.getDocumentation(" * ")
 */
#if ($XMLBindingAnnotations)
@XmlEnum
@XmlType(name="$enumeration.name")
#end
public enum $enumeration.name
{
#set ($nbLiterals = ${enumeration.literals.size()})
#set ($i = 0)
#foreach ($literal in $enumeration.literals)
#set ($i = $i + 1)
#if ($i == $nbLiterals)
#set ($separator = ";")
#else
#set ($separator = ",")
#end
#if ($stringUtils.isNotBlank($literal.documentation))
    /** 
$literal.getDocumentation("     * ")
     */
#else
    /** $toDoTag: Model Documentation for Enumeration Literal $literal.name value $literal.enumerationValue */
#end
#if ($XMLBindingAnnotations)
    @XmlEnumValue("$literal.name")
#end
    ${literal.name}($literal.enumerationValue)$separator
#end

#set ($nbMembers = ${enumeration.memberVariables.size()})
#set ($i = 0)
#foreach ($member in $enumeration.memberVariables)
#set ($i = $i + 1)
#if ($i != $nbMembers)
#set ($separator = ", ")
#else
#set ($separator = "")
#end
#set ($members = "${members} ${member.type.fullyQualifiedName} ${member.name}${separator}")
#if ($stringUtils.isNotBlank($member.documentation))
    /**
$member.getDocumentation("     * ")
     */
#end
    private ${member.type.fullyQualifiedName} $member.name;

#end
#if ($serializable)
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = ${enumeration.serialVersionUID}L;

#end
    private final $literalTypeName enumValue;

    /**
     * The constructor with enumeration literal value allowing
     * super classes to access it.
     */
    private ${enumeration.name}($literalTypeName value)
    {
        this.enumValue = value;
    }

#if (!$enumeration.memberVariables.empty)
## From EJB3 cartridge. Need valueIn to avoid compiler error - initialized final static attribute
    /**
     * $enumeration.name constructor with list of member variables
     */
    private ${enumeration.name}($literalTypeName value#foreach ($memberVariable in $enumeration.memberVariables)
        , ${memberVariable.type.fullyQualifiedName} ${memberVariable.name}#end)
    {
        this.enumValue = value;
#foreach ($memberVariable in $enumeration.memberVariables)
        ${memberVariable.setterName}(${memberVariable.name});
#end
    }

#end
    /*
     * Do not override this method directly. Use an alternate name 
     * if providing a different toString implementation
     * @see Object${esc.hash}toString()
#if ($enableAnnotations)
    @Override
#end
    public String toString()
    {
        return String.valueOf(this.enumValue);
    }
     */

#foreach ($member in $enumeration.memberVariables)
#if ($stringUtils.isNotBlank($member.documentation))
    /**
$member.getDocumentation("     * ")
     */
#end
    public $member.type.fullyQualifiedName ${member.getterName}()
    {
        return $member.name;
    }

#end
    /**
     * Retrieves an instance of $enumeration.name from <code>its name</code>.
     *
     * @param name the name to create the $enumeration.name from.
     * @return The enumeration literal named after the 'name' argument
     */
    public static $enumeration.name fromString(String name)
    {
        return ${enumeration.name}.valueOf(name);
    }

    /**
     * Returns an enumeration literal $literalTypeName <code>value</code>.
     * Required by JAXB2 enumeration implementation
     *
     * @return $literalTypeName with corresponding value
     */
    public $literalTypeName value()
    {
        return this.enumValue;
    }

    /**
     * Returns an instance of $enumeration.name from $literalTypeName <code>value</code>.
     * Required by JAXB2 enumeration implementation
     *
     * @param value the value to create the $enumeration.name from.
     * @return static Enumeration with corresponding value
     */
    public static $enumeration.name fromValue($literalTypeName value)
    {
        for (${enumeration.name} enumName: ${enumeration.name}.values())
        {
#if ($enumeration.literalType.primitive)
            if (enumName.getValue() == value)
#set ($exceptionString = "String.valueOf(value)")
#else
            if (enumName.getValue().equals(value))
#if ($enumeration.literalType.stringType)
#set ($exceptionString = "value")
#else
#set ($exceptionString = "value.toString()")
#end
#end
            {
                return enumName;
            }
        }
        throw new IllegalArgumentException("${enumeration.name}.fromValue(" + $exceptionString + ')');
    }

    /**
     * Gets the underlying value of this type safe enumeration.
     * This method is necessary to comply with DaoBase implementation.
     * @return The name of this literal.
     */
    public $literalTypeName getValue()
    {
        return this.enumValue;
    }

    /**
     * Returns an unmodifiable list containing the literals that are known by this enumeration.
     *
     * @return A List containing the actual literals defined by this enumeration, this list
     *         can not be modified.
     */
    public static List${literalsTemplateType} literals()
    {
        return ${enumeration.name}.literals;
    }

    /**
     * Returns an unmodifiable list containing the names of the literals that are known
     * by this enumeration.
     *
     * @return A List containing the actual names of the literals defined by this
     *         enumeration, this list can not be modified.
     */
    public static List${namesTemplateType} names()
    {
        return ${enumeration.name}.names;
    }

    private static Map${valuesTemplateType} values = new LinkedHashMap${valuesTemplateType}($enumeration.literals.size(), 1);
    private static List${literalsTemplateType} literals = new ArrayList${literalsTemplateType}($enumeration.literals.size());
    private static List${namesTemplateType} names = new ArrayList${namesTemplateType}($enumeration.literals.size());
    private static List${valueListTemplateType} valueList = new ArrayList${valueListTemplateType}($enumeration.literals.size());

    /**
     * Initializes the values.
     */
    static
    {
        synchronized (${enumeration.name}.values)
        {
#foreach ($literal in $enumeration.literals)
#if ($literal.type.primitive)
#set ($value = "${enumeration.literalType.wrapperName}.valueOf(${literal.name}.enumValue)")
#else
#set ($value = "${literal.name}.enumValue")
#end
            ${enumeration.name}.values.put($value, $literal.name);
#end
        }
        synchronized (${enumeration.name}.valueList)
        {
#foreach ($literal in $enumeration.literals)
            ${enumeration.name}.valueList.add($literal.name);
#end
            ${enumeration.name}.valueList = Collections.unmodifiableList(valueList);
        }
        synchronized (${enumeration.name}.literals)
        {
#foreach ($literal in $enumeration.literals)
#if ($literal.type.primitive)
#set ($value = "${enumeration.literalType.wrapperName}.valueOf(${literal.name}.enumValue)")
#else
#set ($value = "${literal.name}.enumValue")
#end
            ${enumeration.name}.literals.add($value);
#end
            ${enumeration.name}.literals = Collections.unmodifiableList(literals);
        }
        synchronized (${enumeration.name}.names)
        {
#foreach ($literal in $enumeration.literals)
            ${enumeration.name}.names.add("$literal.name");
#end
            ${enumeration.name}.names = Collections.unmodifiableList(names);
        }
    }
}
#end