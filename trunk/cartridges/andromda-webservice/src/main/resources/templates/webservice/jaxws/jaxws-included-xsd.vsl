#if ($umlUtils.shouldOutput($service))
<!-- Generated by andromda-webservice cartridge (jaxws/jaxws-included-xsd.vsl) on $webServiceUtils.date DO NOT EDIT! -->
#set ($schemaTypes = $service.typeMappingElements)
#set ($quote='"')
#set ($pkgs = $webServiceUtils.getPackages($service, $schemaTypes, $extensionInheritanceDisabled))
#foreach ($pkg in $pkgs)
#if ($pkg.fullyQualifiedName.equals($service.packageName) || !$importedXSD)
    <xs:schema targetNamespace="http://$webServiceUtils.reversePackage($pkg.fullyQualifiedName)#if($addNamespaceBackslash)/#end"
        attributeFormDefault="$pkg.attributeFormDefault.toLowerCase()" elementFormDefault="$pkg.elementFormDefault.toLowerCase()" version="1.0"
        jxb:version="2.1" jxb:extensionBindingPrefixes="xjc"
        xmlns:${service.namespacePrefix}="http://$webServiceUtils.reversePackage($pkg.fullyQualifiedName)#if($addNamespaceBackslash)/#end"
#set ($pkgRefs = $webServiceUtils.getPackageReferences($service, $schemaTypes, $pkg.fullyQualifiedName, $extensionInheritanceDisabled))
##<!-- $pkg $pkg.fullyQualifiedName $pkgRefs $pkgRefs.size() -->
#foreach ($pkgRef in $pkgRefs)
        xmlns:$webServiceUtils.getPkgAbbr($pkgRef)="http://$webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)#if($addNamespaceBackslash)/#end"
#end
        xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
        xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
        xmlns:xs="$xmlSchemaNamespace">
#foreach ($pkgRef in $pkgRefs)
        <xs:import namespace="http://$webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)#if($addNamespaceBackslash)/#end" xmlns="http://www.w3.org/2001/XMLSchema"
#if($importedXSD)          schemaLocation="xsd/${webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)}.xsd"#end/>
#end
#if ($pkg.fullyQualifiedName.equals($service.packageName))
        <!-- Schema Types from service.allowedOperations -->
#foreach ($operation in $service.allowedOperations)
## Bare not possible if any parameters have minOccurs > 1 or default values
#set ($isMany=false)
#foreach ($parameter in $operation.arguments)
#if (!$useArrayWrapper && ($parameter.upper>1 || $parameter.upper==-1))
#set ($isMany=true)
#end
#end
#if ($defaultParameterStyle.equalsIgnoreCase("WRAPPED") || $isMany)
## RequestWrapper must be the same as the operation name, or else the java is Bare instead of wrapped
        <xs:element name="${operation.operationName}">
#if ($stringUtils.isNotBlank($operation.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
$stringUtils.replaceChars($operation.getDocumentation("                ", 100, false), "\"'&<>", "")
            </xs:documentation></xs:annotation>
#end
#if (!$operation.arguments.empty)
            <xs:complexType>
                <xs:sequence>
#foreach ($parameter in $operation.arguments)
##Check first if we have something like Enumeration, Classifier, not a WSDLType
#if (!$parameter.type.wSDLTypeMetaType)
#if ($parameter.type.packageName.equals($pkg.fullyQualifiedName))
#set ($pkgAbbr='impl')
#else
#set ($pkgAbbr=${webServiceUtils.getPkgAbbr($parameter.type.package)})
#end
#set ($type="$pkgAbbr:${parameter.type.name}")
#elseif ($parameter.type.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($parameter.type.packageName) || $parameter.type.schemaType.startsWith("xs:"))
#set ($type=$parameter.type.schemaType)
#else
#set ($type="${webServiceUtils.getPkgAbbr($parameter.type.package)}:$parameter.type.name")
#end
## Metafacade: Parameter.getUpper returns -1 for multiplicity *
#if (!$useArrayWrapper && ($parameter.upper>1 || $parameter.upper==-1))
#set ($isMany=true)
#set ($maxOccurs=' maxOccurs="unbounded"')
#else
#set ($isMany=false)
#set ($maxOccurs='')
#end
##                    <!-- $parameter.name type=$parameter.type.fullyQualifiedName schemaType=$parameter.type.schemaType isMany=$isMany-->
## Determine if attribute/element is a simple schema type when it starts with xs:
##if (!$useAttributes || !$parameter.type.schemaType.startsWith("xs:") || $isMany)
#if ($parameter.defaultValuePresent)
#set ($default=$parameter.defaultValue.replaceAll('"', ''))
##set ($default='"$default"')
#set ($use = " minOccurs=${quote}0$quote default=$quote$default$quote")
#elseif (!$parameter.nillable)
#set ($use = ' minOccurs="1"')
#else
#set ($use = ' minOccurs="0"')
#end
## Parameter of type List should never be nillable, can still be empty size=0. Could cause interoperability problems.
#if ($parameter.upper>1 || $parameter.upper==-1)
#set ($nillable = ' nillable="false"')
#else
#set ($nillable = "")
#end
## Use minOccurs instead of nillable
                    <xs:element name="$parameter.name"#if (!$parameter.hasStereotype("Validation")) type="$type"#end${use}${maxOccurs}${nillable}>
#renderRestrictions($parameter, $type)
#if ($stringUtils.isNotBlank($parameter.getDocumentation("", 9999, false)))
                        <xs:annotation>
                          <xs:documentation>
##    <!-- $stringUtils.containsNone($parameter.getDocumentation("", 64, false), '<') !$stringUtils.containsNone($parameter.getDocumentation("", 64, false), '<') $stringUtils.containsNone($parameter.getDocumentation("", 64, false), "<") -->
$stringUtils.replaceChars($parameter.getDocumentation("                        ", 100, false), "\"'&<>", "")
                          </xs:documentation>
## JAXB does not bind wrapped types properly - always primitive if no customization, always wrapped if customization
#if ($parameter.type.booleanType && $parameter.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                          <xs:appinfo><jxb:property><jxb:baseType>
                            <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                          </jxb:baseType></jxb:property></xs:appinfo>
#end
                        </xs:annotation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#elseif ($parameter.type.booleanType && $parameter.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                        <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                          <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                        </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
##elseif (($parameter.upper>1 || $parameter.upper==-1) && $parameter.unique)
##                        <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
##                          <xjc:javaType name="$parameter.getterSetterTypeName" adapter="$XMLBooleanAdapter"/>
##                        </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
                    </xs:element>
##end
#end
                </xs:sequence>
            </xs:complexType>
#else
            <xs:complexType/>
#end
        </xs:element>
#if ($operation.returnTypePresent || $operation.exceptionsPresent)
        <xs:element name="${operation.operationName}Response">
#if ($operation.returnTypePresent)
#if ($operation.returnType.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($operation.returnType.packageName) || $operation.returnType.schemaType.startsWith("xs:"))
#set ($type=$operation.returnType.schemaType)
#else
#set ($type="${webServiceUtils.getPkgAbbr($operation.returnType.package)}:${operation.returnType.name}")
#end
#if ($operation.returnParameter.lower<1 || $operation.lower<1)
#set ($minOccurs=' minOccurs="0"')
#else
#set ($minOccurs='')
#end
#if (!$useArrayWrapper && ($operation.returnParameter.many || $operation.upper>1 || $operation.upper==-1 || $type.arrayType))
#set ($maxOccurs=' maxOccurs="unbounded"')
#else
#set ($maxOccurs='')
#end
#if ($operation.returnTypePresent)
## Avoid primitive types for wrapper attribute names, reserved keywords
#if ($stringUtils.isNotBlank($operation.returnParameter.name))
#set ($returnName=$stringUtils.uncapitalize($operation.returnParameter.name))
#else
#set ($returnName="#if ($stringUtils.isBlank($operation.returnType.packageName) || $operation.returnType.schemaType.startsWith('xs:'))_#end${operation.returnType.name}")
#end
#else
#set ($returnName=$stringUtils.uncapitalize($operation.operationName))
#end
            <xs:complexType>
                <xs:sequence>
##                    <!-- $type $operation.returnType.name $operation.returnType $operation.returnType.schemaType -->
                    <xs:element name="$returnName" type="$type"${maxOccurs}>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($operation.returnType.booleanType && $operation.returnType.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                      <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                        <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                      </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
                    </xs:element>
                </xs:sequence>
            </xs:complexType>
#else
            <xs:complexType/>
#end
        </xs:element>
#end
#end
#end
## Service exceptions are already included in referenced $types
##        <!-- Service Exception Faults $pkg.fullyQualifiedName $webServiceUtils.getAllowedOperationExceptions($pkg).size() -->
#foreach($exception in $service.allowedOperationExceptions)
        <!-- Exception: $exception.fullyQualifiedName -->
#set ($faultName=$exception.name.replace("Exception", "Fault"))
#set ($faultPkg=$webServiceUtils.getPkgAbbr($exception.package))
#set ($type="$webServiceUtils.getPkgAbbr(${exception.package}):$faultName")
        <xs:element name="$faultName" type="$type"/>
#if ($exception.packageName.equals($service.packageName))
        <xs:complexType name="${exception.name}">
            <xs:sequence>
#foreach($property in $exception.allProperties)
#if($property.lower==0)
#set ($multiplicity="0")
#elseif($property.lower==1)
#set ($multiplicity="1")
#else
#set ($multiplicity="unlimited")
#end
#if ($property.type.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($property.type.packageName) || $property.type.schemaType.startsWith("xs:"))
                <xs:element name="${property.name}" type="${property.type.schemaType}" minOccurs="$multiplicity"/>
#else
                <xs:element name="${property.name}" type="$webServiceUtils.getPkgAbbr(${property.type.package}):${property.type.name}" minOccurs="$multiplicity"/>
#end
#end
            </xs:sequence>
        </xs:complexType>
#end
##end
#end
#if ($defaultParameterStyle.equalsIgnoreCase("BARE"))
        <!-- TypeMapping for bare parameters in foreign namespaces -->
#foreach ($typeMapping in $webServiceUtils.getServiceReferences($service, $extensionInheritanceDisabled))
##if ($typeMapping.type)#set($typeMapping=$typeMapping.type)#end
#set ($type="${webServiceUtils.getPkgAbbr($typeMapping.package)}:${typeMapping.name}")
##        <!-- $typeMapping.name $typeMapping.packageName $typeMapping.type.schemaType -->
## TODO: default value for parameter added to type
        <xs:element name="$typeMapping.name" type="$type"/>
#end
#end
#end
        <!-- Service TypeMapping elements -->
##        <!-- $service $schemaTypes.size() $pkg.fullyQualifiedName -->
#foreach ($typeMapping in $webServiceUtils.getPackageTypes($service, $schemaTypes, $pkg.fullyQualifiedName, $extensionInheritanceDisabled))
#if ($umlUtils.shouldOutput($typeMapping))
#set ($type = $typeMapping)
##        <!-- Type mapping for $type.getSchemaType(false, true): qName=${type.qName} typeName=$typeMapping.name type=$typeMapping.type.name -->
#if ($typeMapping.type)
#set ($type = $typeMapping.type)
#end
#set ($arrayItemName = ${stringUtils.uncapitalize($type.getSchemaType(false, false))})
## TODO: Add nillable option for all minOccurs=0 elements/attributes
#if ($typeMapping.many && $useArrayWrapper)
        <xs:complexType name="$type.wsdlArrayName">
            <xs:sequence>
                <xs:element name="$arrayItemName" minOccurs="0" maxOccurs="unbounded" form="qualified" type="${type.namespacePrefix}:${type.qName}" />
            </xs:sequence>
        </xs:complexType>
#end
## If the declared type ends in [] (configurable metafacade property)
#if ($type.arrayType && $useArrayWrapper)
        <xs:complexType name="$type.getSchemaType(false, true)">
            <xs:sequence>
                <xs:element name="$arrayItemName" minOccurs="0" maxOccurs="unbounded" form="qualified" type="$type.getSchemaType(true, false)" />
            </xs:sequence>
        </xs:complexType>
#else
#* *##if ($type.enumeration)
##       <!-- Enumeration $type.name $type.getSchemaType(false, true): qName=${type.qName} -->
#*     *##foreach ($literal in $type.literals)
##       <!-- $type.name literal: $literal -->
#*         *##if (!$stringUtils.isBlank($literal.type.schemaType))#set ($enumType = $literal.type.schemaType)#end
#*     *##end
#set ($typeName = ${type.name})
        <xs:simpleType name="${typeName}">
#if ($stringUtils.isNotBlank($type.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
$stringUtils.replaceChars($type.getDocumentation("                ", 100, false), "\"'&<>", "")
            </xs:documentation></xs:annotation>
#end
#if ($stringUtils.isBlank($enumType))#set ($enumType = "xs:string")#end
            <xs:restriction base="$enumType">
#*     *##foreach ($literal in $type.literals)
##            <!-- $type.name literal: $literal -->
#if ($stringUtils.isNotBlank($literal.getDocumentation("", 9999, false)))
                <xs:enumeration value="${escapeUtils.escapeXml($literal.enumerationValue.replaceAll('"', ''))}">
                    <xs:annotation><xs:documentation>
$stringUtils.replaceChars($literal.getDocumentation("                        ", 100, false), "\"'&<>", "")
                    </xs:documentation></xs:annotation>
                </xs:enumeration>
#else
                <xs:enumeration value="${escapeUtils.escapeXml($literal.enumerationValue.replaceAll('"', ''))}"/>
#end
#*     *##end
            </xs:restriction>
        </xs:simpleType>
#* *##else
##      <!-- $type $type.name many=$attribute.many namespacePrefix=$type.namespacePrefix packageName=$type.packageName AschemaType=$attribute.type.schemaType qName=$type.qName isMany=$isMany schemaType=$schemaType -->
#set ($webFault = $type.hasStereotype("WebFault") && ($type.hasStereotype("Exception") || $type.hasStereotype("ApplicationException") || $type.hasStereotype("UnexpectedException")))
#if ($webFault)
        <!-- Fault $type.fullyQualifiedName -->
#if ($type.name.contains("Exception"))
#set ($typeName = $type.name.replace("Exception", "Fault"))
#else
#set ($typeName = "${type.name}Fault")
#end
#elseif ($type.hasStereotype("ValueObject"))
#set ($typeName = "$type.name")
        <!-- ValueObject $type.fullyQualifiedName -->
#end
#if ($type.hasStereotype("ValueObject") || $webFault)
##        <!-- WebFault=$type.hasStereotype("WebFault") Exception=$type.hasStereotype("Exception") ApplicationException=$type.hasStereotype("ApplicationException") UnexpectedException=$type.hasStereotype("UnexpectedException") -->
        <xs:element name="$typeName" type="${service.namespacePrefix}:typeName" />
        <xs:complexType name="$typeName">
#if ($stringUtils.isNotBlank($type.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
$stringUtils.replaceChars($type.getDocumentation("                ", 100, false), "\"'&<>", "")
            </xs:documentation></xs:annotation>
#end
#set ($extensionRequired = $type.generalization && !$extensionInheritanceDisabled)
#if ($extensionRequired)
                <xs:complexContent>
                <xs:extension base="${type.generalization.namespacePrefix}:$type.generalization.qName">
#set ($tab="        ")
#else
#set ($tab="")
#end
#set ($attributes = $type.getProperties($extensionInheritanceDisabled))
#set ($otherEnds = $type.getNavigableConnectingEnds($extensionInheritanceDisabled))
##set ($otherEnds = $type.getNavigableConnectingEnds($extensionInheritanceDisabled))
## Output sequence if there are attributes/associations, and there are complex types or if everything is an element
##            <!-- Model: qName=${type.qName} hasComplexTypes=$webServiceUtils.hasComplexTypes($type, $extensionInheritanceDisabled) package=${type.packageName} attributes=$attributes.size() otherEnds=$otherEnds.size() schemaType=${type.getSchemaType(false, true)} otherEnds.empty=$otherEnds.empty attributes.empty=$attributes.empty (!$useAttributes && !$attributes.empty) -->
##            <!-- Model: qName=${type.qName} package=${type.packageName} schemaType=${type.getSchemaType(false, true)} -->
##            <!-- otherEnds=!$otherEnds.empty useAttributes=$useAttributes attributes=$attributes.empty hasComplexTypes=$webServiceUtils.hasComplexTypes($type, $extensionInheritanceDisabled) -->
#if (!$otherEnds.empty||(!$useAttributes && !$attributes.empty) || $webServiceUtils.hasComplexTypes($type, $extensionInheritanceDisabled))
## xs:all indicates elements can exist in any order but can only appear once or not at all - can't use for arrays
## What we really need here is to see if any of the included elements are array elements maxOccurs > 1
#if ($useArrayWrapper)
$tab            <xs:all>
#else
$tab            <xs:sequence>
#end
#foreach ($attribute in $attributes)
#set ($attributeType = $attribute.type)
## Attribute type may be something other than WSDLType, i.e. Enumeration
#if (!$attributeType.wSDLTypeMetaType)
#if ($attributeType.packageName.equals($pkg.fullyQualifiedName))
#set ($pkgAbbr='impl')
#else
#set ($pkgAbbr=${webServiceUtils.getPkgAbbr($attributeType.package)})
#end
#set ($schemaType = "$pkgAbbr:${attributeType.name}")
#elseif ($attribute.many && $useArrayWrapper)
#set ($schemaType = "${attributeType.namespacePrefix}:${attributeType.wsdlArrayName}")
#elseif (!$attributeType.packageName.equals($pkg.fullyQualifiedName) && $stringUtils.isNotBlank($attributeType.packageName) && $attributeType.packageName.indexOf('.')>0 && !$attributeType.schemaType.startsWith("xs:"))
#set ($schemaType = "${webServiceUtils.getPkgAbbr($attributeType.package)}:${attributeType.name}")
#else
#set ($schemaType = "$attribute.type.schemaType")
#end
#if (!$useArrayWrapper && ($attribute.many || $attributeType.arrayType))
#set ($maxOccurs=' maxOccurs="unbounded"')
#set ($isMany=true)
#else
#set ($maxOccurs='')
#set ($isMany=false)
#end
#if ($attribute.defaultValuePresent)
#set ($default=${attribute.defaultValue.replaceAll('"', '')})
#set ($use = ' minOccurs="0" default=$quote$default$quote')
#elseif (!$attribute.nillable)
#set ($use = ' minOccurs="1"')
#else
#set ($use = ' minOccurs="0"')
#end
#if ((!$useAttributes) || ($isMany) || (!$attribute.type.schemaType.startsWith("xs:")))
$tab                <xs:element name="$attribute.name"#if (!$attribute.hasStereotype("Validation")) type="$schemaType"#end${use}${maxOccurs}>
#renderRestrictions($attribute, $schemaType)
#if ($stringUtils.isNotBlank($attribute.getDocumentation("", 9999, false)))
$tab                  <xs:annotation><xs:documentation>
$stringUtils.replaceChars($attribute.getDocumentation("                        ", 100, false), "\"'&<>", "")
$tab                  </xs:documentation></xs:annotation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
$tab                  <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
$tab                    <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
$tab                  </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
#end
$tab                </xs:element>
#end
#end
#if ($useArrayWrapper)
$tab            </xs:all>
#else
$tab            </xs:sequence>
#end
#end
#if ($useAttributes)
#foreach ($attribute in $attributes)
#set ($attributeType = $attribute.type)
#if ($attribute.many || $attributeType.arrayType)
#set ($isMany=true)
#else
#set ($isMany=false)
#end
#if ($attributeType.schemaType.startsWith("xs:") && !$isMany)
## Metafacade: Paramerter.getUpper returns -1 for multiplicity *
## Use optional/required instead of nillable. If default, parameter is always optional
#set ($quote='"')
#if ($attribute.defaultValuePresent)
#set ($default=${attribute.defaultValue.replaceAll('"', '')})
#set ($use = " use=${quote}optional${quote} default=${quote}$default${quote}")
#elseif (!$attribute.nillable)
#set ($use = ' use="required"')
#else
#set ($use = "")
#end
##            <!-- $attribute.name type=$attribute.getterSetterTypeName packageName=$attribute.packageName typeName=$attribute.fullyQualifiedName typeNameMdl=$attribute.getFullyQualifiedName(false) schemaType=$type.schemaType default=$attribute.defaultValuePresent isMany=$isMany -->
$tab            <xs:attribute name="$attribute.name"#if (!$attribute.hasStereotype("Validation")) type="$attributeType.schemaType"#end${use}>
#renderRestrictions($attribute, $attributeType.schemaType)
#if ($stringUtils.isNotBlank($attribute.getDocumentation("", 9999, false)))
$tab              <xs:annotation>
$tab                  <xs:documentation>
$stringUtils.replaceChars($attribute.getDocumentation("                  ", 100, false), "\"'&<>", "")
$tab                  </xs:documentation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
$tab                  <xs:appinfo><jxb:property><jxb:baseType>
$tab                    <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
$tab                  </jxb:baseType></jxb:property></xs:appinfo>
#end
$tab              </xs:annotation>
#else
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
$tab                <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
$tab                  <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
$tab                </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
#end
$tab            </xs:attribute>
#end
#end
#end
#if ($extensionRequired)
            </xs:extension>
            </xs:complexContent>
#end
        </xs:complexType>
#end
#end
#end
#end
#end
    </xs:schema>
#end
#end
#end