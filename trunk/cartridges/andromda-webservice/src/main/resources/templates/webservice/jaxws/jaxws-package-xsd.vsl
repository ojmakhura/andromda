#if ($umlUtils.shouldOutput($pkg))
#set ($pkgTypes = $webServiceUtils.getPackageTypes($pkg, $extensionInheritanceDisabled))
#set ($operations = $webServiceUtils.getAllowedOperations($pkg))
#if (!$pkgTypes.empty || !$operations.empty)
<!-- pkgTypes=$pkgTypes.size() operations=$operations.size() -->
<!-- Generated by andromda-webservice cartridge (jaxws/jaxws-package-xsd.vsl) on $webServiceUtils.date DO NOT EDIT! -->
#set ($quote='"')
    <xs:schema targetNamespace="http://$webServiceUtils.reversePackage($pkg.fullyQualifiedName)#if($addNamespaceBackslash)/#end"
        attributeFormDefault="$pkg.attributeFormDefault.toLowerCase()" elementFormDefault="$pkg.elementFormDefault.toLowerCase()" version="1.0"
        jxb:version="2.1" jxb:extensionBindingPrefixes="xjc"
## ${service.namespacePrefix} refers only to the $service, so we must use impl here and the value must be set to impl in andromda.xml
        xmlns:impl="http://$webServiceUtils.reversePackage($pkg.fullyQualifiedName)#if($addNamespaceBackslash)/#end"
#set ($pkgRefs = $webServiceUtils.getPackageReferences($pkg, $extensionInheritanceDisabled))
#foreach ($pkgRef in $pkgRefs)
        xmlns:$webServiceUtils.getPkgAbbr($pkgRef)="http://$webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)#if($addNamespaceBackslash)/#end"
#end
        xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
        xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
        xmlns:xs="$xmlSchemaNamespace">
#foreach ($pkgRef in $pkgRefs)
        <xs:import namespace="http://$webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)#if($addNamespaceBackslash)/#end" xmlns="http://www.w3.org/2001/XMLSchema"
            schemaLocation="${webServiceUtils.reversePackage($pkgRef.fullyQualifiedName)}.xsd"/>
#end
        <!-- Service TypeMapping elements -->
#foreach ($operation in $operations)
<!-- ${operation.owner.fullyQualifiedName}.${operation.name} -->
## Bare not possible if any parameters have minOccurs > 1 or default values
#set ($isMany=false)
#foreach ($parameter in $operation.arguments)
#if (!$useArrayWrapper && $parameter.many)
#set ($isMany=true)
#end
#end
#if ($defaultParameterStyle.equalsIgnoreCase("WRAPPED") || $isMany)
## RequestWrapper must be the same as the operation name, or else the java is Bare instead of wrapped
        <xs:element name="${operation.operationName}">
#if ($stringUtils.isNotBlank($operation.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($operation.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[
#end
$operation.getDocumentation("                ", 100, false)
#if (!$stringUtils.containsNone($operation.getDocumentation("", 64, false), "\"'&<>"))]]>
#end
            </xs:documentation></xs:annotation>
#end
#if (!$operation.arguments.empty)
            <xs:complexType>
                <xs:sequence>
#foreach ($parameter in $operation.arguments)
##Check first if we have something like Enumeration, Classifier, not a WSDLType
#if (!$parameter.type.wSDLTypeMetaType)
#if ($parameter.type.packageName.equals($pkg.fullyQualifiedName))
#set ($pkgAbbr='impl')
#else
#set ($pkgAbbr=${webServiceUtils.getPkgAbbr($parameter.type.package)})
#end
#set ($type="$pkgAbbr:${parameter.type.name}")
#elseif ($parameter.type.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($parameter.type.packageName) || $parameter.type.schemaType.startsWith("xs:"))
#set ($type=$parameter.type.schemaType)
#else
#set ($type="${webServiceUtils.getPkgAbbr($parameter.type.package)}:$parameter.type.name")
#end
## Metafacade: Parameter.getUpper returns -1 for multiplicity *
#if (!$useArrayWrapper && ($parameter.upper>1 || $parameter.upper==-1))
#set ($isMany=true)
#set ($maxOccurs=' maxOccurs="unbounded"')
#else
#set ($isMany=false)
#set ($maxOccurs='')
#end
##                    <!-- $parameter.name type=$parameter.type.fullyQualifiedName schemaType=$parameter.type.schemaType isMany=$isMany-->
## Determine if attribute/element is a simple schema type when it starts with xs:
##if (!$useAttributes || !$parameter.type.schemaType.startsWith("xs:") || $isMany)
#if ($parameter.defaultValuePresent)
#set ($default=$parameter.defaultValue.replaceAll('"', ''))
##set ($default='"$default"')
#set ($use = " minOccurs=${quote}0$quote default=$quote$default$quote")
#elseif (!$parameter.nillable)
#set ($use = ' minOccurs="1"')
#else
#set ($use = ' minOccurs="0"')
#end
## Parameter of type List should never be nillable, can still be empty size=0. Could cause interoperability problems.
#if ($parameter.many)
#set ($nillable = ' nillable="false"')
#else
#set ($nillable = "")
#end
## Use minOccurs instead of nillable
                    <xs:element name="$parameter.name"#if (!$parameter.hasStereotype("Validation")) type="$type"#end${use}${maxOccurs}${nillable}>
#renderRestrictions($parameter, $type)
#if ($stringUtils.isNotBlank($parameter.getDocumentation("", 9999, false)))
                        <xs:annotation>
                          <xs:documentation>
##    <!-- $stringUtils.containsNone($parameter.getDocumentation("", 64, false), '<') !$stringUtils.containsNone($parameter.getDocumentation("", 64, false), '<') $stringUtils.containsNone($parameter.getDocumentation("", 64, false), "<") -->
#if (!$stringUtils.containsNone($parameter.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[
#end
$parameter.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($parameter.getDocumentation("", 64, false), "\"'&<>"))]]>
#end
                          </xs:documentation>
## JAXB does not bind wrapped types properly - always primitive if no customization, always wrapped if customization
#if ($parameter.type.booleanType && $parameter.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                          <xs:appinfo><jxb:property><jxb:baseType>
                            <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                          </jxb:baseType></jxb:property></xs:appinfo>
#end
                        </xs:annotation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#elseif ($parameter.type.booleanType && $parameter.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                        <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                          <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                        </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
##elseif ($parameter.many && $parameter.unique)
##                        <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
##                          <xjc:javaType name="$parameter.getterSetterTypeName" adapter="$XMLBooleanAdapter"/>
##                        </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
                    </xs:element>
##end
#end
                </xs:sequence>
            </xs:complexType>
#else
            <xs:complexType/>
#end
        </xs:element>
#if ($operation.returnTypePresent || $operation.exceptionsPresent)
        <xs:element name="${operation.operationName}ResponseWrapper">
#if ($operation.returnTypePresent)
#if ($operation.returnType.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($operation.returnType.packageName) || $operation.returnType.schemaType.startsWith("xs:"))
#set ($type=$operation.returnType.schemaType)
#else
#set ($type="${webServiceUtils.getPkgAbbr($operation.returnType.package)}:${operation.returnType.name}")
#end
#if ($operation.returnParameter.lower<1 || $operation.lower<1)
#set ($minOccurs=' minOccurs="0"')
#else
#set ($minOccurs='')
#end
#if (!$useArrayWrapper && ($operation.returnParameter.many || $operation.upper>1 || $operation.upper==-1 || $type.arrayType))
#set ($maxOccurs=' maxOccurs="unbounded"')
#else
#set ($maxOccurs='')
#end
#if ($operation.returnTypePresent)
## Avoid primitive types for wrapper attribute names, reserved keywords
#if ($stringUtils.isNotBlank($operation.returnParameter.name))
#set ($returnName=$stringUtils.uncapitalize($operation.returnParameter.name))
#else
#set ($returnName="#if ($stringUtils.isBlank($operation.returnType.packageName) || $operation.returnType.schemaType.startsWith('xs:'))_#end${operation.returnType.name}")
#end
#else
#set ($returnName=$stringUtils.uncapitalize($operation.operationName))
#end
            <xs:complexType>
                <xs:sequence>
##                    <!-- $type $operation.returnType.name $operation.returnType $operation.returnType.schemaType -->
                    <xs:element name="$returnName" type="$type"${maxOccurs}>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($operation.returnType.booleanType && $operation.returnType.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                      <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                        <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                      </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
                    </xs:element>
                </xs:sequence>
            </xs:complexType>
#else
            <xs:complexType/>
#end
        </xs:element>
#end
#end
#end
## Service exceptions are already included in referenced $types
        <!-- Service Exception Faults $webServiceUtils.getAllowedOperationExceptions($pkg).size() -->
#foreach($exception in $webServiceUtils.getAllowedOperationExceptions($pkg))
        <!-- $exception.fullyQualifiedName $exception -->
#if ($exception.associationEnds.empty)
#set ($faultName=$exception.name.replace("Exception", "Fault"))
#set ($faultPkg=$webServiceUtils.getPkgAbbr($exception.package))
#else
#set ($faultName=$exception.associationEnds.get(0).otherEnd.type.name)
#set ($faultPkg=$webServiceUtils.getPkgAbbr($exception.associationEnds.get(0).otherEnd.type.package))
#end
#set ($type="$webServiceUtils.getPkgAbbr(${exception.package}):$faultName")
        <xs:element name="$faultName" type="$type"/>
#if ($exception.packageName.equals($pkg))
        <xs:complexType name="${exception.name}">
            <xs:sequence>
#foreach($property in $exception.allProperties)
#if($property.lower==0)
#set ($multiplicity="0")
#elseif($property.lower==1)
#set ($multiplicity="1")
#else
#set ($multiplicity="unlimited")
#end
#if ($property.type.packageName.equals($pkg.fullyQualifiedName) || $stringUtils.isBlank($property.type.packageName) || $property.type.schemaType.startsWith("xs:"))
                <xs:element name="${property.name}" type="${property.type.schemaType}" minOccurs="$multiplicity"/>
#else
                <xs:element name="${property.name}" type="$webServiceUtils.getPkgAbbr(${property.type.package}):${property.type.name}" minOccurs="$multiplicity"/>
#end
#end
            </xs:sequence>
        </xs:complexType>
#end
##end
#end
#foreach ($type in $pkgTypes)
#if ($umlUtils.shouldOutput($type))
#set ($arrayItemName = ${stringUtils.uncapitalize($type.getSchemaType(false, false))})
## TODO: Add nillable option for all minOccurs=0 elements/attributes
#if ($type.many && $useArrayWrapper)
        <xs:complexType name="$type.wsdlArrayName">
            <xs:sequence>
                <xs:element name="$arrayItemName" minOccurs="0" maxOccurs="unbounded" form="qualified" type="${type.namespacePrefix}:${type.qName}" />
            </xs:sequence>
        </xs:complexType>
#end
## If the declared type ends in [] (configurable metafacade property)
#if ($type.arrayType && $useArrayWrapper)
        <xs:complexType name="$type.getSchemaType(false, true)">
            <xs:sequence>
                <xs:element name="$arrayItemName" minOccurs="0" maxOccurs="unbounded" form="qualified" type="$type.getSchemaType(true, false)" />
            </xs:sequence>
        </xs:complexType>
#else
#* *##if ($type.enumeration)
##       <!-- Enumeration $type.name $type.getSchemaType(false, true): qName=${type.qName} -->
#*     *##foreach ($literal in $type.literals)
##       <!-- $type.name literal: $literal -->
#*         *##if (!$stringUtils.isBlank($literal.type.schemaType))#set ($enumType = $literal.type.schemaType)#end
#*     *##end
#if ($stringUtils.isBlank($type.qName))#set ($typeName = ${type.name})#else#set ($typeName = $type.qName)#end
        <xs:simpleType name="${typeName}">
#if ($stringUtils.isNotBlank($type.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($type.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[
#end
$type.getDocumentation("                ", 100, false)
#if (!$stringUtils.containsNone($type.getDocumentation("", 64, false), "\"'&<>"))]]>
#end
            </xs:documentation></xs:annotation>
#end
#if ($stringUtils.isBlank($enumType))#set ($enumType = "xs:string")#end
            <xs:restriction base="$enumType">
#*     *##foreach ($literal in $type.literals)
##            <!-- $type.name literal: $literal -->
#if ($stringUtils.isNotBlank($literal.getDocumentation("", 9999, false)))
                <xs:enumeration value="${escapeUtils.escapeXml($literal.enumerationValue.replaceAll('"', ''))}">
                    <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($literal.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[
#end
$literal.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($literal.getDocumentation("", 64, false), "\"'&<>"))]]>
#end
                    </xs:documentation></xs:annotation>
                </xs:enumeration>
#else
                <xs:enumeration value="${escapeUtils.escapeXml($literal.enumerationValue.replaceAll('"', ''))}"/>
#end
#*     *##end
            </xs:restriction>
        </xs:simpleType>
#* *##else
##        <!-- $type $type.name many=$attribute.many namespacePrefix=$type.namespacePrefix packageName=$type.packageName AschemaType=$attribute.type.schemaType qName=$type.qName isMany=$isMany schemaType=$schemaType -->
#if ($type.hasStereotype("ValueObject"))
#if ($type.hasStereotype("WebFault") && $type.hasStereotype("Exception") || $type.hasStereotype("ApplicationException") || $type.hasStereotype("UnexpectedException"))
        <!-- Fault $type.fullyQualifiedName -->
#if ($type.name.contains("Exception"))
#set ($typeName = $type.name.replace("Exception", "Fault"))
#else
#set ($typeName = "${type.name}Fault")
#end
#else
#set ($typeName = "$type.qName")
        <!-- ValueObject $type.fullyQualifiedName -->
#end
##        <!-- WebFault=$type.hasStereotype("WebFault") Exception=$type.hasStereotype("Exception") ApplicationException=$type.hasStereotype("ApplicationException") UnexpectedException=$type.hasStereotype("UnexpectedException") -->
        <xs:element name="$typeName" type="impl:$typeName" />
        <xs:complexType name="$typeName">
#if ($stringUtils.isNotBlank($type.getDocumentation("", 9999, false)))
            <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($type.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[
#end
$type.getDocumentation("                ", 100, false)
#if (!$stringUtils.containsNone($type.getDocumentation("", 64, false), "\"'&<>"))]]>
#end
            </xs:documentation></xs:annotation>
#end
#set ($extensionRequired = $type.generalization && !$extensionInheritanceDisabled)
#if ($extensionRequired)
                <xs:complexContent>
                <xs:extension base="${type.generalization.namespacePrefix}:$type.generalization.qName">
#end
#set ($attributes = $type.getAttributes($extensionInheritanceDisabled))
#set ($otherEnds = $type.getNavigableConnectingEnds($extensionInheritanceDisabled))
##set ($otherEnds = $type.getNavigableConnectingEnds($extensionInheritanceDisabled))
## Output sequence if there are attributes/associations, and there are complex types or if everything is an element
##            <!-- Model: qName=${type.qName} hasComplexTypes=$webServiceUtils.hasComplexTypes($type, $extensionInheritanceDisabled) package=${type.packageName} attributes=$attributes.size() otherEnds=$otherEnds.size() schemaType=${type.getSchemaType(false, true)} otherEnds.empty=$otherEnds.empty attributes.empty=$attributes.empty (!$useAttributes && !$attributes.empty) -->
##            <!-- Model: qName=${type.qName} package=${type.packageName} schemaType=${type.getSchemaType(false, true)} -->
##            <!-- otherEnds=!$otherEnds.empty useAttributes=$useAttributes attributes=$attributes.empty hasComplexTypes=$webServiceUtils.hasComplexTypes($type, $extensionInheritanceDisabled) -->
#if (!$otherEnds.empty||(!$useAttributes && !$attributes.empty) || $webServiceUtils.hasComplexTypes($type, $extensionInheritanceDisabled))
## xs:all indicates elements can exist in any order but can only appear once or not at all - can't use for arrays
## What we really need here is to see if any of the included elements are array elements maxOccurs > 1
#if ($useArrayWrapper)
            <xs:all>
#else
            <xs:sequence>
#end
#foreach ($attribute in $attributes)
#set ($attributeType = $attribute.type)
## Attribute type may be something other than WSDLType, i.e. Enumeration
#if (!$attributeType.wSDLTypeMetaType)
#if ($attributeType.packageName.equals($pkg.fullyQualifiedName))
#set ($pkgAbbr='impl')
#else
#set ($pkgAbbr=${webServiceUtils.getPkgAbbr($attributeType.package)})
#end
#set ($schemaType = "$pkgAbbr:${attributeType.name}")
#elseif ($attribute.many && $useArrayWrapper)
#set ($schemaType = "${attributeType.namespacePrefix}:${attributeType.wsdlArrayName}")
#elseif (!$attributeType.packageName.equals($pkg.fullyQualifiedName) && $stringUtils.isNotBlank($attributeType.packageName) && $attributeType.packageName.indexOf('.')>0 && !$attributeType.schemaType.startsWith("xs:"))
#set ($schemaType = "${webServiceUtils.getPkgAbbr($attributeType.package)}:${attributeType.qName}")
#else
#set ($schemaType = "$attribute.type.schemaType")
#end
#if (!$useArrayWrapper && ($attribute.many || $attributeType.arrayType))
#set ($maxOccurs=' maxOccurs="unbounded"')
#set ($isMany=true)
#else
#set ($maxOccurs='')
#set ($isMany=false)
#end
#if ($attribute.defaultValuePresent)
#set ($default=${attribute.defaultValue.replaceAll('"', '')})
#set ($use = ' minOccurs="0" default=$quote$default$quote')
#elseif (!$attribute.nillable)
#set ($use = ' minOccurs="1"')
#else
#set ($use = ' minOccurs="0"')
#end
#if ((!$useAttributes) || ($isMany) || (!$attribute.type.schemaType.startsWith("xs:")))
                <xs:element name="$attribute.name"#if (!$attribute.hasStereotype("Validation")) type="$schemaType"#end${use}${maxOccurs}>
#renderRestrictions($attribute, $schemaType)
#if ($stringUtils.isNotBlank($attribute.getDocumentation("", 9999, false)))
                    <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($attribute.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[
#end
$attribute.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($attribute.getDocumentation("", 64, false), "\"'&<>"))]]>
#end
                    </xs:documentation></xs:annotation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                    <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                      <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                    </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
#end
                </xs:element>
#end
#*     *##end
##if (!$otherEnds.empty)
##                <!-- Model associationEnds -->
##end
#foreach ($otherEnd in $otherEnds)
#set ($otherEndType = $otherEnd.type)
#if ($otherEnd.many && $useArrayWrapper)
#set ($schemaType = "${otherEndType.namespacePrefix}:${otherEndType.wsdlArrayName}")
#elseif ($otherEndType.packageName.equals($pkg.fullyQualifiedName) && $stringUtils.isNotBlank($otherEndType.packageName) && $otherEndType.packageName.indexOf('.')>0)
#if ($stringUtils.isBlank(${otherEndType.namespacePrefix}) || $stringUtils.isBlank(${otherEndType.qName}))
#set ($schemaType = "${service.namespacePrefix}:${otherEndType.name}")
#else
#set ($schemaType = "${otherEndType.namespacePrefix}:${otherEndType.qName}")
#end
#else
#if ($otherEndType.packageName.equals($pkg.fullyQualifiedName)))
#set ($schemaType = "${service.namespacePrefix}:${otherEndType.name}")
#elseif ($stringUtils.isBlank(${otherEndType.qName}))
#set ($schemaType = "${webServiceUtils.getPkgAbbr($otherEndType.package)}:${otherEndType.name}")
#else
#set ($schemaType = "${webServiceUtils.getPkgAbbr($otherEndType.package)}:${otherEndType.qName}")
#end
#end
#if (!$useArrayWrapper && ($otherEnd.many || $otherEndType.arrayType))
#set ($maxOccurs=' maxOccurs="unbounded"')
#else
#set ($maxOccurs='')
#end
##                <!-- $otherEnd.name type.packageName=$type.packageName schemaType=$schemaType type.qName=$type.qName type.arrayType=$type.arrayType -->
#if ($stringUtils.isNotBlank($otherEnd.getDocumentation("", 9999, false)))
                <xs:element name="$otherEnd.name" type="${schemaType}"#if ($otherEnd.nillable) minOccurs="0"#else minOccurs="1"#end${maxOccurs}>
                    <xs:annotation><xs:documentation>
#if (!$stringUtils.containsNone($otherEnd.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[
#end
$otherEnd.getDocumentation("                        ", 100, false)
#if (!$stringUtils.containsNone($otherEnd.getDocumentation("", 64, false), "\"'&<>"))]]>
#end
                    </xs:documentation></xs:annotation>
                </xs:element>
#else
                <xs:element name="$otherEnd.name" type="${schemaType}"#if ($otherEnd.nillable) minOccurs="0"#else minOccurs="1"#end${maxOccurs}/>
#end
#end
#if ($useArrayWrapper)
            </xs:all>
#else
            </xs:sequence>
#end
#end
#if ($useAttributes)
#foreach ($attribute in $attributes)
#set ($attributeType = $attribute.type)
#if ($attribute.many || $attributeType.arrayType)
#set ($isMany=true)
#else
#set ($isMany=false)
#end
#if ($attributeType.schemaType.startsWith("xs:") && !$isMany)
## Metafacade: Paramerter.getUpper returns -1 for multiplicity *
## Use optional/required instead of nillable. If default, parameter is always optional
#set ($quote='"')
#if ($attribute.defaultValuePresent)
##if ($attribute.type.name.equals("String") || $attribute.type.name.equals("Character") || $attribute.type.name.equals("char"))
##set ($default='"' + ${attribute.defaultValue.replaceAll('"', '')} + '"')
##else
#set ($default=${attribute.defaultValue.replaceAll('"', '')})
##end
#set ($use = " use=${quote}optional${quote} default=${quote}$default${quote}")
#elseif (!$attribute.nillable)
#set ($use = ' use="required"')
#else
#set ($use = "")
#end
##            <!-- $attribute.name type=$attribute.getterSetterTypeName packageName=$attribute.packageName typeName=$attribute.fullyQualifiedName typeNameMdl=$attribute.getFullyQualifiedName(false) schemaType=$type.schemaType default=$attribute.defaultValuePresent isMany=$isMany -->
            <xs:attribute name="$attribute.name"#if (!$attribute.hasStereotype("Validation")) type="$attributeType.schemaType"#end${use}>
#renderRestrictions($attribute, $attributeType.schemaType)
#if ($stringUtils.isNotBlank($attribute.getDocumentation("", 9999, false)))
              <xs:annotation>
                <xs:documentation>
#if (!$stringUtils.containsNone($attribute.getDocumentation("", 64, false), "\"'&<>"))<![CDATA[
#end
$attribute.getDocumentation("                  ", 100, false)
#if (!$stringUtils.containsNone($attribute.getDocumentation("", 64, false), "\"'&<>"))]]>
#end
                </xs:documentation>
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
                <xs:appinfo><jxb:property><jxb:baseType>
                  <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
                </jxb:baseType></jxb:property></xs:appinfo>
#end
              </xs:annotation>
#else
## JAXB does not bind wrapped types properly - always primitive if no custimization, always wrapped if customization
#if ($attribute.type.booleanType && $attribute.type.wrappedPrimitive && $stringUtils.isNotBlank($XMLBooleanAdapter))
              <xs:annotation><xs:appinfo><jxb:property><jxb:baseType>
                <xjc:javaType name="Boolean" adapter="$XMLBooleanAdapter"/>
              </jxb:baseType></jxb:property></xs:appinfo></xs:annotation>
#end
#end
            </xs:attribute>
#end
#end
#end
#*     *##if ($extensionRequired)
            </xs:extension>
            </xs:complexContent>
#*     *##end
        </xs:complexType>
##if ($type.hasStereotype("WebFault") && $type.hasStereotype("ValueObject"))
##        </xs:element>
##end
##end
#end
#end
#end
#end
#end
    </xs:schema>
#end
#end