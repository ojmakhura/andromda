// license-header java merge-point
/* Autogenerated by AndroMDA (SessionBean.vsl) - do not edit */
#parse("templates/ejb3/Globals.vm")
#if ($stringUtils.isNotBlank($service.packageName))
package $service.packageName;
#end
#set ($generatedFile = "${stringUtils.replace($service.fullyQualifiedServiceName,'.','/')}.java")

/**
 * Autogenerated EJB session bean class ${service.serviceName}.
 *
$service.getDocumentation(" * ")
 */
 
// Do not specify the javax.ejb.${service.type} annotation
// Instead, define the session bean in the ejb-jar.xml descriptor
// @javax.ejb.${service.type}

#if ($service.transactionManagement)
@javax.ejb.TransactionManagement(javax.ejb.TransactionManagementType.${service.transactionManagement})
#end
#if (!$service.transactionManagementBean)
#**##if ($service.transactionType)
@javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${service.transactionType})
#**##end
#end
#if ($stringUtils.isNotBlank($service.securityRealm))
#**##if ($service.persistenceContainerJboss)
@org.jboss.annotation.security.SecurityDomain("${service.securityRealm}")
#**##end
#end
#if ($service.runAs)
@javax.annotation.security.RunAs("${service.runAs}")
#end
#if ($service.jndiNameRemote)
#**##if ($service.persistenceContainerJboss)
@org.jboss.annotation.ejb.RemoteBinding(jndiBinding = "${service.jndiNameRemote}")
#**##end
#end
#if ($service.jndiNameLocal)
#**##if ($service.persistenceContainerJboss)
@org.jboss.annotation.ejb.LocalBinding(jndiBinding = "${service.jndiNameLocal}")
#**##end
#end
#if ($service.viewTypeLocal)
@javax.ejb.Local({${service.fullyQualifiedServiceLocalInterfaceName}.class})
#end
#if ($service.viewTypeRemote)
@javax.ejb.Remote({${service.fullyQualifiedServiceRemoteInterfaceName}.class})
#end

#set ($interceptors = $service.interceptorReferences)
#if ($collectionUtils.size($interceptors) >= 1 || $service.listenerEnabled)
#**##if ($service.listenerEnabled) 
#*  *##set ($lifecycleCallback = "${service.fullyQualifiedServiceListenerName}.class")
#**##else 
#*  *##set ($lifecycleCallback = "")
#**##end
// Lifecycle callback listeners and interceptors are defined in ejb-jar.xml
// @javax.ejb.Interceptors({$transform.getInterceptorsAsList(${interceptors}, ${lifecycleCallback})})
#end
#if ($service.excludeDefaultInterceptors)
// @javax.ejb.ExcludeDefaultInterceptors
#end

public abstract class ${service.serviceName}
#if($service.generalization)
    extends ${service.generalization.fullyQualifiedName}BeanImpl
#end
    implements#if ($service.viewTypeLocal) ${service.fullyQualifiedServiceLocalInterfaceName}#if ($service.viewTypeRemote),#end#end#if ($service.viewTypeRemote) ${service.fullyQualifiedServiceRemoteInterfaceName}#end

{
    // ------ Session Context Injection ------
    
    @javax.annotation.Resource
    protected javax.ejb.SessionContext context;
#if ($service.transactionManagementBean)

    // ---------- User Transaction Injection ---------
    
    @javax.annotation.Resource
    protected javax.transaction.UserTransaction userTrans;
#end

    // ------ Persistence Context Definitions --------
    
#set ($argExists = false)
    /**
     * Inject persistence context #if ($service.persistenceContextUnitName)${service.persistenceContextUnitName}#end
     
     */
    @javax.persistence.PersistenceContext#if ($service.persistenceContextUnitName || $service.persistenceContextType)(#end#if ($service.persistenceContextUnitName)unitName = "${service.persistenceContextUnitName}"#set ($argExists = true)#end#if ($service.persistenceContextType)#if ($argExists),#end type = javax.persistence.PersistenceContextType.${service.persistenceContextType}#end#if ($service.persistenceContextUnitName || $service.persistenceContextType))#end
    
    protected javax.persistence.EntityManager emanager;
#foreach ($persistenceContext in $service.persistenceContextReferences)
#**##set ($argExists = false)

    /**
     * Inject persistence context #if ($persistenceContext.unitName)${persistenceContext.unitName}#end
     
     */
    @javax.persistence.PersistenceContext#if ($persistenceContext.unitName || $persistenceContext.contextType)(#end#if ($persistenceContext.unitName)unitName = "${persistenceContext.unitName}"#set ($argExists = true)#end#if ($persistenceContext.contextType)#if ($argExists),#end type = javax.persistence.PersistenceContextType.${persistenceContext.contextType}#end#if ($persistenceContext.unitName || $persistenceContext.contextType))#end
     
    protected javax.persistence.EntityManager $stringUtils.uncapitalize(${persistenceContext.name});
#end
#set ($references = $service.serviceReferences)
#if (!$references.empty)

    // ------ EJB Injection Definitions --------
#**##foreach ($dependency in $references)
#*  *##set ($reference = $dependency.targetElement)

    /**
     * Inject session EJB ${reference.name}
     */
    @javax.annotation.EJB
    protected ${reference.fullyQualifiedServiceRemoteInterfaceName} $stringUtils.uncapitalize(${reference.name});
#**##end
#end
#set ($mdbReferences = $service.messageDrivenReferences)
#if (!$mdbReferences.empty)

    // ------ Message Driven EJB Injection Definitions --------
    
#**##foreach ($dependency in $mdbReferences)
#*  *##set ($reference = $dependency.targetElement)
#*  *##if ($reference.destinationTypeQueue)
#*    *##if (!$queueConnectionFactoryDefined)
    @javax.annotation.Resource(mappedName = "java:/JmsXA")
    protected javax.jms.QueueConnectionFactory queueFactory;
#*      *##set ($queueConnectionFactoryDefined = true)

#*    *##end
#*  *##elseif ($reference.destinationTypeTopic)
#*    *##if (!$topicConnectionFactoryDefined)
    @javax.annotation.Resource(mappedName = "java:/JmsXA")
    protected javax.jms.TopicConnectionFactory topicFactory;
#*      *##set ($topicConnectionFactoryDefined = true)

#*    *##end
#*  *##end
    /**
     * Inject ${reference.destinationType}
     */
    @javax.annotation.Resource(mappedName = "${reference.destination}")
## NOTE: CHANGE TO USE mappedName
    protected javax.jms.Destination $stringUtils.uncapitalize(${reference.name});
#**##end
#end
#set ($constants = $service.getConstants(true))
#if (!$constants.empty)

    // ----------- Constant Definitions -----------
    
#**##foreach($constant in $constants)
    private static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;
#**##end
#end
#set ($instanceAttributes = $service.instanceAttributes)
#if(!$instanceAttributes.empty)

    // --------- Attribute Definitions ------------
    
#**##foreach ($attribute in $instanceAttributes)
    /**
     * The $attribute.name property
     */
    protected $attribute.type.fullyQualifiedName $attribute.name;
    
#**##end
#end
#set ($envEntries = $service.getEnvironmentEntries(true))
#if (!$envEntries.empty)

    // ---------- Env Entry Injection -----------
    
#**##foreach ($envEntry in $envEntries)
    /**
     * The $envEntry.name resource injection
     */
    @javax.annotation.Resource(name = "${envEntry.name}")
    protected $envEntry.type.fullyQualifiedName $envEntry.name;
    
#**##end
#end
    
    // --------------- Constructors ---------------
    
## Default create method with no arguments.
    public ${service.serviceName}()
    {
        super();
    }
## Autogenerated create method with all attributes. Only present for stateful beans.
#set ($allAttributes = $service.allInstanceAttributes)
#if (!$allAttributes.empty)

    /**
     * Constructor with all attribute values.
#**##set ($inheritedAttributes = $service.inheritedInstanceAttributes)
#**##foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the ${attribute.name} property
#**##end
     */
    public ${service.serviceName}($service.getAttributesAsList($allAttributes, true, true))
    {
#**##if(!$inheritedAttributes.empty)
        super($service.getAttributesAsList($inheritedAttributes, false, true));
#**##end
#**##foreach ($attribute in $service.instanceAttributes)
## Don't use a setter here - we may have none if the attribute is marked readonly
        this.$attribute.name = $attribute.name;
#**##end
    }
#end
#if (!$constants.empty)

    // --------- Accessors for Constants ----------
    
#**##foreach($constant in $constants)
#*  *##if ($constant.visibility == "public")
    /**
     * Get the <code>$constant.name</code> constant
$constant.getDocumentation("     * ")
     */
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}()
    {
        return $constant.name;
    }
    
#*  *##end
#**##end
#end
#if(!$instanceAttributes.empty)

    // ------- Accessors for Attributes ----------
    
#**##foreach ($attribute in $instanceAttributes)
#*  *##set ($visibility = $attribute.visibility)
#*  *##if ($visibility == "public")
    /**
     * Get the ${attribute.name} property
$attribute.getDocumentation("     * ")
     */
#*    *##if (!$service.transactionManagementBean)
#*      *##if ($attribute.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${attribute.transactionType})
#*      *##end
#*    *##end
    $visibility $attribute.type.fullyQualifiedName ${attribute.getterName}() 
    {
       return $attribute.name;
    }
## Only generate a setter if the attribute is not read-only
#*    *##if (!$attribute.readOnly)

    /**
     * Set the $attribute.name property
     * @param value the new value
     */
#*      *##if (!$service.transactionManagementBean)
#*        *##if ($attribute.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${attribute.transactionType})
#*        *##end
#*      *##end
    $visibility void ${attribute.setterName}($attribute.type.fullyQualifiedName value) 
    {
       this.$attribute.name = value;
    }

#*    *##end
#*  *##end
#**##end
#end
#set ($operations = $service.businessOperations)
#if (!$operations.empty)

    // -------- Business Methods  --------------
    
#**##foreach ($operation in $operations)
##
## Check that operation is NOT a lifecycle callback
##
#*  *##if (!$operation.lifecycleCallback)
    /**
$operation.getDocumentation("     * ")
     */
#*    *##if (!$service.transactionManagementBean)
#*      *##if ($operation.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${operation.transactionType})
#*      *##end
#*    *##end
#*    *##if ($service.securityEnabled)
#*      *##if ($stringUtils.isBlank(${operation.rolesAllowed}))
#*        *##if ($operation.denyAll)
    @javax.annotation.security.DenyAll
#*        *##else
    @javax.annotation.security.PermitAll
#*        *##end
#*      *##else
    @javax.annotation.security.RolesAllowed({${operation.rolesAllowed}})
#*      *##end
#*    *##end
#*    *##if ($operation.flushMode)
    @javax.persistence.FlushMode(javax.persistence.FlushModeType.${operation.flushMode})
#*    *##end
#*    *##if ($operation.timeoutCallback)
    @javax.ejb.Timeout
#*    *##end
#*    *##set ($interceptors = $operation.interceptorReferences)
#*    *##if ($collectionUtils.size($interceptors) >= 1)
    // Interceptors are defined in ejb-jar.xml
    // @javax.ejb.Interceptors({$transform.getInterceptorsAsList(${interceptors}, "")})
#*    *##end
#*    *##if ($operation.excludeDefaultInterceptors)
    // Interceptor default exclusions are defined in ejb-jar.xml
    // @javax.ejb.ExcludeDefaultInterceptors
#*    *##end
#*    *##if ($operation.excludeClassInterceptors)
    // Interceptor class exclusions are defined in ejb-jar.xm
    // @javax.ejb.ExcludeClassInterceptors
#*    *##end
    $operation.visibility $operation.returnType.fullyQualifiedName $operation.signature
#*    *##if ($operation.exceptionsPresent)
        $operation.throwsClause
#*    *##end
    {
#*    *##if ($requiredCheckEnabled)
#*      *##foreach ($argument in $operation.arguments)
#*        *##if ($argument.required && !$argument.type.primitive)
        if ($argument.name == null)
        {
            throw new IllegalArgumentException(
                "${service.fullyQualifiedServiceName}.${operation.signature} - '${argument.name}' can not be null");
        }
#*        *##end
#*      *##end
#*    *##end
#*    *##if ($operation.constraintsPresent)
        this.$operation.preconditionCall;
#*    *##end
        try
        {
#*    *##set ($call = "this.${operation.implementationCall};")
#*    *##if ($operation.returnTypePresent)
            return $call
#*    *##else
            $call
#*    *##end
        }
#*    *##foreach($exception in $operation.exceptions)
        catch ($exception.fullyQualifiedName ex)
        {
            throw ex;
        }
#*    *##end
#*    *##if ($service.allowDefaultServiceException)
        catch (Throwable th)
        {
            throw new ${service.fullyQualifiedDefaultExceptionName}(
                "Error performing '${service.fullyQualifiedName}.${operation.signature}' --> " + th,
                th);
        }
#*    *##end
    }
    
#*    *##if ($operation.constraintsPresent)
    /**
     * Performs any precondition checks for {@link #${operation.call}}.
     */
    private void $operation.preconditionSignature
    {
#renderPreconditions($operation)
    }

#*    *##end
    /**
     * Performs the core logic for {@link #${operation.getSignature(false)}}
     */
    protected abstract $operation.returnType.fullyQualifiedName $operation.implementationSignature
        throws java.lang.Exception;

#*  *##end
#**##end
#end
#if (!$operations.empty)

    // -------- Lifecycle Callbacks --------------
    
#**##foreach ($operation in $operations)
#*  *##if ($operation.lifecycleCallback)
    /**
$operation.getDocumentation("     * ")
     */
#*    *##if ($operation.postConstruct)
    @javax.ejb.PostConstruct
#*    *##elseif ($operation.preDestroy)
    @javax.ejb.PreDestroy
#*    *##end
#*    *##if ($service.stateful)
#*      *##if ($operation.postActivate)
    @javax.ejb.PostActivate
#*      *##elseif ($operation.prePassivate)
    @javax.ejb.PrePassivate
#*      *##end
#*    *##end
    $operation.visibility void ${operation.name}()
    {
        this.handle${stringUtils.capitalize(${operation.name})}();
    }
    
    /**
     * Performs the core logic for {@link #${operation.name}()}
     */
    protected abstract $operation.returnType.fullyQualifiedName handle${stringUtils.capitalize(${operation.name})}();
        
#*  *##end
#**##end
#end

    // ------------ Generic Methods ------------
    
    /**
     * Generic remove method
     */
	@javax.ejb.Remove
	public void remove() {
		handleRemove();
	}
	
	/**
	 * Performs the core logic for {@link #remove())
	 */
	protected abstract void handleRemove();
}