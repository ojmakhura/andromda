// license-header java merge-point
/* Autogenerated by AndroMDA (SessionBean.vsl) - do not edit */
#if ($stringUtils.isNotBlank($service.packageName))
package $service.packageName;
#end
#set ($generatedFile = "${stringUtils.replace($service.fullyQualifiedServiceName,'.','/')}.java")

/**
 * Autogenerated EJB entity POJO class for the ${service.serviceName} session bean.
 *
$service.getDocumentation(" * ")
 */
/**
 * Do not specify the javax.ejb.${service.type} annotation
 * Instead, define the session bean in the ejb-jar.xml descriptor
 * javax.ejb.${service.type}
 */
#if ($service.transactionManagement)
@javax.ejb.TransactionManagement(javax.ejb.TransactionManagementType.${service.transactionManagement})
#end
#if (!$service.transactionManagementBean)
#**##if ($service.transactionType)
@javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${service.transactionType})
#**##end
#end
@javax.ejb.CallbackListener(${service.fullyQualifiedServiceListenerName}.class)
#if ($stringUtils.isNotBlank($service.securityRealm))
#**##if ($service.persistenceContainerJboss)
@org.jboss.annotation.security.SecurityDomain("${service.securityRealm}")
#**##end
#end
#if ($service.permitAll)
@javax.annotation.security.PermitAll
#elseif ($service.denyAll)
@javax.annotation.security.DenyAll
#elseif ($service.rolesAllowed)
@javax.annotation.security.RolesAllowed({${service.rolesAllowed}})
#end
#if ($service.runAs)
@javax.annotation.security.RunAs("${service.runAs}")
#end
#if ($service.jndiNameRemote)
#**##if ($service.persistenceContainerJboss)
@org.jboss.annotation.ejb.RemoteBinding(jndiBinding = "${service.jndiNameRemote}")
#**##end
#end
#if ($service.jndiNameLocal)
#**##if ($service.persistenceContainerJboss)
@org.jboss.annotation.ejb.LocalBinding(jndiBinding = "${service.jndiNameLocal}")
#**##end
#end
#if ($service.viewTypeLocal)
@javax.ejb.Local({${service.fullyQualifiedServiceLocalInterfaceName}.class})
#end
#if ($service.viewTypeRemote)
@javax.ejb.Remote({${service.fullyQualifiedServiceRemoteInterfaceName}.class})
#end
#set ($interceptors = $service.interceptorReferences)
#if ($collectionUtils.size($interceptors) == 1)
@javax.ejb.Interceptor($service.getInterceptorsAsList($interceptors))
#elseif ($collectionUtils.size($interceptors) > 1)
@javax.ejb.Interceptors({$service.getInterceptorsAsList($interceptors)})
#end
public abstract class ${service.serviceName}
#if($service.generalization)
    extends ${service.generalization.fullyQualifiedName}BeanImpl
#end
    implements#if ($service.viewTypeLocal) ${service.fullyQualifiedServiceLocalInterfaceName}#if ($service.viewTypeRemote),#end#end#if ($service.viewTypeRemote) ${service.fullyQualifiedServiceRemoteInterfaceName}#end

{
    // ------ Session Context Injection ------
    
    @javax.annotation.Resource
    protected javax.ejb.SessionContext context;
#if ($service.transactionManagementBean)

    // ---------- User Transaction Injection ---------
    
    @javax.annotation.Resource
    protected javax.transaction.UserTransaction userTrans;
#end

    // ------ Persistence Context Definitions --------
    
#set ($argExists = false)
    /**
     * Inject persistence context #if ($service.persistenceContextUnitName)${service.persistenceContextUnitName}#end
     
     */
    @javax.persistence.PersistenceContext#if ($service.persistenceContextUnitName || $service.persistenceContextType)(#end#if ($service.persistenceContextUnitName)unitName = "${service.persistenceContextUnitName}"#set ($argExists = true)#end#if ($service.persistenceContextType)#if ($argExists),#end type = javax.persistence.PersistenceContextType.${service.persistenceContextType}#end#if ($service.persistenceContextUnitName || $service.persistenceContextType))#end
    
    protected javax.persistence.EntityManager emanager;
#foreach ($reference in $service.persistenceContextReferences)
#**##set ($persistenceContext = $reference.targetElement)
#**##set ($argExists = false)

    /**
     * Inject persistence context #if ($persistenceContext.persistenceContextUnitName)${persistenceContext.persistenceContextUnitName}#end
     
     */
    @javax.persistence.PersistenceContext#if ($persistenceContext.persistenceContextUnitName || $persistenceContext.persistenceContextType)(#end#if ($persistenceContext.persistenceContextUnitName)unitName = "${persistenceContext.persistenceContextUnitName}"#set ($argExists = true)#end#if ($persistenceContext.persistenceContextType)#if ($argExists),#end type = javax.persistence.PersistenceContextType.${persistenceContext.persistenceContextType}#end#if ($persistenceContext.persistenceContextUnitName || $persistenceContext.persistenceContextType))#end 
    protected javax.persistence.EntityManager ${persistenceContext.name};
#end
#set ($references = $service.serviceReferences)
#if (!$references.empty)

    // ------ EJB Injection Definitions --------
#**##foreach ($dependency in $references)
#*  *##set ($reference = $dependency.targetElement)

    /**
     * Inject session EJB ${reference.name}
     */
    @javax.annotation.EJB
    protected ${reference.fullyQualifiedServiceRemoteInterfaceName} $stringUtils.uncapitalize(${reference.name});
#**##end
#end
#set ($mdbReferences = $service.messageDrivenReferences)
#if (!$mdbReferences.empty)

    // ------ Message Driven EJB Injection Definitions --------
    
#**##foreach ($dependency in $mdbReferences)
#*  *##set ($reference = $dependency.targetElement)
#*  *##if ($reference.destinationTypeQueue)
#*    *##if (!$queueConnectionFactoryDefined)
    @javax.annotation.Resource(mappedName = "ConnectionFactory")
    protected javax.jms.QueueConnectionFactory queueFactory;
#*      *##set ($queueConnectionFactoryDefined = true)
    
#*    *##end
#*  *##elseif ($reference.destinationTypeTopic)
#*    *##if (!$topicConnectionFactoryDefined)
    @javax.annotation.Resource(mappedName = "ConnectionFactory")
    protected javax.jms.TopicConnectionFactory topicFactory;
#*      *##set ($topicConnectionFactoryDefined = true)

#*    *##end
#*  *##end
    /**
     * Inject ${reference.destinationType}
     */
    @javax.annotation.Resource(mappedName = "${reference.destination}")
## NOTE: CHANGE TO USE mappedName
    protected javax.jms.Destination $stringUtils.uncapitalize(${reference.name});
#**##end
#end
#set ($constants = $service.getConstants(true))
#if (!$constants.empty)

    // ----------- Constant Definitions -----------
    
#**##foreach($constant in $constants)
    private static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;
#**##end
#end
#set ($instanceAttributes = $service.instanceAttributes)
#if(!$instanceAttributes.empty)

    // --------- Attribute Definitions ------------
    
#**##foreach ($attribute in $instanceAttributes)
    /**
     * The $attribute.name property
     */
    protected $attribute.type.fullyQualifiedName $attribute.name;
    
#**##end
#end
#set ($envEntries = $service.getEnvironmentEntries(true))
#if (!$envEntries.empty)

    // ---------- Env Entry Injection -----------
    // NOTE: environment entry resource injection is not
    // available spec compliant until RC4
    
#**##foreach ($envEntry in $envEntries)
    /**
     * The $envEntry.name resource injection
     */
    @javax.annotation.Resource
    protected $envEntry.type.fullyQualifiedName $envEntry.name;
    
#**##end
#end
    
    // --------------- Constructors ---------------
    
## Default create method with no arguments.
    public ${service.serviceName}()
    {
        super();
    }
## Autogenerated create method with all attributes. Only present for stateful beans.
#set ($allAttributes = $service.allInstanceAttributes)
#if (!$allAttributes.empty)

    /**
     * Constructor with all attribute values.
#**##set ($inheritedAttributes = $service.inheritedInstanceAttributes)
#**##foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the ${attribute.name} property
#**##end
     */
    public ${service.serviceName}($service.getAttributesAsList($allAttributes, true, true))
    {
#**##if(!$inheritedAttributes.empty)
        super($service.getAttributesAsList($inheritedAttributes, false, true));
#**##end
#**##foreach ($attribute in $service.instanceAttributes)
## Don't use a setter here - we may have none if the attribute is marked readonly
        this.$attribute.name = $attribute.name;
#**##end
    }
#end
#if (!$constants.empty)

    // --------- Accessors for Constants ----------
    
#**##foreach($constant in $constants)
#*  *##if ($constant.visibility == "public")
    /**
     * Get the <code>$constant.name</code> constant
$constant.getDocumentation("     * ")
     */
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}()
    {
        return $constant.name;
    }
    
#*  *##end
#**##end
#end
#if(!$instanceAttributes.empty)

    // ------- Accessors for Attributes ----------
    
#**##foreach ($attribute in $instanceAttributes)
#*  *##set ($visibility = $attribute.visibility)
#*  *##if ($visibility == "public")
    /**
     * Get the ${attribute.name} property
$attribute.getDocumentation("     * ")
     */
#*    *##if (!$service.transactionManagementBean)
#*      *##if ($attribute.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${attribute.transactionType})
#*      *##end
#*    *##end
    $visibility $attribute.type.fullyQualifiedName ${attribute.getterName}() 
    {
       return $attribute.name;
    }
## Only generate a setter if the attribute is not read-only
#*    *##if (!$attribute.readOnly)

    /**
     * Set the $attribute.name property
     * @param value the new value
     */
#*      *##if (!$service.transactionManagementBean)
#*        *##if ($attribute.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${attribute.transactionType})
#*        *##end
#*      *##end
    $visibility void ${attribute.setterName}($attribute.type.fullyQualifiedName value) 
    {
       this.$attribute.name = value;
    }

#*    *##end
#*  *##end
#**##end
#end
#set ($operations = $service.businessOperations)
#if (!$operations.empty)

    // -------- Business Methods  --------------
    
#**##foreach ($operation in $operations)
#*  *##set ($visibility = $operation.visibility)
## Only public methods have transactions and are exported to the interfaces
#*  *##if ($visibility == "public")
    /**
$operation.getDocumentation("     * ")
     */
#*    *##if (!$service.transactionManagementBean)
#*      *##if ($operation.transactionType)
    @javax.ejb.TransactionAttribute(javax.ejb.TransactionAttributeType.${operation.transactionType})
#*      *##end
#*    *##end
#*    *##if ($operation.permitAll)
    @javax.annotation.security.PermitAll
#*    *##elseif ($operation.denyAll)
    @javax.annotation.security.DenyAll
#*    *##elseif ($operation.rolesAllowed)
    @javax.annotation.security.RolesAllowed({${operation.rolesAllowed}})
#*    *##end
#*    *##if ($operation.flushMode)
    @javax.persistence.FlushMode(javax.persistence.FlushModeType.${operation.flushMode})
#*    *##end
#*    *##if ($operation.timeoutCallback)
    @javax.ejb.Timeout
#*    *##end
#*    *##set ($returnType = $operation.returnType.fullyQualifiedName)
#*    *##if ($operation.exceptionsPresent)
    $visibility abstract $returnType $operation.signature $operation.throwsClause;
#*    *##else
    $visibility abstract $returnType $operation.signature;
#*    *##end

#*  *##end
#**##end
#end
}