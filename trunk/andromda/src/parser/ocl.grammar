/*
   OCL 2.0 grammar for SableCC parser generator.
   This file is used to produce OCL parser with related classes
   and data structures. SableCC is a parser generator tool and can
   be obtained at http://www.sablecc.org/   or
   http://www.sourceforge.net/projects/sablecc

*/

Package org.andromda.core.translation;

Helpers

  	all = [0..127];
  	lf = 10;
  	cr = 13;

	letter = [['A'..'Z'] + ['a'..'z']];
  	digit = ['0'..'9'];
  	number = digit+;

  	line_terminator = lf | cr | cr lf;
  	input_character = [all - [cr + lf]];

  	simple_escape_sequence =
  		'\' ''' | '\"' | '\?' | '\\' |
        '\a' | '\b' | '\f' | '\n' | '\r' | '\t' | '\v';
  	octal_digit = ['0' .. '7'];
  	octal_escape_sequence =
  		'\' octal_digit octal_digit? octal_digit?;

  	hexadecimal_digit = [digit + [['a' .. 'f'] + ['A' .. 'F']]];

  	hexadecimal_escape_sequence = '\x' hexadecimal_digit+;

  	escape_sequence =
  		simple_escape_sequence |
        octal_escape_sequence |
        hexadecimal_escape_sequence;

  	s_char = [all - [''' + ['\' + [lf + cr]]]] | escape_sequence;
  	s_char_sequence = s_char+;
  	h_set = 'Set';
  	h_bag = 'Bag';
  	h_sequence = 'Sequence';
    h_orderedset = 'OrderedSet';
  	h_collection = 'Collection';

  	h_tupletype = 'TupleType';
  	h_tuple = 'Tuple';

Tokens

  	comment = '--' [[all - 10] - 13]* [10 + 13]?;

  	dot = '.';
  	arrow = '->';

  	is_sent_operator = '^';
  	message_operator = '^^';

  	not = 'not';

  	mult = '*';
  	div = '/';
  	plus = '+';
  	minus = '-';

  	package = 'package';
  	endpackage = 'endpackage';
  	init = 'init';
  	derive = 'derive';
  	def = 'def';
	attr = 'attr';
	oper = 'oper';

  	context = 'context';
  	enum = 'enum';
  	pre = 'pre';
  	post = 'post';
  	inv = 'inv';
  	body = 'body';

  	is_empty = 'isEmpty';
  	not_empty = 'notEmpty';
  	size = 'size';
  	sum = 'sum';
  	as_bag = 'asBag';
  	as_ordered_set = 'asOrderedSet';
  	as_sequence = 'asSequence';
  	as_set = 'asSet';
  	flatten = 'flatten';
  	last = 'last';
  	at = 'at';
  	count = 'count';
  	excludes= 'excludes';
  	excludes_all = 'excludesAll';
  	includes = 'includes';
  	includes_all = 'includesAll';
  	append = 'append';
  	excluding = 'excluding';
  	including = 'including';
  	index_of = 'indexOf';
  	intersection = 'intersection';
  	prepend = 'prepend';
  	symmetric_difference = 'symmetricDifference';
  	union = 'union';
  	any = 'any';
  	collect = 'collect';
  	collect_nested = 'collectNested';
  	exists = 'exists';
  	for_all = 'forAll';
  	is_unique = 'isUnique';
  	one = 'one';
  	reject = 'reject';
  	select = 'select';
  	sorted_by = 'sortedBy';
    insert_at = 'insertAt';
    sub_ordered_set= 'subOrderedSet';
    sub_sequence = 'subSequence';
    iterate = 'iterate';

    ocl_is_new = 'oclIsNew';
    ocl_as_type = 'oclAsType';
    ocl_in_state = 'oclInState';
    ocl_is_type_of = 'oclIsTypeOf';
    ocl_is_kind_of = 'oclIsKindOf';

  	equal = '=';
  	not_equal = '<>';
  	lt = '<';
  	gt = '>';
  	lteq = '<=';
  	gteq = '>=';

  	and = 'and';
  	or = 'or';
  	xor = 'xor';
  	implies = 'implies';

  	l_paren = '(';
  	r_paren = ')';
  	l_bracket = '[';
  	r_bracket = ']';
  	l_brace = '{';
  	r_brace = '}';
  	semicolon = ';';

  	scope_operator = '::';
  	colon = ':';
  	comma = ',';

  	commercial_at = '@';
  	bar = '|';
  	range = '..';
  	apostrophe = ''';
  	unknown = '?';

  	let = 'let';
  	in = 'in';

  	if = 'if';
  	then = 'then';
  	else = 'else';
  	endif = 'endif';

  	set = h_set;
  	bag = h_bag;
  	sequence = h_sequence;
  	collection = h_collection;
  	orderedset = h_orderedset;

  	tuple = h_tuple;
  	tupletype = h_tupletype;

  	boolean = 'true' | 'false';

  	name = letter ([[digit + '_'] + letter])*;

  	new_line = line_terminator;
  	int = number;
  	real = number '.' number;
  	blank = 9 | ' '*;
  	tab = 9;

  	string_lit = ''' s_char_sequence? ''';

Ignored Tokens

  	comment,
  	new_line,
  	blank,
 	tab;

Productions

    // package declaration
   declaration =
    	{package} package name path_name_tail* context_declaration* endpackage |
    	{context} context_declaration* ;

   	context_declaration =
   		{classifier} context name path_name_tail* classifier_expression_body+ |
   		{operation} context name path_name_tail* scope_operator operation operation_expression_body+ |
   		{attribute_or_association} context name path_name_tail* scope_operator attribute_or_association_expression_body+;

   	attribute_or_association_expression_body =
		name type_declaration initial_or_derived_value ;

	scope_operator_name =
		scope_operator name ;

	initial_or_derived_value =
		{init} init colon expression initial_or_derived_value? |
		{derive} derive colon expression initial_or_derived_value? ;

  	classifier_expression_body =
  		{def} def name? colon definition_expression |
  		{inv} inv name? colon expression ;

  	definition_expression =
  		{variable} name type_declaration? equal expression |
  		{operation} operation equal expression? ;

  	operation_expression_body =
  		operation_stereotype name? colon expression ;

    operation =
    	name l_paren [parameters]:variable_declaration_list? r_paren [return_type_declaration]:type_declaration? ;

    variable_declaration =
    	name type_declaration? ;

    type_declaration =
    	colon type ;

    variable_declaration_list =
    	variable_declaration [variable_declaration_value]:equal_expression? variable_declaration_list_tail* ;

    variable_declaration_list_tail =
    	comma variable_declaration [variable_declaration_value]:equal_expression?;

    equal_expression =
    	equal expression ;

   	operation_stereotype =
   		{body} body |
   		{pre} pre |
   		{post} post ;

  	expression =
    	{let} let_exp+ |
    	{logical} logical_exp |
    	{message} message_exp;

  	if_expression =
    	if [if_branch]:expression
    	then [then_branch]:expression
    	else [else_branch]:expression
    	endif ;

  	// a logical 'and, 'or', 'xor, ... expression
  	logical_exp =
    	relational_expression logical_expression_tail* ;

  	logical_expression_tail =
    	logical_operator relational_expression ;

    // a relational '<, '>', ... expression.
  	relational_expression =
    	additive_expression relational_expression_tail? ;

  	relational_expression_tail =
    	relational_operator additive_expression ;

    //an addition '+, '-' expression
  	additive_expression =
    	multiplicative_expression additive_expression_tail* ;

  	additive_expression_tail =
    	add_operator multiplicative_expression ;

    // a multiplication expression (i.e. 4 * 5)
  	multiplicative_expression =
    	unary_expression multiplicative_expression_tail* ;

  	multiplicative_expression_tail =
    	multiply_operator unary_expression ;

    // a unary '-, 'not' expression
  	unary_expression =
    	unary_operator? property_call_expression ;

    // a property call expression, done through '.' or '->'.
  	property_call_expression =
    	primary_expression property_call_expression_tail* ;

 	property_call_expression_tail =
     	 {dot} dot dot_feature_call |
     	 {arrow} arrow arrow_feature_call ;

  	primary_expression =
    	{literal} literal |
    	{feature} path_name is_marked_pre? qualifiers? feature_call_parameters? |
    	{parentheses} l_paren expression r_paren |
    	{if} if_expression ;

  	feature_call_parameters =
    	{concrete} l_paren expression? feature_call_parameter_option* r_paren |
    	(l_paren declarator? actual_parameter_list? r_paren) ;

  	declarator =
    	{standard} variable_declaration_list bar |
    	{iterate} [iterator]:variable_declaration semicolon
      		[accumulator]:variable_declaration equal_expression? bar;

  	declarator_tail =
    	comma name ;

    comma_expression =
    	comma expression ;

 	feature_call_parameter_option =
    	{comma} comma expression |
    	{colon} type_declaration |
    	{iterate} semicolon name type_declaration equal expression |
    	{bar} bar expression ;

  	// 'let ...'
  	let_exp =
    	let let_variable_delaration let_exp_sub ;

    let_exp_sub =
  		{variable_declaration} comma let_variable_delaration let_exp_sub |
  		{in} in logical_exp ;

  	let_variable_delaration =
  		variable_declaration equal expression ;

  	literal =
    	{collection} collection_lit |
    	{primitive} primitive_lit |
    	{tuple} tuple_lit ;

    primitive_lit =
    	{string} string_lit |
    	{real} real |
    	{integer} int |
    	{boolean} boolean ;

    tuple_lit =
    	tuple l_brace variable_declaration_list r_brace ;

  	collection_lit =
    	collection_kind l_brace expression_list_or_range? r_brace ;

  	expression_list_or_range =
    	expression expression_list_or_range_tail? ;

  	expression_list_or_range_tail =
    	{list} comma_expression+ |
    	{range} range expression ;

  	dot_feature_call =
    	path_name is_marked_pre? qualifiers? feature_call_parameters? ;

  	arrow_feature_call =
  	    {empty} arrow_no_parameter_feature_call l_paren r_paren |
  	    {single} arrow_single_parameter_feature_call l_paren [first_param]:arrow_feature_call_parameter r_paren |
  	    {double} arrow_double_parameter_feature_call l_paren [first_param]:arrow_feature_call_parameter comma [second_param]:arrow_feature_call_parameter r_paren ;

    arrow_feature_call_parameter =
        {simple} [expression]:expression |
        {expression} [expression]:expression bar [option]:expression ;     

    // todo: what to do with iterate(...) ?

    arrow_no_parameter_feature_call =
  	    {is_empty} is_empty |
  	    {not_empty} not_empty |
  	    {size} size |
  	    {sum} sum |
  	    {as_bag} as_bag |
  	    {as_ordered_set} as_ordered_set |
  	    {as_sequence} as_sequence |
  	    {as_set} as_set |
  	    {flatten} flatten |
  	    {last} last ;

    arrow_single_parameter_feature_call =
  	    {at} at |
  	    {count} count |
  	    {excludes} excludes |
  	    {excludes_all} excludes_all |
  	    {includes} includes |
  	    {includes_all} includes_all |
  	    {append} append |
  	    {excluding} excluding |
  	    {including} including |
    	{index_of} index_of |
    	{intersection} intersection |
    	{prepend} prepend |
    	{symmetric_difference} symmetric_difference |
    	{union} union |
    	{any} any |
    	{collect} collect |
    	{collect_nested} collect_nested |
    	{exists} exists |
    	{for_all} for_all |
    	{is_unique} is_unique |
    	{one} one |
    	{reject} reject |
    	{select} select |
    	{sorted_by} sorted_by ;

    arrow_double_parameter_feature_call =
        {insert_at} insert_at |
        {sub_ordered_set} sub_ordered_set |
        {sub_sequence} sub_sequence ;

 	qualifiers =
    	l_bracket actual_parameter_list r_bracket ;

  	type =
    	{simple} path_name |
    	{collection} collection_type |
    	{tupletype} tuple_type;

    collection_type =
    	{set} set l_paren type r_paren |
    	{bag} bag l_paren type r_paren |
    	{sequence} sequence l_paren type r_paren |
    	{orderedset} orderedset l_paren type r_paren |
    	{collection} collection l_paren type r_paren ;

    tuple_type =
    	tupletype l_paren variable_declaration_list? r_paren ;

    message_exp =
    	{message} expression message_operator name l_paren message_arguments? r_paren |
    	{is_sent} expression is_sent_operator name l_paren message_arguments? r_paren ;

    message_arguments =
    	message_argument message_arguments_tail* ;

    message_arguments_tail =
    	comma message_argument ;

    message_argument =
    	{type} unknown type_declaration? |
    	{exp} expression ;

  	path_name =
  		name path_name_tail* ;

  	path_name_tail =
    	scope_operator name;

  	is_marked_pre =
    	commercial_at pre ;

  	actual_parameter_list =
    	expression comma_expression* ;

  	logical_operator =
    	{and}     and |
    	{or}      or |
    	{xor}     xor |
    	{implies} implies;

  	collection_kind =
    	{set} set |
    	{bag} bag |
    	{sequence} sequence |
    	{collection} collection ;

  	relational_operator =
    	{equal}   equal |
   	 	{not_equal} not_equal |
    	{gt}      gt |
    	{lt}      lt |
    	{gteq}    gteq |
    	{lteq}    lteq ;

  	add_operator =
    	{plus}  plus |
    	{minus} minus;

 	multiply_operator =
    	{mult}  mult |
    	{div}   div;

  	unary_operator =
    	{minus} minus |
    	{not}   not;
