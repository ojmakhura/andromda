#set ($generatedFile = "${entity.packagePath}/${entity.name}Specifications.java")
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end

import org.springframework.data.jpa.domain.Specification;

public final class ${entity.name}Specifications {
    
#set ($entityIdVariable = $stringUtils.uncapitalize(${entity.name}).substring(0,1))
#foreach($attribute in $entity.attributes)
    // Generating specifications for $attribute.name
#set ($capitalised = ${stringUtils.capitalize($attribute.name)})
#if(!$attribute.type.clobType && !$attribute.type.blobType && !$attribute.type.fileType)
#if(!$attribute.required)
    public static Specification<$entity.name> findBy${capitalised}Null() {
        return (root, cq, cb) -> {
            
            return cb.isNull(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"));
        };
    }

    public static Specification<$entity.name> findBy${capitalised}NotNull() {
        return (root, cq, cb) -> {
            
            return cb.isNotNull(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"));
        };
    }

#end   
#if(!$attribute.booleanType)
    public static Specification<$entity.name> findBy${capitalised}($attribute.type.fullyQualifiedName $attribute.name) {
        return (root, cq, cb) -> {
            
            return cb.equal(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"), $attribute.name);
        };
    }

    public static Specification<$entity.name> findBy${capitalised}NotEqual($attribute.type.fullyQualifiedName $attribute.name) {
        return (root, cq, cb) -> {
            
            return cb.notEqual(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"), $attribute.name);
        };
    }

#else
    public static Specification<$entity.name> findBy${capitalised}False(){
        return (root, cq, cb) -> {
            
            return cb.isFalse(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"));
        };
    }

    public static Specification<$entity.name> findBy${capitalised}True(){
        return (root, cq, cb) -> {
            
            return cb.isTrue(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"));
        };
    }

#end
#end
## Other derived queries
#if($attribute.type.stringType)
    public static Specification<$entity.name> findBy${capitalised}StartingWithIgnoreCase($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.equal(cb.upper(root.<$attribute.type.fullyQualifiedName>get("$attribute.name")), ${attribute.name}.toUpperCase() + "%");
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}EndingWithIgnoreCase($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.equal(cb.upper(root.<$attribute.type.fullyQualifiedName>get("$attribute.name")), "%" + ${attribute.name}.toUpperCase());
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}ContainingIgnoreCase($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.equal(cb.upper(root.<$attribute.type.fullyQualifiedName>get("$attribute.name")), "%" + ${attribute.name}.toUpperCase() + "%");
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}LikeIgnoreCase($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.like(cb.upper(root.<$attribute.type.fullyQualifiedName>get("$attribute.name")), "%" + ${attribute.name}.toUpperCase() + "%");
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}NotLikeIgnoreCase($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.notLike(cb.upper(root.<$attribute.type.fullyQualifiedName>get("$attribute.name")), "%" + ${attribute.name}.toUpperCase() + "%");
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}Containing($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.like(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"), "%" + ${attribute.name}.toUpperCase() + "%");
        };
    }
    
#elseif($umlMetafacadeUtils.isNumber( $attribute.type) || $attribute.type.dateType)
    public static Specification<$entity.name> findBy${capitalised}LessThan($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.lessThan(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"), $attribute.name);
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}LessThanEqual($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.lessThanOrEqualTo(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"), $attribute.name);
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}GreaterThan($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.greaterThan(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"), $attribute.name);
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}GreaterThanEqual($attribute.type.fullyQualifiedName $attribute.name){
        return (root, cq, cb) -> {
            
            return cb.greaterThanOrEqualTo(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"), $attribute.name);
        };
    }
    
    public static Specification<$entity.name> findBy${capitalised}Between($attribute.type.fullyQualifiedName ${attribute.name}Start, $attribute.type.fullyQualifiedName ${attribute.name}End){
        return (root, cq, cb) -> {
            
            return cb.between(root.<$attribute.type.fullyQualifiedName>get("$attribute.name"), ${attribute.name}Start, ${attribute.name}End);
        };
    }

#end
#if($attribute.many)
    public static Specification<$entity.name> findBy${capitalised}In(java.util.Collection<$attribute.type.fullyQualifiedName> ${attribute.name}In){

        return (root, cq, cb) -> {
            
            return root.join("${attribute.name}").in(${attribute.name}In);
        };
    }

#else
    public static Specification<$entity.name> findBy${capitalised}In(java.util.Collection<$attribute.type.fullyQualifiedName> ${attribute.name}In){

        return (root, cq, cb) -> {
            
            return root.<$attribute.type.fullyQualifiedName>get("${attribute.name}").in(${attribute.name}In);
        };
    }

#end
#end
#foreach ($associationEnd in $entity.associationEnds)
#set ($target = $associationEnd.otherEnd)
#if($target.navigable)
#set ($capitalised = ${stringUtils.capitalize($target.name)})
#set ($joinEntity = $target.type)
#if($joinEntity.identifiersPresent)
#foreach($identifier in $joinEntity.identifiers)
#set ($capitalisedIdentifier = ${stringUtils.capitalize($identifier.name)})
    // Specifications for $target.getterSetterTypeName $target.name
    public static Specification<$entity.name> findBy${capitalised}${capitalisedIdentifier}In(java.util.Collection<$identifier.type.fullyQualifiedName> ${identifier.name}s) {
        return (root, cq, cb) -> {
            
#if ($associationEnd.many2One)
            // Many to One
#elseif ($associationEnd.one2Many)
            // One to Many
#elseif ($associationEnd.one2One)
            // One to One
#elseif ($associationEnd.many2Many)
            // Many to Many
#end
            
            javax.persistence.criteria.Join<$entity.name, $target.type.fullyQualifiedEntityName> ${target.name}Join = root.join("$target.name");
            return cb.in(${target.name}Join.get("$identifier.name").in(${identifier.name}s));
        };
    }

    public static Specification<$entity.name> findBy${capitalised}Null() {
        return (root, cq, cb) -> {
            
            return cb.isNull(root.<$target.type.fullyQualifiedName>get("$target.name"));
        };
    }

    public static Specification<$entity.name> findBy${capitalised}NotNull() {
        return (root, cq, cb) -> {
            
            return cb.isNotNull(root.<$target.type.fullyQualifiedName>get("$target.name"));
        };
    }

    public static Specification<$entity.name> findBy${capitalised}${capitalisedIdentifier}($identifier.type.fullyQualifiedName ${identifier.name}) {
        return (root, cq, cb) -> {
            
#if ($associationEnd.many2One)
            // Many to One
#elseif ($associationEnd.one2Many)
            // One to Many
#elseif ($associationEnd.one2One)
            // One to One
#elseif ($associationEnd.many2Many)
            // Many to Many
#end
            
            javax.persistence.criteria.Join<$entity.name, $target.type.fullyQualifiedEntityName> ${target.name}Join = root.join("$target.name");
            return cb.equal(${target.name}Join.get("$identifier.name"), ${identifier.name});
        };
    }

#end
#end
#end
#end
#set ($finders = $entity.getQueryOperations(false))
#foreach($finder in $finders)
## Only interested in criteriaFinder methods
#if($finder.criteriaFinder)
#set($criteriaArgument = $finder.criteriaArgument)
#set($criteriaArgumentName = $criteriaArgument.name)
#set($criteriaClass = $criteriaArgument.type)
#foreach($criteriaAttribute in $criteriaClass.getAttributes(true))
#set($isJoin = $hibernateUtils.isJoin($criteriaAttribute.attributeName))
#set($joinLength = $hibernateUtils.joinLength($criteriaAttribute.attributeName))
#if($isJoin && $joinLength > 1 && !(${criteriaAttribute.attributeName.endsWith(".id")} && $joinLength < 3))
#set ($capitalised = $stringUtils.capitalize($hibernateUtils.getAttributeName($criteriaAttribute.attributeName)))
#set ($specName = "findBy${capitalised}")
#set ($attributeName = $criteriaAttribute.attributeName)
#set ($getter = "get$stringUtils.capitalize($criteriaAttribute.name)()")
#set ($comparator = "equal")
#if($criteriaAttribute.comparatorPresent)
#set ($comparator = "$criteriaAttribute.comparatorConstant $criteriaAttribute.comparator")
#if($criteriaAttribute.comparatorConstant == "LIKE_COMPARATOR")
#set ($comparator = "like")
#elseif($criteriaAttribute.comparatorConstant == "INSENSITIVE_LIKE_COMPARATOR")
#set ($comparator = "like")
#elseif($criteriaAttribute.comparatorConstant == "EQUAL_COMPARATOR")
#set ($comparator = "equal")
#elseif($criteriaAttribute.comparatorConstant == "GREATER_THAN_OR_EQUAL_COMPARATOR")
#set ($comparator = "greaterThanOrEqualTo")
#elseif($criteriaAttribute.comparatorConstant == "GREATER_THAN_COMPARATOR")
#set ($comparator = "greaterThan")
#elseif($criteriaAttribute.comparatorConstant == "LESS_THAN_OR_EQUAL_COMPARATOR")
#set ($comparator = "lessThanOrEqualTo")
#elseif($criteriaAttribute.comparatorConstant == "LESS_THAN_COMPARATOR")
#set ($comparator = "lessThanOrEqual")
#elseif($criteriaAttribute.comparatorConstant == "IN_COMPARATOR")
#set ($comparator = "in")
#elseif($criteriaAttribute.comparatorConstant == "NOT_EQUAL_COMPARATOR")
#set ($comparator = "notEqual")
#end
#end
#set ($matchMode = "${criteriaAttribute.name}")
#if($criteriaAttribute.matchModePresent)
#set ($matchMode = "$criteriaAttribute.matchModeConstant $criteriaAttribute.matchMode")
#if($criteriaAttribute.matchModeConstant == "ANYWHERE")
#set ($matchMode = "'%' + ${criteriaAttribute.name} + '%'")
#elseif($criteriaAttribute.matchModeConstant == "START")
#set ($matchMode = "${criteriaAttribute.name} + '%'")
#elseif($criteriaAttribute.matchModeConstant == "END")
#set ($matchMode = "'%' + ${criteriaAttribute.name}")
#end
#end
    public static Specification<$entity.name> ${hibernateUtils.getCriteriaAttributeMethodName($criteriaAttribute)}($criteriaAttribute.getterSetterTypeName $criteriaAttribute.name) {
        return (root, cq, cb) -> {
            
            return cb.${comparator}(root.get("$criteriaAttribute.attributeName"), $matchMode);
        };
    }

#end
#end
#end
#end
}