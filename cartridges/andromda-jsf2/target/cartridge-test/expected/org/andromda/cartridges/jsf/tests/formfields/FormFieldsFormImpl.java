// license-header java merge-point
// Generated by andromda-jsf cartridge (forms\FormImpl.java.vsl) on 07/30/2011 09:32:39-0300
package org.andromda.cartridges.jsf.tests.formfields;

import java.io.Serializable;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.faces.application.FacesMessage;
import javax.faces.event.ActionEvent;
import javax.faces.event.FacesEvent;
import javax.faces.event.ValueChangeEvent;
import javax.faces.model.SelectItem;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.myfaces.trinidad.model.UploadedFile;

/**
 * 
 */
public class FormFieldsFormImpl
    implements Serializable
{
    /**
     * Default constructor
     */
    public FormFieldsFormImpl()
    {
        final DateFormat dateDateFormatter = new SimpleDateFormat("MM/dd/yyyy");
        dateDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("date", dateDateFormatter);
        this.dateTimeFormatters.put("time", new SimpleDateFormat("HH:mm"));
        final DateFormat dateWithTimeDateFormatter = new SimpleDateFormat("dddd/MM/yyyy HH:mm:ss");
        dateWithTimeDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("dateWithTime", dateWithTimeDateFormatter);
        final DateFormat dateWithoutCalendarDateFormatter = new SimpleDateFormat("MM/dd/yyyy");
        dateWithoutCalendarDateFormatter.setLenient(true);
        this.dateTimeFormatters.put("dateWithoutCalendar", dateWithoutCalendarDateFormatter);
        // - setup the default Date.toString() formatter
        final DateFormat dateFormatter = new SimpleDateFormat("EEE MMM dd hh:mm:ss zzz yyyy");
        dateFormatter.setLenient(true);
        this.dateTimeFormatters.put(null, dateFormatter);
    }

    private transient FacesEvent event;

    /**
     * @param eventIn
     */
    public void setEvent(FacesEvent eventIn)
    {
        this.event = eventIn;
    }

    /**
     * @return ValueChangeEvent
     */
    public ValueChangeEvent getValueChangeEvent()
    {
        return this.event instanceof ValueChangeEvent
            ? (ValueChangeEvent)this.event : null;
    }

    /**
     * @return ActionEvent
     */
    public ActionEvent getActionEvent()
    {
        return this.event instanceof ActionEvent
            ? (ActionEvent)this.event : null;
    }

    // Action form-fields-one formFields

    private Date date;

    /**
     * 
     * @return date 
     */
    public Date getDate()
    {
        return this.date;
    }

    /**
     * Keeps track of whether or not the value of date has
     * be populated at least once.
     */
    private boolean dateSet = false;

    /**
     * Resets the value of the dateSet to false
     */
    public void resetDateSet()
    {
        this.dateSet = false;
    }

    /**
     * Indicates whether or not the value for date has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isDateSet()
    {
        return this.dateSet;
    }

    /**
     * 
     * @param dateIn 
     */
    public void setDate(Date dateIn)
    {
        this.date = dateIn;
        this.dateSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] dateValueList;

    /**
     * Stores the labels
     */
    private Object[] dateLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getDateBackingList()
    {
        Object[] values = this.dateValueList;
        Object[] labels = this.dateLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return dateValueList
     */
    public Object[] getDateValueList()
    {
        return this.dateValueList;
    }

    /**
     * @param dateValueListIn
     */
    public void setDateValueList(Object[] dateValueListIn)
    {
        this.dateValueList = dateValueListIn;
    }

    /**
     * @return dateLabelList Object[]
     */
    public Object[] getDateLabelList()
    {
        return this.dateLabelList;
    }

    /**
     * @param dateLabelListIn
     */
    public void setDateLabelList(Object[] dateLabelListIn)
    {
        this.dateLabelList = dateLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setDateBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.dateValueList = null;
        this.dateLabelList = null;
        if (items != null)
        {
            this.dateValueList = new Object[items.size()];
            this.dateLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.dateValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.dateLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.dateLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Date time;

    /**
     * 
     * @return time 
     */
    public Date getTime()
    {
        return this.time;
    }

    /**
     * Keeps track of whether or not the value of time has
     * be populated at least once.
     */
    private boolean timeSet = false;

    /**
     * Resets the value of the timeSet to false
     */
    public void resetTimeSet()
    {
        this.timeSet = false;
    }

    /**
     * Indicates whether or not the value for time has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTimeSet()
    {
        return this.timeSet;
    }

    /**
     * 
     * @param timeIn 
     */
    public void setTime(Date timeIn)
    {
        this.time = timeIn;
        this.timeSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] timeValueList;

    /**
     * Stores the labels
     */
    private Object[] timeLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTimeBackingList()
    {
        Object[] values = this.timeValueList;
        Object[] labels = this.timeLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return timeValueList
     */
    public Object[] getTimeValueList()
    {
        return this.timeValueList;
    }

    /**
     * @param timeValueListIn
     */
    public void setTimeValueList(Object[] timeValueListIn)
    {
        this.timeValueList = timeValueListIn;
    }

    /**
     * @return timeLabelList Object[]
     */
    public Object[] getTimeLabelList()
    {
        return this.timeLabelList;
    }

    /**
     * @param timeLabelListIn
     */
    public void setTimeLabelList(Object[] timeLabelListIn)
    {
        this.timeLabelList = timeLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTimeBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.timeValueList = null;
        this.timeLabelList = null;
        if (items != null)
        {
            this.timeValueList = new Object[items.size()];
            this.timeLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.timeValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.timeLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.timeLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String text;

    /**
     * 
     * @return text 
     */
    public String getText()
    {
        return this.text;
    }

    /**
     * Keeps track of whether or not the value of text has
     * be populated at least once.
     */
    private boolean textSet = false;

    /**
     * Resets the value of the textSet to false
     */
    public void resetTextSet()
    {
        this.textSet = false;
    }

    /**
     * Indicates whether or not the value for text has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTextSet()
    {
        return this.textSet;
    }

    /**
     * 
     * @param textIn 
     */
    public void setText(String textIn)
    {
        this.text = textIn;
        this.textSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] textValueList;

    /**
     * Stores the labels
     */
    private Object[] textLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTextBackingList()
    {
        Object[] values = this.textValueList;
        Object[] labels = this.textLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return textValueList
     */
    public Object[] getTextValueList()
    {
        return this.textValueList;
    }

    /**
     * @param textValueListIn
     */
    public void setTextValueList(Object[] textValueListIn)
    {
        this.textValueList = textValueListIn;
    }

    /**
     * @return textLabelList Object[]
     */
    public Object[] getTextLabelList()
    {
        return this.textLabelList;
    }

    /**
     * @param textLabelListIn
     */
    public void setTextLabelList(Object[] textLabelListIn)
    {
        this.textLabelList = textLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTextBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.textValueList = null;
        this.textLabelList = null;
        if (items != null)
        {
            this.textValueList = new Object[items.size()];
            this.textLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.textValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.textLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.textLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private int number;

    /**
     * 
     * @return number 
     */
    public int getNumber()
    {
        return this.number;
    }

    /**
     * Keeps track of whether or not the value of number has
     * be populated at least once.
     */
    private boolean numberSet = false;

    /**
     * Resets the value of the numberSet to false
     */
    public void resetNumberSet()
    {
        this.numberSet = false;
    }

    /**
     * Indicates whether or not the value for number has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isNumberSet()
    {
        return this.numberSet;
    }

    /**
     * 
     * @param numberIn 
     */
    public void setNumber(int numberIn)
    {
        this.number = numberIn;
        this.numberSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] numberValueList;

    /**
     * Stores the labels
     */
    private Object[] numberLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getNumberBackingList()
    {
        Object[] values = this.numberValueList;
        Object[] labels = this.numberLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return numberValueList
     */
    public Object[] getNumberValueList()
    {
        return this.numberValueList;
    }

    /**
     * @param numberValueListIn
     */
    public void setNumberValueList(Object[] numberValueListIn)
    {
        this.numberValueList = numberValueListIn;
    }

    /**
     * @return numberLabelList Object[]
     */
    public Object[] getNumberLabelList()
    {
        return this.numberLabelList;
    }

    /**
     * @param numberLabelListIn
     */
    public void setNumberLabelList(Object[] numberLabelListIn)
    {
        this.numberLabelList = numberLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setNumberBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.numberValueList = null;
        this.numberLabelList = null;
        if (items != null)
        {
            this.numberValueList = new Object[items.size()];
            this.numberLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.numberValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.numberLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.numberLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Collection collections;

    /**
     * 
     * @return collections 
     */
    public Collection getCollections()
    {
        return this.collections;
    }

    /**
     * Keeps track of whether or not the value of collections has
     * be populated at least once.
     */
    private boolean collectionsSet = false;

    /**
     * Resets the value of the collectionsSet to false
     */
    public void resetCollectionsSet()
    {
        this.collectionsSet = false;
    }

    /**
     * Indicates whether or not the value for collections has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isCollectionsSet()
    {
        return this.collectionsSet;
    }

    /**
     * 
     * @param collectionsIn 
     */
    public void setCollections(Collection collectionsIn)
    {
        this.collections = collectionsIn;
        this.collectionsSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] collectionsValueList;

    /**
     * Stores the labels
     */
    private Object[] collectionsLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getCollectionsBackingList()
    {
        Object[] values = this.collectionsValueList;
        Object[] labels = this.collectionsLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return collectionsValueList
     */
    public Object[] getCollectionsValueList()
    {
        return this.collectionsValueList;
    }

    /**
     * @param collectionsValueListIn
     */
    public void setCollectionsValueList(Object[] collectionsValueListIn)
    {
        this.collectionsValueList = collectionsValueListIn;
    }

    /**
     * @return collectionsLabelList Object[]
     */
    public Object[] getCollectionsLabelList()
    {
        return this.collectionsLabelList;
    }

    /**
     * @param collectionsLabelListIn
     */
    public void setCollectionsLabelList(Object[] collectionsLabelListIn)
    {
        this.collectionsLabelList = collectionsLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setCollectionsBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.collectionsValueList = null;
        this.collectionsLabelList = null;
        if (items != null)
        {
            this.collectionsValueList = new Object[items.size()];
            this.collectionsLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.collectionsValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.collectionsLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.collectionsLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private Collection collectionsBackingValue;

    /**
     * @param collectionsBackingValueIn
     */
    public void setCollectionsBackingValue(Collection collectionsBackingValueIn)
    {
        this.collectionsBackingValue = collectionsBackingValueIn;
    }

    /**
     * @return collectionsBackingValue
     */
    public Collection getCollectionsBackingValue()
    {
        return this.collectionsBackingValue;
    }


    private String selectable;

    /**
     * 
     * @return selectable 
     */
    public String getSelectable()
    {
        return this.selectable;
    }

    /**
     * Keeps track of whether or not the value of selectable has
     * be populated at least once.
     */
    private boolean selectableSet = false;

    /**
     * Resets the value of the selectableSet to false
     */
    public void resetSelectableSet()
    {
        this.selectableSet = false;
    }

    /**
     * Indicates whether or not the value for selectable has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isSelectableSet()
    {
        return this.selectableSet;
    }

    /**
     * 
     * @param selectableIn 
     */
    public void setSelectable(String selectableIn)
    {
        this.selectable = selectableIn;
        this.selectableSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] selectableValueList;

    /**
     * Stores the labels
     */
    private Object[] selectableLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getSelectableBackingList()
    {
        Object[] values = this.selectableValueList;
        Object[] labels = this.selectableLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return selectableValueList
     */
    public Object[] getSelectableValueList()
    {
        return this.selectableValueList;
    }

    /**
     * @param selectableValueListIn
     */
    public void setSelectableValueList(Object[] selectableValueListIn)
    {
        this.selectableValueList = selectableValueListIn;
    }

    /**
     * @return selectableLabelList Object[]
     */
    public Object[] getSelectableLabelList()
    {
        return this.selectableLabelList;
    }

    /**
     * @param selectableLabelListIn
     */
    public void setSelectableLabelList(Object[] selectableLabelListIn)
    {
        this.selectableLabelList = selectableLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setSelectableBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.selectableValueList = null;
        this.selectableLabelList = null;
        if (items != null)
        {
            this.selectableValueList = new Object[items.size()];
            this.selectableLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.selectableValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.selectableLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.selectableLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private boolean bool;

    /**
     * 
     * @return bool 
     */
    public boolean isBool()
    {
        return this.bool;
    }

    /**
     * Keeps track of whether or not the value of bool has
     * be populated at least once.
     */
    private boolean boolSet = false;

    /**
     * Resets the value of the boolSet to false
     */
    public void resetBoolSet()
    {
        this.boolSet = false;
    }

    /**
     * Indicates whether or not the value for bool has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isBoolSet()
    {
        return this.boolSet;
    }

    /**
     * 
     * @param boolIn 
     */
    public void setBool(boolean boolIn)
    {
        this.bool = boolIn;
        this.boolSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] boolValueList;

    /**
     * Stores the labels
     */
    private Object[] boolLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getBoolBackingList()
    {
        Object[] values = this.boolValueList;
        Object[] labels = this.boolLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return boolValueList
     */
    public Object[] getBoolValueList()
    {
        return this.boolValueList;
    }

    /**
     * @param boolValueListIn
     */
    public void setBoolValueList(Object[] boolValueListIn)
    {
        this.boolValueList = boolValueListIn;
    }

    /**
     * @return boolLabelList Object[]
     */
    public Object[] getBoolLabelList()
    {
        return this.boolLabelList;
    }

    /**
     * @param boolLabelListIn
     */
    public void setBoolLabelList(Object[] boolLabelListIn)
    {
        this.boolLabelList = boolLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setBoolBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.boolValueList = null;
        this.boolLabelList = null;
        if (items != null)
        {
            this.boolValueList = new Object[items.size()];
            this.boolLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.boolValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.boolLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.boolLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Collection multiSelects;

    /**
     * 
     * @return multiSelects 
     */
    public Collection getMultiSelects()
    {
        return this.multiSelects;
    }

    /**
     * Keeps track of whether or not the value of multiSelects has
     * be populated at least once.
     */
    private boolean multiSelectsSet = false;

    /**
     * Resets the value of the multiSelectsSet to false
     */
    public void resetMultiSelectsSet()
    {
        this.multiSelectsSet = false;
    }

    /**
     * Indicates whether or not the value for multiSelects has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isMultiSelectsSet()
    {
        return this.multiSelectsSet;
    }

    /**
     * 
     * @param multiSelectsIn 
     */
    public void setMultiSelects(Collection multiSelectsIn)
    {
        this.multiSelects = multiSelectsIn;
        this.multiSelectsSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] multiSelectsValueList;

    /**
     * Stores the labels
     */
    private Object[] multiSelectsLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getMultiSelectsBackingList()
    {
        Object[] values = this.multiSelectsValueList;
        Object[] labels = this.multiSelectsLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return multiSelectsValueList
     */
    public Object[] getMultiSelectsValueList()
    {
        return this.multiSelectsValueList;
    }

    /**
     * @param multiSelectsValueListIn
     */
    public void setMultiSelectsValueList(Object[] multiSelectsValueListIn)
    {
        this.multiSelectsValueList = multiSelectsValueListIn;
    }

    /**
     * @return multiSelectsLabelList Object[]
     */
    public Object[] getMultiSelectsLabelList()
    {
        return this.multiSelectsLabelList;
    }

    /**
     * @param multiSelectsLabelListIn
     */
    public void setMultiSelectsLabelList(Object[] multiSelectsLabelListIn)
    {
        this.multiSelectsLabelList = multiSelectsLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setMultiSelectsBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.multiSelectsValueList = null;
        this.multiSelectsLabelList = null;
        if (items != null)
        {
            this.multiSelectsValueList = new Object[items.size()];
            this.multiSelectsLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.multiSelectsValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.multiSelectsLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.multiSelectsLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private Collection multiSelectsBackingValue;

    /**
     * @param multiSelectsBackingValueIn
     */
    public void setMultiSelectsBackingValue(Collection multiSelectsBackingValueIn)
    {
        this.multiSelectsBackingValue = multiSelectsBackingValueIn;
    }

    /**
     * @return multiSelectsBackingValue
     */
    public Collection getMultiSelectsBackingValue()
    {
        return this.multiSelectsBackingValue;
    }


    private String title;

    /**
     * should not conflict with the use-cases title property in the resource bundle
     * @return title should not conflict with the use-cases title property in the resource bundle
     */
    public String getTitle()
    {
        return this.title;
    }

    /**
     * Keeps track of whether or not the value of title has
     * be populated at least once.
     */
    private boolean titleSet = false;

    /**
     * Resets the value of the titleSet to false
     */
    public void resetTitleSet()
    {
        this.titleSet = false;
    }

    /**
     * Indicates whether or not the value for title has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isTitleSet()
    {
        return this.titleSet;
    }

    /**
     * should not conflict with the use-cases title property in the resource bundle
     * @param titleIn should not conflict with the use-cases title property in the resource bundle
     */
    public void setTitle(String titleIn)
    {
        this.title = titleIn;
        this.titleSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] titleValueList;

    /**
     * Stores the labels
     */
    private Object[] titleLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getTitleBackingList()
    {
        Object[] values = this.titleValueList;
        Object[] labels = this.titleLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return titleValueList
     */
    public Object[] getTitleValueList()
    {
        return this.titleValueList;
    }

    /**
     * @param titleValueListIn
     */
    public void setTitleValueList(Object[] titleValueListIn)
    {
        this.titleValueList = titleValueListIn;
    }

    /**
     * @return titleLabelList Object[]
     */
    public Object[] getTitleLabelList()
    {
        return this.titleLabelList;
    }

    /**
     * @param titleLabelListIn
     */
    public void setTitleLabelList(Object[] titleLabelListIn)
    {
        this.titleLabelList = titleLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setTitleBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.titleValueList = null;
        this.titleLabelList = null;
        if (items != null)
        {
            this.titleValueList = new Object[items.size()];
            this.titleLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.titleValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.titleLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.titleLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private UploadedFile file;

    /**
     * 
     * @return file 
     */
    public UploadedFile getFile()
    {
        return this.file;
    }

    /**
     * Keeps track of whether or not the value of file has
     * be populated at least once.
     */
    private boolean fileSet = false;

    /**
     * Resets the value of the fileSet to false
     */
    public void resetFileSet()
    {
        this.fileSet = false;
    }

    /**
     * Indicates whether or not the value for file has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isFileSet()
    {
        return this.fileSet;
    }

    /**
     * 
     * @param fileIn 
     */
    public void setFile(UploadedFile fileIn)
    {
        this.file = fileIn;
        this.fileSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] fileValueList;

    /**
     * Stores the labels
     */
    private Object[] fileLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getFileBackingList()
    {
        Object[] values = this.fileValueList;
        Object[] labels = this.fileLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return fileValueList
     */
    public Object[] getFileValueList()
    {
        return this.fileValueList;
    }

    /**
     * @param fileValueListIn
     */
    public void setFileValueList(Object[] fileValueListIn)
    {
        this.fileValueList = fileValueListIn;
    }

    /**
     * @return fileLabelList Object[]
     */
    public Object[] getFileLabelList()
    {
        return this.fileLabelList;
    }

    /**
     * @param fileLabelListIn
     */
    public void setFileLabelList(Object[] fileLabelListIn)
    {
        this.fileLabelList = fileLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setFileBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.fileValueList = null;
        this.fileLabelList = null;
        if (items != null)
        {
            this.fileValueList = new Object[items.size()];
            this.fileLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.fileValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.fileLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.fileLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String multiFormat;

    /**
     * 
     * @return multiFormat 
     */
    public String getMultiFormat()
    {
        return this.multiFormat;
    }

    /**
     * Keeps track of whether or not the value of multiFormat has
     * be populated at least once.
     */
    private boolean multiFormatSet = false;

    /**
     * Resets the value of the multiFormatSet to false
     */
    public void resetMultiFormatSet()
    {
        this.multiFormatSet = false;
    }

    /**
     * Indicates whether or not the value for multiFormat has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isMultiFormatSet()
    {
        return this.multiFormatSet;
    }

    /**
     * 
     * @param multiFormatIn 
     */
    public void setMultiFormat(String multiFormatIn)
    {
        this.multiFormat = multiFormatIn;
        this.multiFormatSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] multiFormatValueList;

    /**
     * Stores the labels
     */
    private Object[] multiFormatLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getMultiFormatBackingList()
    {
        Object[] values = this.multiFormatValueList;
        Object[] labels = this.multiFormatLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return multiFormatValueList
     */
    public Object[] getMultiFormatValueList()
    {
        return this.multiFormatValueList;
    }

    /**
     * @param multiFormatValueListIn
     */
    public void setMultiFormatValueList(Object[] multiFormatValueListIn)
    {
        this.multiFormatValueList = multiFormatValueListIn;
    }

    /**
     * @return multiFormatLabelList Object[]
     */
    public Object[] getMultiFormatLabelList()
    {
        return this.multiFormatLabelList;
    }

    /**
     * @param multiFormatLabelListIn
     */
    public void setMultiFormatLabelList(Object[] multiFormatLabelListIn)
    {
        this.multiFormatLabelList = multiFormatLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setMultiFormatBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.multiFormatValueList = null;
        this.multiFormatLabelList = null;
        if (items != null)
        {
            this.multiFormatValueList = new Object[items.size()];
            this.multiFormatLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.multiFormatValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.multiFormatLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.multiFormatLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Date dateWithTime;

    /**
     * 
     * @return dateWithTime 
     */
    public Date getDateWithTime()
    {
        return this.dateWithTime;
    }

    /**
     * Keeps track of whether or not the value of dateWithTime has
     * be populated at least once.
     */
    private boolean dateWithTimeSet = false;

    /**
     * Resets the value of the dateWithTimeSet to false
     */
    public void resetDateWithTimeSet()
    {
        this.dateWithTimeSet = false;
    }

    /**
     * Indicates whether or not the value for dateWithTime has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isDateWithTimeSet()
    {
        return this.dateWithTimeSet;
    }

    /**
     * 
     * @param dateWithTimeIn 
     */
    public void setDateWithTime(Date dateWithTimeIn)
    {
        this.dateWithTime = dateWithTimeIn;
        this.dateWithTimeSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] dateWithTimeValueList;

    /**
     * Stores the labels
     */
    private Object[] dateWithTimeLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getDateWithTimeBackingList()
    {
        Object[] values = this.dateWithTimeValueList;
        Object[] labels = this.dateWithTimeLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return dateWithTimeValueList
     */
    public Object[] getDateWithTimeValueList()
    {
        return this.dateWithTimeValueList;
    }

    /**
     * @param dateWithTimeValueListIn
     */
    public void setDateWithTimeValueList(Object[] dateWithTimeValueListIn)
    {
        this.dateWithTimeValueList = dateWithTimeValueListIn;
    }

    /**
     * @return dateWithTimeLabelList Object[]
     */
    public Object[] getDateWithTimeLabelList()
    {
        return this.dateWithTimeLabelList;
    }

    /**
     * @param dateWithTimeLabelListIn
     */
    public void setDateWithTimeLabelList(Object[] dateWithTimeLabelListIn)
    {
        this.dateWithTimeLabelList = dateWithTimeLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setDateWithTimeBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.dateWithTimeValueList = null;
        this.dateWithTimeLabelList = null;
        if (items != null)
        {
            this.dateWithTimeValueList = new Object[items.size()];
            this.dateWithTimeLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.dateWithTimeValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.dateWithTimeLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.dateWithTimeLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Date dateWithoutCalendar;

    /**
     * 
     * @return dateWithoutCalendar 
     */
    public Date getDateWithoutCalendar()
    {
        return this.dateWithoutCalendar;
    }

    /**
     * Keeps track of whether or not the value of dateWithoutCalendar has
     * be populated at least once.
     */
    private boolean dateWithoutCalendarSet = false;

    /**
     * Resets the value of the dateWithoutCalendarSet to false
     */
    public void resetDateWithoutCalendarSet()
    {
        this.dateWithoutCalendarSet = false;
    }

    /**
     * Indicates whether or not the value for dateWithoutCalendar has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isDateWithoutCalendarSet()
    {
        return this.dateWithoutCalendarSet;
    }

    /**
     * 
     * @param dateWithoutCalendarIn 
     */
    public void setDateWithoutCalendar(Date dateWithoutCalendarIn)
    {
        this.dateWithoutCalendar = dateWithoutCalendarIn;
        this.dateWithoutCalendarSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] dateWithoutCalendarValueList;

    /**
     * Stores the labels
     */
    private Object[] dateWithoutCalendarLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getDateWithoutCalendarBackingList()
    {
        Object[] values = this.dateWithoutCalendarValueList;
        Object[] labels = this.dateWithoutCalendarLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return dateWithoutCalendarValueList
     */
    public Object[] getDateWithoutCalendarValueList()
    {
        return this.dateWithoutCalendarValueList;
    }

    /**
     * @param dateWithoutCalendarValueListIn
     */
    public void setDateWithoutCalendarValueList(Object[] dateWithoutCalendarValueListIn)
    {
        this.dateWithoutCalendarValueList = dateWithoutCalendarValueListIn;
    }

    /**
     * @return dateWithoutCalendarLabelList Object[]
     */
    public Object[] getDateWithoutCalendarLabelList()
    {
        return this.dateWithoutCalendarLabelList;
    }

    /**
     * @param dateWithoutCalendarLabelListIn
     */
    public void setDateWithoutCalendarLabelList(Object[] dateWithoutCalendarLabelListIn)
    {
        this.dateWithoutCalendarLabelList = dateWithoutCalendarLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setDateWithoutCalendarBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.dateWithoutCalendarValueList = null;
        this.dateWithoutCalendarLabelList = null;
        if (items != null)
        {
            this.dateWithoutCalendarValueList = new Object[items.size()];
            this.dateWithoutCalendarLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.dateWithoutCalendarValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.dateWithoutCalendarLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.dateWithoutCalendarLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String hasCustomValidator;

    /**
     * 
     * @return hasCustomValidator 
     */
    public String getHasCustomValidator()
    {
        return this.hasCustomValidator;
    }

    /**
     * Keeps track of whether or not the value of hasCustomValidator has
     * be populated at least once.
     */
    private boolean hasCustomValidatorSet = false;

    /**
     * Resets the value of the hasCustomValidatorSet to false
     */
    public void resetHasCustomValidatorSet()
    {
        this.hasCustomValidatorSet = false;
    }

    /**
     * Indicates whether or not the value for hasCustomValidator has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isHasCustomValidatorSet()
    {
        return this.hasCustomValidatorSet;
    }

    /**
     * 
     * @param hasCustomValidatorIn 
     */
    public void setHasCustomValidator(String hasCustomValidatorIn)
    {
        this.hasCustomValidator = hasCustomValidatorIn;
        this.hasCustomValidatorSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] hasCustomValidatorValueList;

    /**
     * Stores the labels
     */
    private Object[] hasCustomValidatorLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getHasCustomValidatorBackingList()
    {
        Object[] values = this.hasCustomValidatorValueList;
        Object[] labels = this.hasCustomValidatorLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return hasCustomValidatorValueList
     */
    public Object[] getHasCustomValidatorValueList()
    {
        return this.hasCustomValidatorValueList;
    }

    /**
     * @param hasCustomValidatorValueListIn
     */
    public void setHasCustomValidatorValueList(Object[] hasCustomValidatorValueListIn)
    {
        this.hasCustomValidatorValueList = hasCustomValidatorValueListIn;
    }

    /**
     * @return hasCustomValidatorLabelList Object[]
     */
    public Object[] getHasCustomValidatorLabelList()
    {
        return this.hasCustomValidatorLabelList;
    }

    /**
     * @param hasCustomValidatorLabelListIn
     */
    public void setHasCustomValidatorLabelList(Object[] hasCustomValidatorLabelListIn)
    {
        this.hasCustomValidatorLabelList = hasCustomValidatorLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setHasCustomValidatorBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.hasCustomValidatorValueList = null;
        this.hasCustomValidatorLabelList = null;
        if (items != null)
        {
            this.hasCustomValidatorValueList = new Object[items.size()];
            this.hasCustomValidatorLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.hasCustomValidatorValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.hasCustomValidatorLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.hasCustomValidatorLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Integer integerClass;

    /**
     * 
     * @return integerClass 
     */
    public Integer getIntegerClass()
    {
        return this.integerClass;
    }

    /**
     * Keeps track of whether or not the value of integerClass has
     * be populated at least once.
     */
    private boolean integerClassSet = false;

    /**
     * Resets the value of the integerClassSet to false
     */
    public void resetIntegerClassSet()
    {
        this.integerClassSet = false;
    }

    /**
     * Indicates whether or not the value for integerClass has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isIntegerClassSet()
    {
        return this.integerClassSet;
    }

    /**
     * 
     * @param integerClassIn 
     */
    public void setIntegerClass(Integer integerClassIn)
    {
        this.integerClass = integerClassIn;
        this.integerClassSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] integerClassValueList;

    /**
     * Stores the labels
     */
    private Object[] integerClassLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getIntegerClassBackingList()
    {
        Object[] values = this.integerClassValueList;
        Object[] labels = this.integerClassLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return integerClassValueList
     */
    public Object[] getIntegerClassValueList()
    {
        return this.integerClassValueList;
    }

    /**
     * @param integerClassValueListIn
     */
    public void setIntegerClassValueList(Object[] integerClassValueListIn)
    {
        this.integerClassValueList = integerClassValueListIn;
    }

    /**
     * @return integerClassLabelList Object[]
     */
    public Object[] getIntegerClassLabelList()
    {
        return this.integerClassLabelList;
    }

    /**
     * @param integerClassLabelListIn
     */
    public void setIntegerClassLabelList(Object[] integerClassLabelListIn)
    {
        this.integerClassLabelList = integerClassLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setIntegerClassBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.integerClassValueList = null;
        this.integerClassLabelList = null;
        if (items != null)
        {
            this.integerClassValueList = new Object[items.size()];
            this.integerClassLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.integerClassValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.integerClassLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.integerClassLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Collection setClasses;

    /**
     * 
     * @return setClasses 
     */
    public Collection getSetClasses()
    {
        return this.setClasses;
    }

    /**
     * Keeps track of whether or not the value of setClasses has
     * be populated at least once.
     */
    private boolean setClassesSet = false;

    /**
     * Resets the value of the setClassesSet to false
     */
    public void resetSetClassesSet()
    {
        this.setClassesSet = false;
    }

    /**
     * Indicates whether or not the value for setClasses has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isSetClassesSet()
    {
        return this.setClassesSet;
    }

    /**
     * 
     * @param setClassesIn 
     */
    public void setSetClasses(Collection setClassesIn)
    {
        this.setClasses = setClassesIn;
        this.setClassesSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] setClassesValueList;

    /**
     * Stores the labels
     */
    private Object[] setClassesLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getSetClassesBackingList()
    {
        Object[] values = this.setClassesValueList;
        Object[] labels = this.setClassesLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return setClassesValueList
     */
    public Object[] getSetClassesValueList()
    {
        return this.setClassesValueList;
    }

    /**
     * @param setClassesValueListIn
     */
    public void setSetClassesValueList(Object[] setClassesValueListIn)
    {
        this.setClassesValueList = setClassesValueListIn;
    }

    /**
     * @return setClassesLabelList Object[]
     */
    public Object[] getSetClassesLabelList()
    {
        return this.setClassesLabelList;
    }

    /**
     * @param setClassesLabelListIn
     */
    public void setSetClassesLabelList(Object[] setClassesLabelListIn)
    {
        this.setClassesLabelList = setClassesLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setSetClassesBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.setClassesValueList = null;
        this.setClassesLabelList = null;
        if (items != null)
        {
            this.setClassesValueList = new Object[items.size()];
            this.setClassesLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.setClassesValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.setClassesLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.setClassesLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }
    private Set setClassesBackingValue;

    /**
     * @param setClassesBackingValueIn
     */
    public void setSetClassesBackingValue(Set setClassesBackingValueIn)
    {
        this.setClassesBackingValue = setClassesBackingValueIn;
    }

    /**
     * @return setClassesBackingValue
     */
    public Set getSetClassesBackingValue()
    {
        return this.setClassesBackingValue;
    }


    private Map mapClass;

    /**
     * 
     * @return mapClass 
     */
    public Map getMapClass()
    {
        return this.mapClass;
    }

    /**
     * Keeps track of whether or not the value of mapClass has
     * be populated at least once.
     */
    private boolean mapClassSet = false;

    /**
     * Resets the value of the mapClassSet to false
     */
    public void resetMapClassSet()
    {
        this.mapClassSet = false;
    }

    /**
     * Indicates whether or not the value for mapClass has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isMapClassSet()
    {
        return this.mapClassSet;
    }

    /**
     * 
     * @param mapClassIn 
     */
    public void setMapClass(Map mapClassIn)
    {
        this.mapClass = mapClassIn;
        this.mapClassSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] mapClassValueList;

    /**
     * Stores the labels
     */
    private Object[] mapClassLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getMapClassBackingList()
    {
        Object[] values = this.mapClassValueList;
        Object[] labels = this.mapClassLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return mapClassValueList
     */
    public Object[] getMapClassValueList()
    {
        return this.mapClassValueList;
    }

    /**
     * @param mapClassValueListIn
     */
    public void setMapClassValueList(Object[] mapClassValueListIn)
    {
        this.mapClassValueList = mapClassValueListIn;
    }

    /**
     * @return mapClassLabelList Object[]
     */
    public Object[] getMapClassLabelList()
    {
        return this.mapClassLabelList;
    }

    /**
     * @param mapClassLabelListIn
     */
    public void setMapClassLabelList(Object[] mapClassLabelListIn)
    {
        this.mapClassLabelList = mapClassLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setMapClassBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.mapClassValueList = null;
        this.mapClassLabelList = null;
        if (items != null)
        {
            this.mapClassValueList = new Object[items.size()];
            this.mapClassLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.mapClassValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.mapClassLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.mapClassLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Boolean booleanClass;

    /**
     * 
     * @return booleanClass 
     */
    public Boolean getBooleanClass()
    {
        return this.booleanClass;
    }

    /**
     * Keeps track of whether or not the value of booleanClass has
     * be populated at least once.
     */
    private boolean booleanClassSet = false;

    /**
     * Resets the value of the booleanClassSet to false
     */
    public void resetBooleanClassSet()
    {
        this.booleanClassSet = false;
    }

    /**
     * Indicates whether or not the value for booleanClass has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isBooleanClassSet()
    {
        return this.booleanClassSet;
    }

    /**
     * 
     * @param booleanClassIn 
     */
    public void setBooleanClass(Boolean booleanClassIn)
    {
        this.booleanClass = booleanClassIn;
        this.booleanClassSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] booleanClassValueList;

    /**
     * Stores the labels
     */
    private Object[] booleanClassLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getBooleanClassBackingList()
    {
        Object[] values = this.booleanClassValueList;
        Object[] labels = this.booleanClassLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return booleanClassValueList
     */
    public Object[] getBooleanClassValueList()
    {
        return this.booleanClassValueList;
    }

    /**
     * @param booleanClassValueListIn
     */
    public void setBooleanClassValueList(Object[] booleanClassValueListIn)
    {
        this.booleanClassValueList = booleanClassValueListIn;
    }

    /**
     * @return booleanClassLabelList Object[]
     */
    public Object[] getBooleanClassLabelList()
    {
        return this.booleanClassLabelList;
    }

    /**
     * @param booleanClassLabelListIn
     */
    public void setBooleanClassLabelList(Object[] booleanClassLabelListIn)
    {
        this.booleanClassLabelList = booleanClassLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setBooleanClassBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.booleanClassValueList = null;
        this.booleanClassLabelList = null;
        if (items != null)
        {
            this.booleanClassValueList = new Object[items.size()];
            this.booleanClassLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.booleanClassValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.booleanClassLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.booleanClassLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private Float floatClass;

    /**
     * 
     * @return floatClass 
     */
    public Float getFloatClass()
    {
        return this.floatClass;
    }

    /**
     * Keeps track of whether or not the value of floatClass has
     * be populated at least once.
     */
    private boolean floatClassSet = false;

    /**
     * Resets the value of the floatClassSet to false
     */
    public void resetFloatClassSet()
    {
        this.floatClassSet = false;
    }

    /**
     * Indicates whether or not the value for floatClass has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isFloatClassSet()
    {
        return this.floatClassSet;
    }

    /**
     * 
     * @param floatClassIn 
     */
    public void setFloatClass(Float floatClassIn)
    {
        this.floatClass = floatClassIn;
        this.floatClassSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] floatClassValueList;

    /**
     * Stores the labels
     */
    private Object[] floatClassLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getFloatClassBackingList()
    {
        Object[] values = this.floatClassValueList;
        Object[] labels = this.floatClassLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return floatClassValueList
     */
    public Object[] getFloatClassValueList()
    {
        return this.floatClassValueList;
    }

    /**
     * @param floatClassValueListIn
     */
    public void setFloatClassValueList(Object[] floatClassValueListIn)
    {
        this.floatClassValueList = floatClassValueListIn;
    }

    /**
     * @return floatClassLabelList Object[]
     */
    public Object[] getFloatClassLabelList()
    {
        return this.floatClassLabelList;
    }

    /**
     * @param floatClassLabelListIn
     */
    public void setFloatClassLabelList(Object[] floatClassLabelListIn)
    {
        this.floatClassLabelList = floatClassLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setFloatClassBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.floatClassValueList = null;
        this.floatClassLabelList = null;
        if (items != null)
        {
            this.floatClassValueList = new Object[items.size()];
            this.floatClassLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.floatClassValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.floatClassLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.floatClassLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String hiddenWithDefaultValue = "someDefaultValue";

    /**
     * 
     * @return hiddenWithDefaultValue 
     */
    public String getHiddenWithDefaultValue()
    {
        return this.hiddenWithDefaultValue;
    }

    /**
     * Keeps track of whether or not the value of hiddenWithDefaultValue has
     * be populated at least once.
     */
    private boolean hiddenWithDefaultValueSet = false;

    /**
     * Resets the value of the hiddenWithDefaultValueSet to false
     */
    public void resetHiddenWithDefaultValueSet()
    {
        this.hiddenWithDefaultValueSet = false;
    }

    /**
     * Indicates whether or not the value for hiddenWithDefaultValue has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isHiddenWithDefaultValueSet()
    {
        return this.hiddenWithDefaultValueSet;
    }

    /**
     * 
     * @param hiddenWithDefaultValueIn 
     */
    public void setHiddenWithDefaultValue(String hiddenWithDefaultValueIn)
    {
        this.hiddenWithDefaultValue = hiddenWithDefaultValueIn;
        this.hiddenWithDefaultValueSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] hiddenWithDefaultValueValueList;

    /**
     * Stores the labels
     */
    private Object[] hiddenWithDefaultValueLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getHiddenWithDefaultValueBackingList()
    {
        Object[] values = this.hiddenWithDefaultValueValueList;
        Object[] labels = this.hiddenWithDefaultValueLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return hiddenWithDefaultValueValueList
     */
    public Object[] getHiddenWithDefaultValueValueList()
    {
        return this.hiddenWithDefaultValueValueList;
    }

    /**
     * @param hiddenWithDefaultValueValueListIn
     */
    public void setHiddenWithDefaultValueValueList(Object[] hiddenWithDefaultValueValueListIn)
    {
        this.hiddenWithDefaultValueValueList = hiddenWithDefaultValueValueListIn;
    }

    /**
     * @return hiddenWithDefaultValueLabelList Object[]
     */
    public Object[] getHiddenWithDefaultValueLabelList()
    {
        return this.hiddenWithDefaultValueLabelList;
    }

    /**
     * @param hiddenWithDefaultValueLabelListIn
     */
    public void setHiddenWithDefaultValueLabelList(Object[] hiddenWithDefaultValueLabelListIn)
    {
        this.hiddenWithDefaultValueLabelList = hiddenWithDefaultValueLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setHiddenWithDefaultValueBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.hiddenWithDefaultValueValueList = null;
        this.hiddenWithDefaultValueLabelList = null;
        if (items != null)
        {
            this.hiddenWithDefaultValueValueList = new Object[items.size()];
            this.hiddenWithDefaultValueLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.hiddenWithDefaultValueValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.hiddenWithDefaultValueLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.hiddenWithDefaultValueLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private String bAdName;

    /**
     * 
     * @return bAdName 
     */
    public String getBAdName()
    {
        return this.bAdName;
    }

    /**
     * Keeps track of whether or not the value of bAdName has
     * be populated at least once.
     */
    private boolean bAdNameSet = false;

    /**
     * Resets the value of the bAdNameSet to false
     */
    public void resetBAdNameSet()
    {
        this.bAdNameSet = false;
    }

    /**
     * Indicates whether or not the value for bAdName has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isBAdNameSet()
    {
        return this.bAdNameSet;
    }

    /**
     * 
     * @param bAdNameIn 
     */
    public void setBAdName(String bAdNameIn)
    {
        this.bAdName = bAdNameIn;
        this.bAdNameSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] bAdNameValueList;

    /**
     * Stores the labels
     */
    private Object[] bAdNameLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getBAdNameBackingList()
    {
        Object[] values = this.bAdNameValueList;
        Object[] labels = this.bAdNameLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return bAdNameValueList
     */
    public Object[] getBAdNameValueList()
    {
        return this.bAdNameValueList;
    }

    /**
     * @param bAdNameValueListIn
     */
    public void setBAdNameValueList(Object[] bAdNameValueListIn)
    {
        this.bAdNameValueList = bAdNameValueListIn;
    }

    /**
     * @return bAdNameLabelList Object[]
     */
    public Object[] getBAdNameLabelList()
    {
        return this.bAdNameLabelList;
    }

    /**
     * @param bAdNameLabelListIn
     */
    public void setBAdNameLabelList(Object[] bAdNameLabelListIn)
    {
        this.bAdNameLabelList = bAdNameLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setBAdNameBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.bAdNameValueList = null;
        this.bAdNameLabelList = null;
        if (items != null)
        {
            this.bAdNameValueList = new Object[items.size()];
            this.bAdNameLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.bAdNameValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.bAdNameLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.bAdNameLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    private SubValueObject complexParameter;

    /**
     * 
     * @return complexParameter 
     */
    public SubValueObject getComplexParameter()
    {
        if (this.complexParameter == null)
        {
            this.complexParameter = new SubValueObject();
            this.setComplexParameter(this.complexParameter);
        }
        return this.complexParameter;
    }

    /**
     * Keeps track of whether or not the value of complexParameter has
     * be populated at least once.
     */
    private boolean complexParameterSet = false;

    /**
     * Resets the value of the complexParameterSet to false
     */
    public void resetComplexParameterSet()
    {
        this.complexParameterSet = false;
    }

    /**
     * Indicates whether or not the value for complexParameter has been set at least
     * once.
     *
     * @return true/false
     */
    public boolean isComplexParameterSet()
    {
        return this.complexParameterSet;
    }

    /**
     * 
     * @param complexParameterIn 
     */
    public void setComplexParameter(SubValueObject complexParameterIn)
    {
        this.complexParameter = complexParameterIn;
        this.complexParameterSet = true;
    }

    /**
     * Stores the values.
     */
    private Object[] complexParameterValueList;

    /**
     * Stores the labels
     */
    private Object[] complexParameterLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getComplexParameterBackingList()
    {
        Object[] values = this.complexParameterValueList;
        Object[] labels = this.complexParameterLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return complexParameterValueList
     */
    public Object[] getComplexParameterValueList()
    {
        return this.complexParameterValueList;
    }

    /**
     * @param complexParameterValueListIn
     */
    public void setComplexParameterValueList(Object[] complexParameterValueListIn)
    {
        this.complexParameterValueList = complexParameterValueListIn;
    }

    /**
     * @return complexParameterLabelList Object[]
     */
    public Object[] getComplexParameterLabelList()
    {
        return this.complexParameterLabelList;
    }

    /**
     * @param complexParameterLabelListIn
     */
    public void setComplexParameterLabelList(Object[] complexParameterLabelListIn)
    {
        this.complexParameterLabelList = complexParameterLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setComplexParameterBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.complexParameterValueList = null;
        this.complexParameterLabelList = null;
        if (items != null)
        {
            this.complexParameterValueList = new Object[items.size()];
            this.complexParameterLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.complexParameterValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.complexParameterLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.complexParameterLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    // complexParameter attributes

    /**
     * Stores the values.
     */
    private Object[] complexParameterSubValueObjectAttributeOneValueList;

    /**
     * Stores the labels
     */
    private Object[] complexParameterSubValueObjectAttributeOneLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getComplexParameterSubValueObjectAttributeOneBackingList()
    {
        Object[] values = this.complexParameterSubValueObjectAttributeOneValueList;
        Object[] labels = this.complexParameterSubValueObjectAttributeOneLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return complexParameterSubValueObjectAttributeOneValueList
     */
    public Object[] getComplexParameterSubValueObjectAttributeOneValueList()
    {
        return this.complexParameterSubValueObjectAttributeOneValueList;
    }

    /**
     * @param complexParameterSubValueObjectAttributeOneValueListIn
     */
    public void setComplexParameterSubValueObjectAttributeOneValueList(Object[] complexParameterSubValueObjectAttributeOneValueListIn)
    {
        this.complexParameterSubValueObjectAttributeOneValueList = complexParameterSubValueObjectAttributeOneValueListIn;
    }

    /**
     * @return complexParameterSubValueObjectAttributeOneLabelList Object[]
     */
    public Object[] getComplexParameterSubValueObjectAttributeOneLabelList()
    {
        return this.complexParameterSubValueObjectAttributeOneLabelList;
    }

    /**
     * @param complexParameterSubValueObjectAttributeOneLabelListIn
     */
    public void setComplexParameterSubValueObjectAttributeOneLabelList(Object[] complexParameterSubValueObjectAttributeOneLabelListIn)
    {
        this.complexParameterSubValueObjectAttributeOneLabelList = complexParameterSubValueObjectAttributeOneLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setComplexParameterSubValueObjectAttributeOneBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.complexParameterSubValueObjectAttributeOneValueList = null;
        this.complexParameterSubValueObjectAttributeOneLabelList = null;
        if (items != null)
        {
            this.complexParameterSubValueObjectAttributeOneValueList = new Object[items.size()];
            this.complexParameterSubValueObjectAttributeOneLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.complexParameterSubValueObjectAttributeOneValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.complexParameterSubValueObjectAttributeOneLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.complexParameterSubValueObjectAttributeOneLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }

    /**
     * Stores the values.
     */
    private Object[] complexParameterRootAttributeOneValueList;

    /**
     * Stores the labels
     */
    private Object[] complexParameterRootAttributeOneLabelList;

    /**
     * @return backingList Object[]
     */
    public Object[] getComplexParameterRootAttributeOneBackingList()
    {
        Object[] values = this.complexParameterRootAttributeOneValueList;
        Object[] labels = this.complexParameterRootAttributeOneLabelList;

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = Math.min(labels.length, values.length);
        SelectItem[] backingList = new SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new SelectItem(
                values[ctr] != null ? values[ctr] : "", labels[ctr] != null ? String.valueOf(labels[ctr]) : "");
        }
        return backingList;
    }

    /**
     * @return complexParameterRootAttributeOneValueList
     */
    public Object[] getComplexParameterRootAttributeOneValueList()
    {
        return this.complexParameterRootAttributeOneValueList;
    }

    /**
     * @param complexParameterRootAttributeOneValueListIn
     */
    public void setComplexParameterRootAttributeOneValueList(Object[] complexParameterRootAttributeOneValueListIn)
    {
        this.complexParameterRootAttributeOneValueList = complexParameterRootAttributeOneValueListIn;
    }

    /**
     * @return complexParameterRootAttributeOneLabelList Object[]
     */
    public Object[] getComplexParameterRootAttributeOneLabelList()
    {
        return this.complexParameterRootAttributeOneLabelList;
    }

    /**
     * @param complexParameterRootAttributeOneLabelListIn
     */
    public void setComplexParameterRootAttributeOneLabelList(Object[] complexParameterRootAttributeOneLabelListIn)
    {
        this.complexParameterRootAttributeOneLabelList = complexParameterRootAttributeOneLabelListIn;
    }

    /**
     * @param items
     * @param valueProperty
     * @param labelProperty
     */
    public void setComplexParameterRootAttributeOneBackingList(Collection<? extends Object> items, String valueProperty, String labelProperty)
    {
        this.complexParameterRootAttributeOneValueList = null;
        this.complexParameterRootAttributeOneLabelList = null;
        if (items != null)
        {
            this.complexParameterRootAttributeOneValueList = new Object[items.size()];
            this.complexParameterRootAttributeOneLabelList = new Object[items.size()];

            try
            {
                final List<String> labelProperties =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\W&&[^\\.]]+")));
                final List<String> labelDelimiters =
                    labelProperty == null ? null : new ArrayList<String>(Arrays.asList(labelProperty.split("[\\w\\.]+")));
                int ctr = 0;
                for (final Iterator<? extends Object> iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final Object item = iterator.next();
                    if (item != null)
                    {
                        this.complexParameterRootAttributeOneValueList[ctr] = valueProperty == null ? item :
                            PropertyUtils.getProperty(item, valueProperty.trim());
                        if (labelProperties == null)
                        {
                            this.complexParameterRootAttributeOneLabelList[ctr] = item;
                        }
                        else
                        {
                            final StringBuilder labelText = new StringBuilder();
                            int ctr2 = 0;
                            do
                            {
                                if (!labelDelimiters.isEmpty())
                                {
                                    labelText.append(labelDelimiters.get(ctr2));
                                }
                                String property = null;
                                if (ctr2 < labelProperties.size())
                                {
                                    property = labelProperties.get(ctr2);
                                }
                                if (property != null && property.length() > 0)
                                {
                                    if (PropertyUtils.isReadable(item, property))
                                    {
                                        Object value = PropertyUtils.getProperty(item, property);
                                        if (value != null)
                                        {
                                            if (value instanceof String)
                                            {
                                                if (((String)value).trim().length() == 0)
                                                {
                                                    value = null;
                                                }
                                            }
                                            if (value != null)
                                            {
                                                labelText.append(value);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        labelText.append(property);
                                    }
                                }
                                ctr2++;
                            }
                            while (ctr2 < labelDelimiters.size());
                            this.complexParameterRootAttributeOneLabelList[ctr] = labelText.toString().replaceAll("\\s+", " ").trim();
                        }
                    }
                }
            }
            catch (final Throwable throwable)
            {
                throw new RuntimeException(throwable);
            }
        }
    }


    /**
     * Resets all the "isSet" flags.
     */
     public void resetIsSetFlags()
     {
         this.resetDateSet();
         this.resetTimeSet();
         this.resetTextSet();
         this.resetNumberSet();
         this.resetCollectionsSet();
         this.resetSelectableSet();
         this.resetBoolSet();
         this.resetMultiSelectsSet();
         this.resetTitleSet();
         this.resetFileSet();
         this.resetMultiFormatSet();
         this.resetDateWithTimeSet();
         this.resetDateWithoutCalendarSet();
         this.resetHasCustomValidatorSet();
         this.resetIntegerClassSet();
         this.resetSetClassesSet();
         this.resetMapClassSet();
         this.resetBooleanClassSet();
         this.resetFloatClassSet();
         this.resetHiddenWithDefaultValueSet();
         this.resetBAdNameSet();
         this.resetComplexParameterSet();
     }

    /**
     * Stores any date or time formatters for this form.
     */
    private final Map<String, DateFormat> dateTimeFormatters =
        new HashMap<String, DateFormat>();

    /**
     * Gets any date and time formatters (keyed by property name)
     * for this form.
     *
     * @return the Map containing any date and time formatters.
     */
    public Map<String, DateFormat> getDateTimeFormatters()
    {
        return this.dateTimeFormatters;
    }

    /**
     * The current collection of messages stored within this form.
     */
    private transient Map<String, FacesMessage> jsfMessages =
        new LinkedHashMap<String, FacesMessage>();


    /**
     * Adds a {@link FacesMessage} message to the current messages
     * stored within this form.
     *
     * @param jsfMessage the faces message to add.
     */
    public void addJsfMessages(FacesMessage jsfMessage)
    {
        if (this.jsfMessages != null)
        {
            this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
        }
    }

    /**
     * Gets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @return the current Faces messages.
     */
    public Collection<FacesMessage> getJsfMessages()
    {
        if (this.jsfMessages == null)
        {
            this.jsfMessages = new LinkedHashMap<String, FacesMessage>();
        }
        return this.jsfMessages.values();
    }

    /**
     * Sets the current {@link FacesMessage} message
     * instances stored within this form.
     *
     * @param messages a collection of the current Faces messages.
     */
    public void setJsfMessages(final Collection<FacesMessage> messages)
    {
        if (messages != null)
        {
            for (final FacesMessage jsfMessage: messages)
            {
                this.jsfMessages.put(jsfMessage.getDetail(), jsfMessage);
            }
        }
    }

    /**
     * Clear the current {@link FacesMessage} message
     * instances stored within this form.
     */
    public void clearJsfMessages()
    {
        this.jsfMessages.clear();
    }

    /**
     * The faces message title (used on a view).
     */
    private String jsfMessagesTitle;

    /**
     * The optional faces message title to set (used on a view).  If not set, the default title
     * will be used.
     *
     * @param jsfMessagesTitleIn the title to use for the messages on the view.
     */
    public void setJsfMessagesTitle(final String jsfMessagesTitleIn)
    {
        this.jsfMessagesTitle = jsfMessagesTitleIn;
    }

    /**
     * Gets the faces messages title to use.
     *
     * @return the faces messages title.
     */
    public String getJsfMessagesTitle()
    {
        return this.jsfMessagesTitle;
    }

    /**
     * Gets the maximum severity of the messages stored in this form.
     *
     * @return the maximum severity or null if no messages are present and/or severity isn't set.
     */
    public FacesMessage.Severity getMaximumMessageSeverity()
    {
        FacesMessage.Severity maxSeverity = null;
        for (final FacesMessage message : this.getJsfMessages())
        {
            final FacesMessage.Severity severity = message.getSeverity();
            if (maxSeverity == null || (severity != null && severity.getOrdinal() > maxSeverity.getOrdinal()))
            {
                maxSeverity = severity;
            }
        }
        return maxSeverity;
    }

    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = -7652211626046938046L;
}