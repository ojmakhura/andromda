##
## Set global invariants
##
#set ($stateMachine = $transform.getStateMachine($class))
#set ($initialState = $transform.getInitialState($stateMachine))
#set ($controllerClass = $transform.getControllerClass($class))
#set ($controllerClassName = $transform.toJavaClassName($controllerClass))
#set ($controllerFormName = $transform.toJavaClassName($transform.getControllerForm($class)))
#if (!$controllerFormName)## If there is no form, use the default one
#set ($controllerFormName = "ActionForm")
#end
#set ($className = "${controllerClassName}Abstract")
#set ($packageName = $transform.getPackageName($controllerClass))
##
## This small macro will handle the processing of the argument transition.
## Depending on this transition's target it will rendered different code:
##
## A guarded decision point
##   there is a method for each of these nodes, it will be called here
##
## ActionState & FinalState
##    it will render the action forward from the mapping for this target
##
## ObjectFlowState
##    there is a method for each object flow state, it will be called here
##
## Please note that any merge points are simply skipped, they do not add
## any specific logic.
##
#macro ( processTransition $transition $indent )
#set ($target = $transform.dynamicHelper.skipMergePoints($transition).target)
#if ($transform.dynamicHelper.isGuardedDecisionPoint($target))
${indent}return $transform.toJavaMethodName($target)(mapping, form, request, response);
#elseif ($transform.dynamicHelper.isActionState($target) || $transform.dynamicHelper.isFinalState($target))
${indent}return mapping.findForward("$transform.toForwardName($target)");
#elseif ($transform.dynamicHelper.isObjectFlowState($target))
#set ($objectFlowStateName = $transform.toJavaClassName($target))
#set ($objectFlowStateState = $transform.getObjectFlowStateState($target))
${indent}return set$objectFlowStateName$transform.toJavaClassName($objectFlowStateState)(mapping, form, request, response);
#else
// illegal modelelement : $target.name ($target)
#end
#end
##
## Package declaration and imports
##
package $packageName;

import org.apache.struts.actions.DispatchAction;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.lang.reflect.Method;

##
## Set collections from which methods will be rendered, we convert them to sets
## because we don't want to render doubles (just to make sure)
##
#set ($actionStates = $transform.toSet($transform.dynamicHelper.getActionStates($stateMachine)))
#set ($decisionPoints = $transform.toSet($transform.dynamicHelper.getDecisionPoints($stateMachine)))
#set ($objectFlowStates = $transform.toSet($transform.dynamicHelper.getObjectFlowStates($stateMachine)))
#set ($guardNames = $transform.toSet($transform.getGuardNames($stateMachine)))
#set ($guardedTransitions = $transform.toSet($transform.dynamicHelper.getGuardedTransitions($stateMachine)))
##
## Start of the class declaration, notice how it extends DispatchAction, not Action
##
/**
#generateDocumentation ( $class " " )
 */
public abstract class ${className} extends DispatchAction
{
    private final String dispatchGuardAttributeKey = "org.andromda.cartridges.bpm4struts.dispatchguard";
    private final Object dispatchGuardDummyValue   = new Object();

##
## Global constants used by the decision making processes, please note how their values
## are hashcodes, while they do not need to be unique for each object of the same type we know they
## are unique for String instances that represent the same text.
##
#foreach ($guardName in $guardNames)
#set ($fieldName = $transform.toFinalMemberName($guardName))
#set ($fieldValue = $fieldName.hashCode())
    protected final int $fieldName = $fieldValue;
#end

##
## Since there is only one initial state (with only one outgoing transition we will make the unspecified method
## call the first state vertex.
##
    public final ActionForward unspecified(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
    {
#processTransition ( $initialState.outgoing.iterator().next() "        " )
    }

##
## Each action state will have a corresponding dispatch method, depending on the outgoing
## transitions the macro is called.
##
## If there is only one transition this method is fairly simply, for more transitions
## there needs to be some logic to determine which one has been called. This is done by
## means of a request parameter (notice what happens if there is no custom form class,
## the transition value will be retrieved from the request context in that case).
##
## Each transition needs to have a trigger or this script will not work (hard requirement).
##
#foreach ($actionState in $actionStates)
#set ($methodName = $transform.toJavaMethodName($actionState))
#set ($methodNameImpl = "${methodName}Impl")
    /**
#generateDocumentation ( $actionState "    " )
    */
    public final ActionForward ${methodName}(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
    {
#set ($transition = $actionState.outgoing.iterator().next())## there MUST be only one outgoing transition
#set ($target = $transition.target)
#if ($transform.dynamicHelper.isTriggeredDecisionPoint($target))
#if ($controllerFormName.equals("ActionForm"))
        final String trigger = request.getParameter("trigger").toUpperCase();
#else
        final String trigger = (($controllerFormName)form).getTrigger().toUpperCase();
#end

#foreach ($transition in $target.outgoing)
        if ("$transform.toFinalMemberName($transition.trigger)".equals(trigger))
#processTransition( $transition "            " )

#end
        // if this happens the page specified an illegal trigger: application bug!
        return null;
#else
#processTransition( $transition "        " )
#end
    }

#end
##
## Each decision point in the use-case represents a node where the application flow can take a different
## road depending on a certain decision process that is part of the business.
##
#foreach ($decisionPoint in $decisionPoints)
#if ($transform.dynamicHelper.isGuardedDecisionPoint($decisionPoint))
#set ($methodName = $transform.toJavaMethodName($decisionPoint))
    private ActionForward $methodName(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
    {
        final int ${methodName}Value = ${methodName}Impl(mapping, ($controllerFormName)form, request, response);

        switch(${methodName}Value)
        {
#foreach ($transition in $decisionPoint.outgoing)
            case $transform.toFinalMemberName($transition.guard) :
#processTransition ( $transition "                " )
#end
            default :
                return null;
        }
    }

    /**
     * Possible values this method can return are:
     * <ul>
#foreach ($transition in $decisionPoint.outgoing)
     *  <li>$transform.toFinalMemberName($transition.guard)
#end
     * </ul>
#generateDocumentation ( $decisionPoint "    " )
    */
    protected abstract int ${methodName}Impl(ActionMapping mapping, $controllerFormName form, HttpServletRequest request, HttpServletResponse response);

#end
#end
##
## For each object flow state we will have a method that implements the logic to actually
## set the specified object in the desired state, this is done in the implementation class.
##
#foreach ($objectFlowState in $objectFlowStates)
#set ($objectFlowStateName = $transform.toJavaClassName($objectFlowState))
#set ($objectFlowTypeName = $transform.toJavaClassName($objectFlowState.type))
#set ($objectFlowStateState = $transform.getObjectFlowStateState($objectFlowState))
#set ($methodName = "set$objectFlowStateName$transform.toJavaClassName($objectFlowStateState)")
    private final ActionForward ${methodName}(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception
    {
        ${methodName}Impl(mapping, ($controllerFormName)form, request, response);
#processTransition( $objectFlowState.outgoing.iterator().next() "        " )
    }

    /**
     * This method changes the state of the object with name '$objectFlowState.name' to '$objectFlowStateState.name'. The
     * type of this object is <code>'$transform.toFullyQualifiedJavaClassName($objectFlowState.type)'</code>.
     * <p>
     * Values are transferred from and to the form.
#generateDocumentation ( $objectFlowState "    " )
     */
    protected abstract void ${methodName}Impl(ActionMapping mapping, $controllerFormName form, HttpServletRequest request, HttpServletResponse response) throws Exception;

#end


    /**
     * In some cases it may happen that a single client request is passed onto several controllers, Struts with Tiles
     * is an example: when requesting a page constructed with tiles each tile will receive the same client request.
     * <p>
     * In general this works fine, but with DispatchActions there is a side effect: all controllers will be requested
     * to dispatch to a specific method, and most of the time this method will only exist in one controller.
     * <p>
     * This method takes care of these cases by handling unfound dispatch methods by calling the
     * <code>unspecified()</code> method instead.
     */
    protected final Method getMethod(String s) throws NoSuchMethodException
    {
        Method method = null;

        try
        {
            method = super.getMethod(s);
        }
        catch (NoSuchMethodException e)
        {
            method = super.getMethod("unspecified");
        }

        return method;
    }

    /**
     * A client request contains a parameter that holds the name of the controller's dispatch method to call.
     * Typically this request originates from a page on the client machine and targets a specific controller
     * feature.
     * <p>
     * If the controller decides to forward to another controller this parameter will also be passed on, making
     * the latter controller think he needs to dispatch also to this method. When this method name does not exist
     * the <code>getMethod()</code> method of the controller will handle it, but consider the case where a controller
     * decides to target itself: it will result in an endless-loop because the same dispatch method is
     * called over and over again.
     * <p>
     * In fact, dispatching may only occur once per request. When a controller targets a controller
     * it can only call the <code>unspecified()</code> method (architectural convention).
     * <p>
     * In order to guarantee this this class has a mechanism built-in that sets flag into the request indicating
     * dispatching occurred. The flag is set here if it is not yet present. In case it is present we forward to
     * the <code>unspecified()</code> method.
     */
    protected final ActionForward dispatchMethod(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response, String name) throws Exception
    {
        if (request.getAttribute(dispatchGuardAttributeKey) == null)
        {
            request.setAttribute(dispatchGuardAttributeKey, dispatchGuardDummyValue);
            return super.dispatchMethod(mapping, form, request, response, name);
        }
        else
        {
            return unspecified(mapping, form, request, response);
        }
    }
}
