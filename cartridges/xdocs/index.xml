<?xml version="1.0"?>

<document>

  <properties>
    <author email="mbohlen@mbohlen.de">Matthias Bohlen</author>
    <author email="chdbrandon@yahoo.com">Chad Brandon</author>
    <title>The cartridge system of AndroMDA</title>
    <gennews>no</gennews>
  </properties>

  <body>

    <section name="The cartridge system of AndroMDA">
 
      <p>
			The <strong>primary plugin</strong> of the AndroMDA framework, <em>cartridges</em>
			provide the ability to process model elements that have specified <code>stereotypes</code>
			(i.e. <code><![CDATA[<<Entity>>]]></code>, <code><![CDATA[<<Enumeration>>]]></code>, etc.).  
			Cartridges process these model elements using template files defined within the cartridge
			<a href="descriptor-schema.html">descriptor</a>.
      </p>
      <p>
          This page describes the internal structure of an AndroMDA cartridge.
          After reading it, you will probably find it very easy to write your
          own cartridge or customize an existing cartridge for your needs.
      </p>

      <h2>Using a cartridge</h2>
      <p>
          If you want to use existing cartridge(s) for generation 
          (i.e. the <a href="../andromda-bpm4struts-cartridge/index.html">BPM4Struts Cartridge</a>, 
          etc.), simply place the cartridges on your classpath; using the 
          <a href="../maven-andromda-plugin/index.html">AndromMDA Maven Plugin</a> 
          this is VERY simple, you just add the AndroMDA maven plugin and cartridge(s)
          as dependencies to your project.xml file and then run the plugin goal 
          <em>andromda:run</em>, that's it!
          <source><![CDATA[
<dependencies>
    ...
	<dependency>
		<groupId>andromda</groupId>
		<artifactId>maven-andromda-plugin</artifactId>
		<version>3.0</version>
		<type>plugin</type>
	</dependency>
	<dependency>
		<groupId>andromda-cartridges</groupId>
		<artifactId>andromda-bpm4struts-cartridge</artifactId>
		<version>3.0</version>
	</dependency>
	<dependency>
		<groupId>andromda-hibernate</groupId>
		<artifactId>andromda-bpm4struts-cartridge</artifactId>
		<version>3.0</version>
	</dependency>
	...
</dependencies>
]]></source>
      </p>

      <h2>Inside a cartridge</h2>
      <p>
          An AndroMDA cartridge is a "thing" (directory or jar file)
          on the classpath that consists of several items:
      </p>
      <table border="1" cellpadding="4">
        <tr>
          <td valign="top"><b>File</b></td>
          <td valign="top"><b>Contents</b></td>
          <td align="center"><b>Required</b></td>
        </tr>
		<tr>
			<td valign="top">
				<code>src/java/**/*</code>
			</td>
			<td valign="top">Source code for classes that are invoked at 
				runtime of the code generated by that cartridge.
			</td>
			<td valign="top">
				No.
			</td>			
		</tr>
		<tr>
			<td nowrap="nowrap">
				<code>src/META-INF/andromda-cartridge.xml</code>
			</td>
			<td valign="top"> 
				Declarative cartridge descriptor (see below). 
			</td>
			<td valign="top"> 
				Yes. 
			</td>
		</tr>
		<tr>
			<td nowrap="nowrap">
				<code>src/META-INF/andromda-metafacades.xml</code>
			</td>
			<td valign="top"> 
				Metafacades descriptor. This is used to specify
				facades for the underlying metamodel (UML 1.4, etc.).
			</td>
			<td valign="top"> 
				No. 
			</td>
		</tr>
        <tr>
			<td valign="top">
				<code>src/templates/*.vsl</code>
			</td>
          <td valign="top">
			  Templates that tell the cartridge how to format the generated code.
		  </td>
          <td valign="top">Yes.</td>
        </tr>
      </table>
      <p>
          All items except the descriptor and the templates are optional. If
          you want to see a complete cartridge, have a look inside the 
          <em>andromda-bpm4struts-cartridge</em> cartridge.
      </p>

      <h2>The cartridge descriptor</h2>

      <p>
        The descriptor allows AndroMDA to find this cartridge on the classpath automatically.
        The core also uses this descriptor to find out the capabilities of a cartridge: the
        supported stereotypes, the outlets and, templates and the variable name
        to place the model element(s) into in the template. The cartridge descriptor <b>must</b>
        reside in the <code>META-INF</code> subdirectory and <b>must</b> be named
        <code>andromda-cartridge.xml</code>.
      </p>

      <p>
        Let's have a look at part of a typical cartridge descriptor:
      </p>
      <source><![CDATA[
<cartridge name="ejb">

    <templateEngine>
        <!-- library of macros used in template engine -->
       <macrolibrary name="templates/EJB.vm" />
    </templateEngine>

    <!-- define the template objects that are made availble to the template -->
    <templateObject name="str" className="org.andromda.core.common.StringUtilsHelper"/>
    <templateObject name="transform" className="org.andromda.cartridges.ejb.EJBScriptHelper"/>
    
    <template
        sheet="templates/EntityBean.vsl"
        outputPattern="{0}/{1}Bean.java"
        outlet="entity-beans"
        overWrite="true">
        <modelElements variable="class">
            <modelElement stereotype="Entity"/>    
        </modelElements>
    </template>

    <template
        sheet="templates/EntityLocalIntf.vsl"
        outputPattern="{0}/{1}.java"
        outlet="entity-beans"
        overWrite="true">
        <modelElements variable="class">
            <modelElement stereotype="Entity"/>    
        </modelElements>
    </template>

    <template
        sheet="templates/EntityHome.vsl"
        outputPattern="{0}/{1}LocalHome.java"
        outlet="entity-beans"
        overWrite="true">
        <modelElements variable="class">
            <modelElement stereotype="Entity"/>    
        </modelElements>
    </template>
    
    <template
        sheet="templates/EntityBeanImpl.vsl"
        outputPattern="{0}/{1}BeanImpl.java"
        outlet="entity-impls"
        overWrite="false">
        <modelElements variable="class">
            <modelElement stereotype="Entity"/>  
        </modelElements>  
    </template>

	...
    
</cartridge>
      ]]></source>
      <p>
          Note the usage
          of the <code>"{0}/"</code> pattern. This will cause the target
          java file to be generated into <code>"com/mycompany/test"</code>
          if it was in the package <code>"com.mycompany.test"</code>.
      </p>

      <h3><![CDATA[<cartridge/>]]></h3>
      <p>
        The <code><![CDATA[<cartridge/>]]></code> element is the root of
        the cartridge descriptor and also gives a name to the cartridge.
      </p>
      <table border="1" cellpadding="2" cellspacing="0">
          <tr>
              <td valign="top">
			      <b>Attribute</b>
			  </td>
              <td valign="top">
              	  <b>Description</b>
              </td>
              <td valign="top">
                  <b>Required?</b>
              </td>
          </tr>
          <tr>
			  <td>name</td>
			  <td>
				  Specifies the name of the cartridge.
			  </td>
			  <td >Yes</td>
          </tr>
      </table>
      <h3><![CDATA[<property/>]]></h3>
      <p>
        The <code><![CDATA[<property/>]]></code> element is used to specify 
        property references for a cartridge.  These references are defined
        by the calling client of a cartridge.  For example, if you have
        the property reference <code>securityEnabled</code> defined 
        (i.e. <strong><![CDATA[<property reference="securityEnabled"/>]]></strong>), 
        then the framework will expect the client to define a namespace property 
        named <code>securityEnabled</code> when this cartridge is run. This property 
        (and it's value) will then be made available to the template during processing
      </p>
      <table border="1" cellpadding="2" cellspacing="0">
          <tr>
              <td valign="top">
			      <b>Attribute</b>
			  </td>
              <td valign="top">
              	  <b>Description</b>
              </td>
              <td valign="top">
                  <b>Required?</b>
              </td>
          </tr>
          <tr>
			  <td>reference</td>
			  <td>
				  Specifies the name of the reference.  This is
				  the name that must be defined in the namespace
				  and its the name that will be made available to 
				  the template during processing.
			  </td>
			  <td >Yes</td>
          </tr>
          <tr>
			  <td>default</td>
			  <td>
				  Specifies the default value to be used if
				  <strong>NOT</strong> supplied by the 
				  cartridge client.
			  </td>
			  <td >No</td>
          </tr>
      </table>
      <h3><![CDATA[<template/>]]></h3>
      <p>
        The <code><![CDATA[<template/>]]></code> element is used to describe
        the template that will be used to generate source code.
      </p>
      <table border="1" cellpadding="2" cellspacing="0">
        <tr>
          <td><b>Attribute</b></td>
          <td><b>Description</b></td>
          <td align="center"><b>Required?</b></td>
        </tr>
        <tr>
          <td>sheet</td>
          <td>
              Specifies the path (relative to the cartridge root)
              for a template (*.vsl) file to use for code generation.
          </td>
          <td >Yes.</td>
        </tr>
        <tr>
          <td>outputPattern</td>
          <td>Specifies a pattern in
			   <a href="http://java.sun.com/j2se/1.4/docs/api/java/text/MessageFormat.html">
				 java.text.MessageFormat</a> syntax.
			   You can use this pattern to tell AndroMDA how to construct
			   output file names. The pattern can consist of any ordinary
			   printable characters as well as some predefined placeholders
			   for things that AndroMDA already knows about: <br />
			   <code>{0}</code> stands for the package directory of the class.<br />
			   <code>{1}</code> stands for the class name.<br />
			   See example above.
          </td>
          <td>Yes.</td>
        </tr>
        <tr>
          <td>outlet</td>
          <td>
          	   Specifies the logical name of the outlet
			   where the cartridge will write the output files
			   caused by this template.
		  </td>
          <td>Yes.</td>
        </tr>
        <tr>
          <td>overWrite</td>
          <td>
              Specifies whether the files already specified by the 
              <code>outlet</code> attribute should be overwritten 
              when AndroMDA runs the next time.
          </td>
          <td>Yes.</td>
        </tr>
        <tr>
          <td>generateEmptyFiles</td>
          <td>
	          Specifies whether files should be generated even if the template did not produce
              any output. This can be used by the cartridge developer to decide if a certain file should be generated
              based on the information in the model. <em>Note:</em> If this property is set to "false", the
              template produces no output, <code>overWrite</code> is set to "true", and an existing file is found
              (probably generated by a previous run), then this file is removed.
          </td>
          <td>
		      No, default is <code>false</code>.
		   </td>
        </tr>
		<tr>
			<td>
				outputToSingleFile
			</td>
			<td>
				Specifies whether you want to output all stereotyped
				model elements to a single file.  This is useful for example
				if you wanted to generated a SQL script that had tables for 
				all entities in your model.  This also allows you to group 
				more than one type of model element into multiple collections
				which are then made available to your templates.
			</td>
			<td>
				No, default is <code>false</code>.
			</td>
		</tr>
		<tr>
		    <td>
				required
		    </td>
			<td>
				Specifies whether or not the template is required during
				processing, if set to false, AndroMDA will ignore the
				fact that no outlet property has been defined in a namespace
				when running AndroMDA.  Otherwise if its true, warnings
				will be issued notifying a cartridge user that they must 
				define a property matching the outlet name.
			</td>
			<td>
				No, default is <code>true</code>.
			</td>	
		</tr>
      </table>
    </section>
  </body>
</document>
