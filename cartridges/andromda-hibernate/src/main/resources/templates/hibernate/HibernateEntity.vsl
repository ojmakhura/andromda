#set ($generatedFile = "${entity.packagePath}/${entity.entityName}.java")
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by hibernate/HibernateEntity.vsl in andromda-hibernate-cartridge#if($dateTimeGeneratedText) on $hibernateUtils.date#end.
//
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end

#if(!$entity.generalization)
import java.io.Serializable;

#end
/**
$entity.getDocumentation(" * ")
 */
#if ($hibernateEntityAnnotations)
@jakarta.persistence.Entity
@jakarta.persistence.Table(name = "${entity.tableName}"#if($stringUtils.isNotBlank($entity.schema)), schema="$entity.schema"#end)
##, uniqueConstraints=@UniqueConstraint(name="",columnNames={"", ""}
##if(!$entity.lazy), lazy="false"#end
##if($entity.hibernateProxy), proxy="$entity.fullyQualifiedEntityName"#end
##, dynamic-insert="$entity.dynamicInsert" dynamic-update="$entity.dynamicUpdate"
##if (!$entity.specializations.empty && $entity.hibernateInheritanceClass && !$entity.abstract), discriminator-value="$entity.hibernateDiscriminatorValue"#end
##if ($entity.xmlTagName), node="$entity.xmlTagName"#end
##if ($entity.abstract), abstract="true"#end)
##if ($entity.listenerEnabled)
##@jakarta.persistence.EntityListeners({${entity.fullyQualifiedEntityListenerName}.class})
##else
##// Uncomment to enable entity listener for ${entity.entityName}
##// @jakarta.persistence.EntityListeners({${entity.fullyQualifiedEntityListenerName}.class})
##end
#set ($discriminatorColumnDefinition = "$entity.hibernateDiscriminatorColumn $entity.hibernateDiscriminatorType $entity.hibernateDiscriminatorType ($entity.hibernateDiscriminatorLength) NOT NULL")
##        <discriminator column="$entity.hibernateDiscriminatorColumn" type="$entity.hibernateDiscriminatorType"/>
## Only include the inheritance related annotations for inheritance mapping
## that doesn't involve embeddable superclass hierarchy.
##
## Only include the inheritance and discriminator column mapping for the top level class
## in the hierarchy, regardless of the number of levels in the hierarchy.
##
#if (!$entity.specializations.empty && $entity.generalizations.empty)
@jakarta.persistence.Inheritance(strategy = jakarta.persistence.InheritanceType.$hibernateUtils.getInheritanceTypeEnum(${entity.hibernateInheritanceStrategy}))
##
## Discriminator components only apply to single table mapping strategy
##
#*  *##if ($entity.hibernateInheritanceClass)
#*    *##set ($argExists = false)
@jakarta.persistence.DiscriminatorColumn(#if ($entity.hibernateDiscriminatorColumn)name = "${entity.hibernateDiscriminatorColumn}"#set ($argExists = true)#end#if ($entity.hibernateDiscriminatorType)#if ($argExists), #end#**#discriminatorType = jakarta.persistence.DiscriminatorType.${entity.hibernateDiscriminatorType}#set ($argExists = true)#end#if ($discriminatorColumnDefinition)#if ($argExists), #end#**#columnDefinition = "${discriminatorColumnDefinition}"#set ($argExists = true)#end#if ($entity.hibernateDiscriminatorLength > 0)#if ($argExists), #end#**#length = ${entity.hibernateDiscriminatorLength}#end)
@jakarta.persistence.DiscriminatorValue("${entity.hibernateDiscriminatorValue}")
#*  *##end
#elseif ($entity.generalizations.empty && $entity.hibernateInheritanceClass)## && !$entity.embeddableSuperclassGeneralizationExists)

##
## Only include the DiscriminatorValue annotation for subclasses if
## the inheritance strategy is single table mapping strategy.
##
@jakarta.persistence.DiscriminatorValue("${entity.hibernateDiscriminatorValue}")
#end
#if ($hibernateEnableCache.equalsIgnoreCase("true"))
@org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.${entity.hibernateCacheType})
#else
// Uncomment to enable caching for ${entity.entityName}
// @org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.${entity.hibernateCacheType})
#end
#set ($finders = $entity.getQueryOperations(false))
#set ($entityIdVariable = $stringUtils.uncapitalize(${entity.name}).substring(0,1))
#if (!$finders.empty)
@jakarta.persistence.NamedQueries
({
##if ($entity.genericFinders && !$entity.finderFindAllExists)
#if (!$entity.finderFindAllExists)
    @jakarta.persistence.NamedQuery(name = "${entity.name}.findAll", query = "SELECT $entityIdVariable FROM ${entity.name} AS $entityIdVariable")#if (!$finders.empty),#end

#end
#foreach ($finder in $finders)
    @jakarta.persistence.NamedQuery(name = "${entity.name}.${finder.name}", query = "${finder.query}")#if($velocityCount != $finders.size()), #end

#end
})
#else
##if ($entity.genericFinders)
@jakarta.persistence.NamedQuery(name = "${entity.name}.findAll", query = "SELECT $entityIdVariable FROM ${entity.name} AS $entityIdVariable")#if (!$finders.empty),#end

##end
#end
#end
#foreach($annotation in $entity.additionalAnnotations)
@$annotation
#end
// HibernateEntity.vsl annotations merge-point
public class $entity.entityName
#if($entity.generalization)
#if ($entity.generalization.fullyQualifiedEntityName)
#set ($generalizationName = $entity.generalization.fullyQualifiedEntityName)
#else
#set ($generalizationName = $entity.generalization.fullyQualifiedName)
#end
    extends $generalizationName
#else
    implements Serializable, Comparable<${entity.entityName}>
#if (!$entity.interfaceAbstractions.empty)
        , $entity.implementedInterfaceList
#end
#end
{
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = ${entity.serialVersionUID}L;

#if ($stringUtils.isNotBlank($entity.hibernateVersionProperty))
#if (!$entity.generalization || ($entity.generalization && !$entity.hibernateInheritanceSubclass))
#set ($versionProperty = $entity.hibernateVersionProperty)
#set ($versionPropertyCapitalized = $stringUtils.capitalize($entity.hibernateVersionProperty))
    /**
     * Version property managed by Hibernate.
     */
    private int $versionProperty;

    public int get$versionPropertyCapitalized()
    {
        return this.$versionProperty;
    }

    private void set$versionPropertyCapitalized (int ${versionProperty}In)
    {
        this.$versionProperty = ${versionProperty}In;
    }

#end
#end
#if($entity.compositeIdentifier)
#if ($hibernateEntityAnnotations)
    @jakarta.persistence.EmbeddedId
#end
#if ($generateAttributeNameConstant)
    public static final String ${attributeNameConstantPrefix}${entity.identifierName}="${entity.identifierName}";

#end
    private $entity.fullyQualifiedIdentifierTypeName $entity.identifierName;

    /**
     * Get the composite primary key identifier class
     * @return ${entity.identifierName}
     */
    public $entity.fullyQualifiedIdentifierTypeName ${entity.identifierGetterName}()
    {
        return this.${entity.identifierName};
    }

    /**
     * Set the composite primary key identifier class
     * @param ${entity.identifierName}In
     */
    public void ${entity.identifierSetterName}($entity.fullyQualifiedIdentifierTypeName ${entity.identifierName}In) {
        this.$entity.identifierName = ${entity.identifierName}In;
    }

#end
#if (!$entity.attributes.empty)
    // Generate $entity.attributes.size() attributes
#end
## Identifier attribute is automatically added to the list of attributes.
#foreach ($attribute in $entity.attributes)
#renderAttribute($entity $attribute)
#end
#if (!$entity.navigableConnectingEnds.empty)
    // Generate $entity.navigableConnectingEnds.size() associations
#end
#foreach ($associationEnd in $entity.associationEnds)
#renderAssociation($entity $associationEnd)
#end
#if (!$entity.businessOperations.empty)
    // Generate $entity.businessOperations.size() businessOperations
#end
#foreach ($operation in $entity.businessOperations)
    /**
$operation.getDocumentation("     * ")
#foreach ($argument in $operation.arguments)
     * @param $argument.name $argument.getDocumentation("")
#end
#if ($operation.returnTypePresent)
     * @return $operation.getterSetterReturnTypeName
#end
#foreach ($exception in $operation.exceptions)
     * @throws $exception.name
#end
     */
#if ($operation.exceptionsPresent)
    $operation.visibility $operation.getterSetterReturnTypeName $operation.signature
        throws $operation.exceptionList
#else
    $operation.visibility $operation.getterSetterReturnTypeName $operation.signature
#end
    {
#if ($operation.returnTypePresent)
        // Your implementation required in descendant
        return null;
#end
    }

#end
#if ($generateEntityEqualsAndHashCode.equalsIgnoreCase('true'))
#set ($identifiers = $entity.getIdentifiers(false))
    /**
#if ($identifiers.empty)
     * This entity does not have any identifiers
#if (${entity.generalization.fullyQualifiedEntityName})
     * but since it extends the <code>$entity.generalization.fullyQualifiedEntityName</code> class
     * it will simply delegate the call up there.
     *
     * @see ${entity.generalization.fullyQualifiedEntityName}${esc.hash}equals(Object)
#else
     * and is not extending any other entity,
     * so this method will only return <code>true</code> if the argument reference and <code>this</code>
     * refer to the same object.
#end
#else
#if (${entity.generalization.fullyQualifiedEntityName})
     * Returns <code>true</code> if the argument is an $entity.entityName instance and all identifiers for this entity
     * equal the identifiers of the argument entity. The <code>equals</code> method of the parent entity
     * will also need to return <code>true</code>. Returns <code>false</code> otherwise.
     *
     * @see ${entity.generalization.fullyQualifiedEntityName}${esc.hash}equals(Object)
#else
     * Returns <code>true</code> if the argument is an $entity.entityName instance and all identifiers for this entity
     * equal the identifiers of the argument entity. Returns <code>false</code> otherwise.
#end
#end
     */
#renderEqualsMethod($entity $entity.entityName $identifiers)

    /**
#if ($identifiers.empty)
     * This entity does not have any identifiers
#if (${entity.generalization.fullyQualifiedEntityName})
     * but since it extends the <code>$entity.generalization.fullyQualifiedEntityName</code> class
     * it will simply delegate the call up there.
     *
     * @see ${entity.generalization.fullyQualifiedEntityName}${esc.hash}hashCode()
#else
     * and is not extending any other entity,
     * so this method will only take the identifiers of this entity into account when calculating the hash code.
#end
#else
#if (${entity.generalization.fullyQualifiedEntityName})
     * Returns a hash code based on this entity's identifiers and the hash code of the parent entity.
     *
     * @see ${entity.generalization.fullyQualifiedEntityName}${esc.hash}hashCode()
#else
     * Returns a hash code based on this entity's identifiers.
#end
#end
     */
#renderHashCodeMethod($entity $entity.entityName $identifiers)

#end
#if (!$entity.abstract)
    /**
     * Constructs new instances of {@link ${entity.fullyQualifiedName}}.
     */
    public static final class Factory
    {
        /**
         * Constructs a new instance of {@link ${entity.fullyQualifiedName}}.
         * @return new ${entity.fullyQualifiedEntityName}()
         */
        public static $entity.fullyQualifiedName newInstance()
        {
            return new ${entity.fullyQualifiedEntityName}();
        }

## Allow for the possibility that identifiers might be seen as required if default multiplicity is set to 1
#set ($allSize = $entity.allProperties.size())
#if (!$entity.usingForeignIdentifier)
## allRequiredProperties includes identifiers, which should never be required. subtract 1 from allProperties.size()
#foreach ($identifier in $entity.identifiers)
#set ($allSize = $allSize - 1)
#end
#end
#set ($requiredParams=0)
#foreach ($property in $entity.allRequiredConstructorParameters)
#if ($entity.usingForeignIdentifier || !$property.identifier)
#set ($requiredParams=$requiredParams+1)
#end
#end
## Don't duplicate newInstance if there are no optional parameters or no required parameters
#if ($requiredParams < $allSize && $requiredParams > 0)
        /**
         * Constructs a new instance of {@link ${entity.fullyQualifiedName}}, taking all required and/or
         * read-only properties as arguments, except for identifiers.
#foreach ($property in $entity.allRequiredConstructorParameters)
#if ($entity.usingForeignIdentifier || !$property.identifier)
         * @param ${property.name} ${property.getterSetterTypeName}
#end
#end
         * @return newInstance
         */
        public static $entity.fullyQualifiedName newInstance(## no newline
#set ($comma = "")
#foreach ($property in $entity.allRequiredConstructorParameters)
#if ($entity.usingForeignIdentifier || !$property.identifier)
${comma}${property.getterSetterTypeName} ${property.name}## no newline
#set ($comma = ", ")
#end
#end
)
        {
            final ${entity.fullyQualifiedName} entity = new ${entity.fullyQualifiedEntityName}();
#foreach ($property in $entity.allRequiredConstructorParameters)
#if (!$property.identifier || $entity.usingForeignIdentifier)
#if ($property.hibernateEntityAttributeMetaType || ($property.navigable && $property.otherEnd))
#if ($property.readOnly)
            entity.${property.name} = ${property.name};
#else
            entity.${property.setterName}(${property.name});
#end
#end
#end
#end
            return entity;
        }
#end
#set ($propertiesPresent = false)
#foreach ($property in $entity.allProperties)
#if ($entity.usingForeignIdentifier || !$property.identifier)
#set ($propertiesPresent = true)
#end
#end
#if ($propertiesPresent)

        /**
         * Constructs a new instance of {@link ${entity.fullyQualifiedName}}, taking all possible properties
         * (except the identifier(s))as arguments.
#foreach ($property in $entity.allProperties)
#if ($entity.usingForeignIdentifier || !$property.identifier)
         * @param ${property.name} ${property.getterSetterTypeName}
#end
#end
         * @return newInstance $entity.fullyQualifiedName
         */
        public static $entity.fullyQualifiedName newInstance(## no newline
#set ($comma = "")
#foreach ($property in $entity.allProperties)
#if (!$property.identifier || $entity.usingForeignIdentifier)
${comma}${property.getterSetterTypeName} ${property.name}## no newline
#set ($comma = ", ")
#end
#end
)
        {
            final ${entity.fullyQualifiedName} entity = new ${entity.fullyQualifiedEntityName}();
#foreach ($property in $entity.allProperties)
#if (!$property.identifier || $entity.usingForeignIdentifier)
#if ($property.hibernateEntityAttributeMetaType || ($property.navigable && $property.otherEnd))
#if ($property.readOnly)
            entity.${property.name} = ${property.name};
#else
            entity.${property.setterName}(${property.name});
#end
#end
#end
#end
            return entity;
        }
#end
    }

#end
#renderCompareToMethod($entity $entity.entityName $entity.identifiers)

## Don't want to render associations because we may get an infinite loop on bidirectional relationships. Can we render only the remote Entity IDs?
#renderToStringMethod($entity $entity.entityName $entity.getAttributes(true))
// HibernateEntity.vsl merge-point
}