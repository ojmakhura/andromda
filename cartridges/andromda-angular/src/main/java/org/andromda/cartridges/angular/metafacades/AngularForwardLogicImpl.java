// license-header java merge-point
//
// Generated by: MetafacadeLogicImpl.vsl in andromda-meta-cartridge.
package org.andromda.cartridges.angular.metafacades;

import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

import org.andromda.cartridges.angular.AngularProfile;
import org.andromda.metafacades.uml.StateVertexFacade;
import org.andromda.utils.StringUtilsHelper;

/**
 * Represents a forward within a JSF activity graph.
 * MetafacadeLogic implementation for org.andromda.cartridges.angular.metafacades.AngularForward.
 *
 * @see org.andromda.cartridges.angular.metafacades.AngularForward
 */
public class AngularForwardLogicImpl
    extends AngularForwardLogic
{
    private static final long serialVersionUID = 34L;
    /**
     * Public constructor for AngularForwardLogicImpl
     * @see org.andromda.cartridges.angular.metafacades.AngularForward
     */
    public AngularForwardLogicImpl (Object metaObject, String context)
    {
        super(metaObject, context);
    }

    /**
     * The path to which this forward points.
     * @see org.andromda.cartridges.angular.metafacades.AngularForward#getPath()
     */
    protected String handleGetPath()
    {
        String forwardPath = null;
        final StateVertexFacade target = getTarget();
        if (this.isEnteringView())
        {
            forwardPath = ((AngularView)target).getPath();
        }
        else if (this.isEnteringFinalState())
        {
            forwardPath = ((AngularFinalState)target).getPath();
        }

        return forwardPath;
    }

    /**
     * Indicates whether or not a final state is the target of this forward.
     * @see org.andromda.cartridges.angular.metafacades.AngularForward#isFinalStateTarget()
     */
    protected boolean handleIsFinalStateTarget()
    {
        return this.getTarget() instanceof AngularFinalState;
    }

    /**
     * The name that corresponds to the from-outcome in an navigational rule.
     * @see org.andromda.cartridges.angular.metafacades.AngularForward#getFromOutcome()
     */
    protected String handleGetFromOutcome()
    {
        return this.getName();
    }

    /**
     * Messages used to indicate successful execution.
     * @see org.andromda.cartridges.angular.metafacades.AngularForward#getSuccessMessages()
     */
    protected Map handleGetSuccessMessages()
    {
        return this.getMessages(AngularProfile.TAGGEDVALUE_ACTION_SUCCESS_MESSAGE);
    }

    /**
     * Indicates whether or not any success messags are present.
     * @see org.andromda.cartridges.angular.metafacades.AngularForward#isSuccessMessagesPresent()
     */
    protected boolean handleIsSuccessMessagesPresent()
    {
        return !this.getSuccessMessages().isEmpty();
    }

    /**
     * Any messages used to indicate a warning.
     * @see org.andromda.cartridges.angular.metafacades.AngularForward#getWarningMessages()
     */
    protected Map handleGetWarningMessages()
    {
        return this.getMessages(AngularProfile.TAGGEDVALUE_ACTION_WARNING_MESSAGE);
    }

    /**
     * Whether or not any warning messages are present.
     * @see org.andromda.cartridges.angular.metafacades.AngularForward#isWarningMessagesPresent()
     */
    protected boolean handleIsWarningMessagesPresent()
    {
        return !this.getWarningMessages().isEmpty();
    }

    /**
     * Collects specific messages in a map.
     *
     * @param taggedValue the tagged value from which to read the message
     * @return maps message keys to message values, but only those that match the arguments
     *         will have been recorded
     */
    @SuppressWarnings("unchecked")
    private Map<String, String> getMessages(String taggedValue)
    {
        Map<String, String> messages;

        final Collection taggedValues = this.findTaggedValues(taggedValue);
        if (taggedValues.isEmpty())
        {
            messages = Collections.EMPTY_MAP;
        }
        else
        {
            messages = new LinkedHashMap<String, String>(); // we want to keep the order

            for (final Iterator iterator = taggedValues.iterator(); iterator.hasNext();)
            {
                final String value = (String)iterator.next();
                messages.put(StringUtilsHelper.toResourceMessageKey(value), value);
            }
        }

        return messages;
    }
}