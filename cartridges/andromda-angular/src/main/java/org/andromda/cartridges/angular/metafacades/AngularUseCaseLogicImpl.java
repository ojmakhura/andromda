// license-header java merge-point
//
// Generated by: MetafacadeLogicImpl.vsl in andromda-meta-cartridge.
package org.andromda.cartridges.angular.metafacades;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeMap;

import org.andromda.cartridges.angular.AngularGlobals;
import org.andromda.cartridges.angular.AngularHelper;
import org.andromda.cartridges.angular.AngularProfile;
import org.andromda.metafacades.uml.AssociationEndFacade;
import org.andromda.metafacades.uml.AttributeFacade;
import org.andromda.metafacades.uml.ClassifierFacade;
import org.andromda.metafacades.uml.DependencyFacade;
import org.andromda.metafacades.uml.FrontEndAction;
import org.andromda.metafacades.uml.FrontEndActivityGraph;
import org.andromda.metafacades.uml.FrontEndFinalState;
import org.andromda.metafacades.uml.FrontEndForward;
import org.andromda.metafacades.uml.FrontEndParameter;
import org.andromda.metafacades.uml.FrontEndUseCase;
import org.andromda.metafacades.uml.FrontEndView;
import org.andromda.metafacades.uml.IncludeFacade;
import org.andromda.metafacades.uml.ModelElementFacade;
import org.andromda.metafacades.uml.Role;
import org.andromda.utils.StringUtilsHelper;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.lang3.StringUtils;

/**
 * Represents a JSF use case.
 * MetafacadeLogic implementation for AngularUseCase.
 *
 * @see AngularUseCase
 */
public class AngularUseCaseLogicImpl
    extends AngularUseCaseLogic
{
    private static final long serialVersionUID = 34L;
    /**
     * Public constructor for AngularUseCaseLogicImpl
     * @see AngularUseCase
     */
    public AngularUseCaseLogicImpl (Object metaObject, String context)
    {
        super(metaObject, context);
    }

    /**
     * The path to which this use case points.
     * @see AngularUseCase#getPath()
     */
    protected String handleGetPath()
    {
        String actionPath = null;
        final FrontEndActivityGraph graph = this.getActivityGraph();
        if (graph != null)
        {
            final AngularAction action = (AngularAction)graph.getInitialAction();
            if (action != null)
            {
                actionPath = action.getPath();
            }
        }
        return actionPath;
    }

    /**
     * The root path for this use case (this is the path the directory containing the use case's
     * resources).
     * @see AngularUseCase#getPathRoot()
     */
    protected String handleGetPathRoot()
    {
        final StringBuilder pathRoot = new StringBuilder("/");
        final String packagePath = this.getPackagePath();
        final String prefix = packagePath != null ? packagePath.trim() : "";
        pathRoot.append(prefix);
        return pathRoot.toString();
    }

    /**
     * The name that will cause a forward to use case.
     * @see AngularUseCase#getForwardName()
     */
    protected String handleGetForwardName()
    {
        return AngularHelper.toWebResourceName(this.getName()) + AngularGlobals.USECASE_FORWARD_NAME_SUFFIX;
    }

    /**
     * Indicates whether or not we should normalize messages.
     *
     * @return true/false
     */
    private boolean isNormalizeMessages()
    {
        final String normalizeMessages = (String)getConfiguredProperty(AngularGlobals.NORMALIZE_MESSAGES);
        return Boolean.valueOf(normalizeMessages).booleanValue();
    }

    /**
     * Collects all attribute messages into the given Map.
     *
     * @param messages the Map in which messages are collected.
     * @param attributes the attributes to collect the messages from.
     * @param resolvingTypes used to prevent endless recursion.
     */
    private void collectAttributeMessages(Map<String,String> messages, Collection attributes,
        final Collection<ClassifierFacade> resolvingTypes)
    {
        if (attributes != null && !attributes.isEmpty())
        {
            for (final Iterator iterator = attributes.iterator(); iterator.hasNext(); )
            {
                final AngularAttribute attribute = (AngularAttribute)iterator.next();
                messages.put(
                    attribute.getMessageKey(),
                    attribute.getMessageValue());
                // - lets go another level for nested attributes
                this.collectTypeMessages(messages, attribute.getType(), resolvingTypes);
            }
        }
    }

    /**
     * Collects all association end messages into the given Map.
     *
     * @param messages the Map in which messages are collected.
     * @param associationEnds the association ends to collect the messages from.
     * @param resolvingTypes used to prevent endless recursion.
     */
    private void collectAssociationEndMessages(Map<String,String> messages, Collection associationEnds,
        final Collection<ClassifierFacade> resolvingTypes)
    {
        if (associationEnds != null && !associationEnds.isEmpty())
        {
            for (final Iterator iterator = associationEnds.iterator(); iterator.hasNext();)
            {
                final AssociationEndFacade end = (AssociationEndFacade)iterator.next();
                this.collectTypeMessages(messages, end.getType(), resolvingTypes);
            }
        }
    }

    private void collectTypeMessages(Map<String,String> messages, ClassifierFacade type,
         final Collection<ClassifierFacade> resolvingTypes)
    {
        if (type != null)
        {
            if (!resolvingTypes.contains(type))
            {
                resolvingTypes.add(type);
                if (type.isArrayType())
                {
                    type = type.getNonArray();
                }
                //check again, since the type can be changed
                if (!resolvingTypes.contains(type))
                {
                    this.collectAttributeMessages(messages, type.getAttributes(), resolvingTypes);
                    this.collectAssociationEndMessages(messages, type.getNavigableConnectingEnds(), resolvingTypes);
                }
            }
            resolvingTypes.remove(type);
        }
    }

    /**
     * A map with keys sorted alphabetically, normalized across all different use-cases, views, etc.
     * @see AngularUseCase#getAllMessages()
     */
    protected Map handleGetAllMessages()
    {
        final boolean normalize = this.isNormalizeMessages();
        final Map<String, String> messages = normalize ?
            new TreeMap<String, String>() : new LinkedHashMap<String, String>();

        // - only retrieve the messages for the entry use case (i.e. the use case
        //   where the application begins)
        if (this.isEntryUseCase())
        {
            final List<FrontEndUseCase> useCases = this.getAllUseCases();
            for (int ctr = 0; ctr < useCases.size(); ctr++)
            {
                // - usecase
                final AngularUseCase useCase = (AngularUseCase)useCases.get(ctr);
                messages.put(
                    useCase.getTitleKey(),
                    useCase.getTitleValue());

                final List<FrontEndView> views = useCase.getViews();
                for (int ctr2 = 0; ctr2 < views.size(); ctr2++)
                {
                    // - view
                    final AngularView view = (AngularView)views.get(ctr2);
                    messages.put(
                        view.getTitleKey(),
                        view.getTitleValue());
                    messages.put(
                        view.getMessageKey(),
                        view.getMessageValue());
                    messages.put(
                        view.getDocumentationKey(),
                        view.getDocumentationValue());

                    final List<FrontEndParameter> viewVariables = view.getVariables();
                    for (int ctr3 = 0; ctr3 < viewVariables.size(); ctr3++)
                    {
                        // - page variables
                        final Object object = viewVariables.get(ctr3);
                        if (object instanceof AngularParameter)
                        {
                            final AngularParameter parameter = (AngularParameter)object;

                            final Collection<ClassifierFacade> resolvingTypes = new ArrayList<ClassifierFacade>();
                            this.collectAttributeMessages(messages, parameter.getAttributes(), resolvingTypes);
                            this.collectAssociationEndMessages(messages,
                                parameter.getNavigableAssociationEnds(), resolvingTypes);
                            messages.put(
                                parameter.getMessageKey(),
                                parameter.getMessageValue());

                            // - table
                            if (parameter.isTable())
                            {
                                for (String columnName : parameter.getTableColumnNames())
                                {
                                     messages.put(
                                        parameter.getTableColumnMessageKey(columnName),
                                        parameter.getTableColumnMessageValue(columnName));
                                }
                            }
                        }
                    }

                    final List<FrontEndAction> actions = useCase.getActions();
                    for (int ctr3 = 0; ctr3 < actions.size(); ctr3++)
                    {
                        // - action
                        final AngularAction action = (AngularAction)actions.get(ctr3);

                        // - event/trigger
                        final Object trigger = action.getTrigger();
                        if (trigger != null && trigger instanceof AngularEvent)
                        {
                            final AngularEvent event = (AngularEvent)trigger;
                            // only add these when a trigger is present, otherwise it's no use having them
                            messages.put(
                                action.getDocumentationKey(),
                                action.getDocumentationValue());

                            // the regular trigger messages
                            messages.put(
                                event.getResetMessageKey(),
                                event.getResetMessageValue());

                            // this one is the same as doing: action.getMessageKey()
                            messages.put(
                                event.getMessageKey(),
                                event.getMessageValue());

                            // - IMAGE LINK

                            /*if (action.isImageLink())
                            {
                                messages.put(
                                    action.getImageMessageKey(),
                                    action.getImagePath());
                            }*/
                        }

                        // - forwards
                        for (final FrontEndForward forward : action.getTransitions())
                        {
                            if (forward instanceof AngularForward)
                            {
                                final AngularForward forwardTransition = (AngularForward)forward;
                                messages.putAll(forwardTransition.getSuccessMessages());
                                messages.putAll(forwardTransition.getWarningMessages());
                            }
                            else
                            {
                                final AngularAction actionTransition = (AngularAction)forward;
                                messages.putAll(actionTransition.getSuccessMessages());
                                messages.putAll(actionTransition.getWarningMessages());
                            }

                        }

                        // - action parameters
                        final List<FrontEndParameter> parameters = action.getParameters();
                        for (int l = 0; l < parameters.size(); l++)
                        {
                            final Object object = parameters.get(l);
                            if (object instanceof AngularParameter)
                            {
                                final AngularParameter parameter = (AngularParameter)object;
                                final Collection attributes = parameter.getAttributes();
                                if (!attributes.isEmpty())
                                {
                                    for (final Iterator iterator = attributes.iterator(); iterator.hasNext();)
                                    {
                                        final AngularAttribute attribute = (AngularAttribute)iterator.next();
                                        messages.put(
                                            attribute.getMessageKey(),
                                            attribute.getMessageValue());
                                    }
                                }
                                final Collection associationEnds = parameter.getNavigableAssociationEnds();
                                if (!associationEnds.isEmpty())
                                {
                                    for (final Iterator iterator = associationEnds.iterator(); iterator.hasNext();)
                                    {
                                        final AssociationEndFacade end = (AssociationEndFacade)iterator.next();
                                        final ClassifierFacade type = end.getType();
                                        if (type != null)
                                        {
                                            final Collection<AttributeFacade> typeAttributes = type.getAttributes();
                                            if (!attributes.isEmpty())
                                            {
                                                for (final Iterator<AttributeFacade> attributeIterator
                                                    = typeAttributes.iterator(); attributeIterator.hasNext(); )
                                                {
                                                    final AngularAttribute attribute = (AngularAttribute)attributeIterator.next();
                                                    messages.put(
                                                        attribute.getMessageKey(),
                                                        attribute.getMessageValue());
                                                }
                                            }
                                        }
                                    }
                                }
                                messages.put(
                                    parameter.getMessageKey(),
                                    parameter.getMessageValue());
                                messages.put(
                                    parameter.getDocumentationKey(),
                                    parameter.getDocumentationValue());

                                // - submittable input table
                                if (parameter.isInputTable())
                                {
                                    final Collection<String> columnNames = parameter.getTableColumnNames();
                                    for (final Iterator<String> columnNameIterator = columnNames.iterator();
                                        columnNameIterator.hasNext();)
                                    {
                                        final String columnName = columnNameIterator.next();
                                        messages.put(
                                            parameter.getTableColumnMessageKey(columnName),
                                            parameter.getTableColumnMessageValue(columnName));
                                    }
                                }
                                /*if (parameter.getValidWhen() != null)
                                {
                                    // this key needs to be fully qualified since the valid when value can be different
                                    final String completeKeyPrefix =
                                        (normalize)
                                        ? useCase.getTitleKey() + '.' + view.getMessageKey() + '.' +
                                        action.getMessageKey() + '.' + parameter.getMessageKey() : parameter.getMessageKey();
                                    messages.put(
                                        completeKeyPrefix + "_validwhen",
                                        "{0} is only valid when " + parameter.getValidWhen());
                                }*/
                                /*if (parameter.getOptionCount() > 0)
                                {
                                    final List optionKeys = parameter.getOptionKeys();
                                    final List optionValues = parameter.getOptionValues();

                                    for (int m = 0; m < optionKeys.size(); m++)
                                    {
                                        messages.put(
                                            optionKeys.get(m),
                                            optionValues.get(m));
                                        messages.put(
                                            optionKeys.get(m) + ".title",
                                            optionValues.get(m));
                                    }
                                }*/
                            }
                        }

                        // - portlet preferences
                        final AngularPortletPreferences preferences = useCase.getPreferences();
                        if (preferences != null)
                        {
                            final Collection<AttributeFacade> attributes = preferences.getAttributes(true);
                            if (!attributes.isEmpty())
                            {
                                for (final Iterator iterator = attributes.iterator(); iterator.hasNext();)
                                {
                                    final AngularAttribute attribute = (AngularAttribute)iterator.next();
                                    messages.put(
                                        attribute.getMessageKey(),
                                        attribute.getMessageValue());
                                }
                            }
                        }

                        // - exception forwards

                        /*
                        final List exceptions = action.getActionExceptions();

                        if (normalize)
                        {
                            if (exceptions.isEmpty())
                            {
                                messages.put("exception.occurred", "{0}");
                            }
                            else
                            {
                                for (int l = 0; l < exceptions.size(); l++)
                                {
                                    final FrontEndExceptionHandler exception =
                                        (FrontEndExceptionHandler)exceptions.get(l);
                                    messages.put(action.getMessageKey() + '.' + exception.getExceptionKey(), "{0}");
                                }
                            }
                        }
                        else
                        {
                            if (exceptions.isEmpty())
                            {
                                if (!action.isUseCaseStart())
                                {
                                    messages.put(action.getMessageKey() + ".exception", "{0} (java.lang.Exception)");
                                }
                            }
                            else
                            {
                                for (int l = 0; l < exceptions.size(); l++)
                                {
                                    final FrontEndExceptionHandler exception =
                                        (FrontEndExceptionHandler)exceptions.get(l);

                                    // we construct the key using the action message too because the exception can
                                    // belong to more than one action (therefore it cannot return the correct value
                                    // in .getExceptionKey())
                                    messages.put(
                                        action.getMessageKey() + '.' + exception.getExceptionKey(),
                                        "{0} (" + exception.getExceptionType() + ")");
                                }
                            }
                        }*/
                    }
                }
            }
        }
        return messages;
    }

    /**
     * The title message key for this use-case.
     * @see AngularUseCase#getTitleKey()
     */
    protected String handleGetTitleKey()
    {
        return StringUtilsHelper.toResourceMessageKey(
            this.isNormalizeMessages() ? this.getTitleValue() : this.getName()) + '.' +
            AngularGlobals.TITLE_MESSAGE_KEY_SUFFIX;
    }

    /**
     * The title message value for this use-case.
     * @see AngularUseCase#getTitleValue()
     */
    protected String handleGetTitleValue()
    {
        return StringUtilsHelper.toPhrase(getName());
    }

    /**
     * The name of the action class that forwards to this use case.
     * @see AngularUseCase#getActionClassName()
     */
    protected String handleGetActionClassName()
    {
        return StringUtilsHelper.upperCamelCaseName(this.getName());
    }

    /**
     * The fully qualified path to the action class that forwards to this use case.
     * @see AngularUseCase#getFullyQualifiedActionClassPath()
     */
    protected String handleGetFullyQualifiedActionClassPath()
    {
        return this.getFullyQualifiedActionClassName().replace(
            '.',
            '/') + ".java";
    }

    /**
     * The name of the action on the controller that executions this use case.
     * @see AngularUseCase#getControllerAction()
     */
    protected String handleGetControllerAction()
    {
        return StringUtilsHelper.lowerCamelCaseName(this.getName());
    }

    /**
     * The fully qualified name of the action class that forwards to this use case.
     * @see AngularUseCase#getFullyQualifiedActionClassName()
     */
    protected String handleGetFullyQualifiedActionClassName()
    {
        final StringBuilder path = new StringBuilder();
        final String packageName = this.getPackageName();
        if (StringUtils.isNotBlank(packageName))
        {
            path.append(packageName);
            path.append('.');
        }
        path.append(this.getActionClassName());
        return path.toString();
    }

    /**
     * The key under which to store the action form passed along in this in this use-case.
     * @see AngularUseCase#getFormKey()
     */
    protected String handleGetFormKey()
    {
        final Object formKeyValue = this.findTaggedValue(AngularProfile.TAGGEDVALUE_ACTION_FORM_KEY);
        return formKeyValue == null ? Objects.toString(this.getConfiguredProperty(AngularGlobals.ACTION_FORM_KEY))
                                    : String.valueOf(formKeyValue);
    }

    /**
     * The path of the initial target going into this use case.
     * @see AngularUseCase#getInitialTargetPath()
     */
    protected String handleGetInitialTargetPath()
    {
        String path = null;
        final Object target = this.getInitialTarget();
        if (target instanceof AngularView)
        {
            path = ((AngularView)target).getPath();
        }
        else if (target instanceof AngularUseCase)
        {
            path = ((AngularUseCase)target).getPath();
        }
        return path;
    }

    /**
     * Gets the initial target when this use case is entered.
     *
     * @return the initial target.
     */
    private Object getInitialTarget()
    {
        Object initialTarget = null;
        final FrontEndActivityGraph graph = this.getActivityGraph();
        final FrontEndAction action = graph != null ? this.getActivityGraph().getInitialAction() : null;
        final Collection<FrontEndForward> forwards = action != null ? action.getActionForwards() : null;
        if (forwards != null && !forwards.isEmpty())
        {
            final Object target = forwards.iterator().next().getTarget();
            if (target instanceof FrontEndView)
            {
                initialTarget = target;
            }
            else if (target instanceof FrontEndFinalState)
            {
                final FrontEndFinalState finalState = (FrontEndFinalState)target;
                final FrontEndUseCase targetUseCase = finalState.getTargetUseCase();
                if (targetUseCase != null && !targetUseCase.equals(this.THIS()))
                {
                    initialTarget = targetUseCase;
                }
            }
        }
        return initialTarget;
    }

    /**
     * Indicates whether or not the initial target of this use case is a view or not.
     * @see AngularUseCase#isInitialTargetView()
     */
    protected boolean handleIsInitialTargetView()
    {
        return this.getInitialTarget() instanceof AngularView;
    }

    /**
     * Indicates that at least one client/server parameter found in the collection of existing
     * use-cases requires validation.
     * @see AngularUseCase#isApplicationValidationRequired()
     */
    protected boolean handleIsApplicationValidationRequired()
    {
        boolean required = false;
        for (final FrontEndUseCase feUseCase : this.getAllUseCases())
        {
            final AngularUseCase useCase = (AngularUseCase)feUseCase;
            if (useCase.isValidationRequired())
            {
                required = true;
                break;
            }
        }
        return required;
    }

    /**
     * Indicates whether or not at least one parameter in this use-case require validation.
     * @see AngularUseCase#isValidationRequired()
     */
    protected boolean handleIsValidationRequired()
    {
        boolean required = false;
        for (final FrontEndView feView : this.getViews())
        {
            final AngularView view = (AngularView)feView;
            if (view.isValidationRequired())
            {
                required = true;
                break;
            }
        }
        return required;
    }

    /**
     * Indicates whether or not at least one view in the use case has the same name as this use
     * case.
     * @see AngularUseCase#isViewHasNameOfUseCase()
     */
    protected boolean handleIsViewHasNameOfUseCase()
    {
        boolean sameName = false;
        for (final FrontEndView view : this.getViews())
        {
            sameName = ((AngularView)view).isHasNameOfUseCase();
            if (sameName)
            {
                break;
            }
        }
        return sameName;
    }

    /**
     * Indicates whether or not this is a front-end registration use case.  Only one use case can be
     * labeled as a 'registration' use case.
     * @see AngularUseCase#isRegistrationUseCase()
     */
    protected boolean handleIsRegistrationUseCase()
    {
        return this.hasStereotype(AngularProfile.STEREOTYPE_FRONT_END_REGISTRATION);
    }

    /**
     * The suffix for the forwards class name.
     */
    private static final String FORWARDS_CLASS_NAME_SUFFIX = "Forwards";

    /**
     * The name of the class that stores all the forwards paths.
     * @see AngularUseCase#getForwardsClassName()
     */
    protected String handleGetForwardsClassName()
    {
        return StringUtilsHelper.upperCamelCaseName(this.getName()) + FORWARDS_CLASS_NAME_SUFFIX;
    }

    /**
     * Constains all forwards includes regular FrontEndForwards and all actiion forwards.
     * @see AngularUseCase#getAllForwards()
     */
    protected List handleGetAllForwards()
    {
        final Map<String, ModelElementFacade> forwards = new LinkedHashMap<String, ModelElementFacade>();
        for (final AngularAction forward : this.getActionForwards())
        {
            forwards.put(forward.getName(), forward);
        }
        for (final AngularForward forward : this.getForwards())
        {
            forwards.put(forward.getName(), forward);
        }
        return new ArrayList<ModelElementFacade>(forwards.values());
    }

    /**
     * The forward name for the portlet 'view' page.
     * @see AngularUseCase#getPortletViewForwardName()
     */
    protected String handleGetPortletViewForwardName()
    {
        return this.getWebResourceName() + "-portlet-view";
    }

    private String getWebResourceName()
    {
        return AngularHelper.toWebResourceName(this.getName());
    }

    /**
     * The forward name for the portlet 'edit' page.
     * @see AngularUseCase#getPortletEditForwardName()
     */
    protected String handleGetPortletEditForwardName()
    {
        return this.getWebResourceName() + "-portlet-edit";
    }

    /**
     * The forward name for the portlet 'help' page.
     * @see AngularUseCase#getPortletHelpForwardName()
     */
    protected String handleGetPortletHelpForwardName()
    {
        return this.getWebResourceName() + "-portlet-help";
    }

    /**
     * The path to the portlet 'view' page.
     * @see AngularUseCase#getPortletViewPath()
     */
    protected String handleGetPortletViewPath()
    {
        return this.getPath();
    }

    /**
     * The path to the portlet 'edit' page.
     * @see AngularUseCase#getPortletEditPath()
     */
    protected String handleGetPortletEditPath()
    {
        return this.getPathRoot() + "/" + this.getPortletEditForwardName();
    }

    /**
     * The path to the 'help' page of the portlet.
     * @see AngularUseCase#getPortletHelpPath()
     */
    protected String handleGetPortletHelpPath()
    {
        return this.getPathRoot() + "/" + this.getPortletHelpForwardName();
    }

    /**
     * Retrieves all navigation rules for the faces-config.xml
     * @see AngularUseCase#getNavigationRules()
     */
    protected Collection handleGetNavigationRules()
    {
        final Map<String, Object> rules = new LinkedHashMap<String, Object>();
        for (final FrontEndView feView : this.getViews())
        {
            final AngularView view = (AngularView)feView;
            rules.put(view.getFromOutcome(), view);
            for (final Iterator forwardIterator = view.getForwards().iterator(); forwardIterator.hasNext();)
            {
                final Object forward = forwardIterator.next();
                String name;
                if (forward instanceof AngularForward)
                {
                    name = ((AngularForward)forward).getFromOutcome();
                }
                else
                {
                    name = ((AngularAction)forward).getFromOutcome();
                }
                rules.put(name, forward);
            }
        }
        return rules.values();
    }

    /**
     * TODO: Model Documentation for
     * AngularUseCase.getNavigationChildren
     * @see AngularUseCase#getNavigationChildren()
     */
    protected Collection handleGetNavigationChildren()
    {
        return CollectionUtils.collect(getIncludes(), new Transformer()
        {
            public Object transform(Object object)
            {
                final IncludeFacade include = (IncludeFacade)object;
                return include.getAddition();
            }
        });
    }

    private static boolean isParent(final AngularUseCase useCase1, final AngularUseCase useCase2)
    {
        return CollectionUtils.exists(useCase2.getIncludes(), new Predicate()
        {
            public boolean evaluate(Object object)
            {
                final IncludeFacade include = (IncludeFacade)object;
                return include.getAddition().equals(useCase1);
            }
        });
    }

    /**
     * TODO: Model Documentation for
     * AngularUseCase.getNavigationParents
     * @see AngularUseCase#getNavigationParents()
     */
    protected Collection handleGetNavigationParents()
    {
        final AngularUseCase theUseCase = this;
        return CollectionUtils.select(getAllUseCases(),new Predicate() {
            @SuppressWarnings("synthetic-access")
            public boolean evaluate(Object o)
            {
                final AngularUseCase useCase = (AngularUseCase)o;
                if (theUseCase.equals(useCase))
                {
                    return false;
                }
                return isParent(theUseCase, useCase);
            }
        });
    }

    /**
     * TODO: Model Documentation for
     * AngularUseCase.getActionRoles
     * @see AngularUseCase#getActionRoles()
     */
    protected String handleGetActionRoles()
    {
        final StringBuilder rolesBuffer = new StringBuilder();
        boolean first = true;
        for (final Role role : this.getRoles())
        {
            if (first)
            {
                first = false;
            }
            else
            {
                rolesBuffer.append(',');
            }
            rolesBuffer.append(role.getName());
        }
        return rolesBuffer.toString();
    }

    /**
     * Represents a JSF use case.
     * @see AngularUseCase#getForwards()
     */
    protected List<AngularForward> handleGetForwards()
    {
        final Map<String, AngularForward> forwards = new LinkedHashMap<String, AngularForward>();
        for (final FrontEndAction action : this.getActions())
        {
            for (final FrontEndForward forward : action.getActionForwards())
            {
                if (forward instanceof AngularForward)
                {
                    forwards.put(forward.getName(), (AngularForward) forward);
                }
            }
        }
        return new ArrayList(forwards.values());
    }

    /**
     * Represents a JSF use case.
     * @see AngularUseCase#getActionForwards()
     */
    protected List<AngularAction> handleGetActionForwards()
    {
        final Set<AngularAction> actionForwards = new LinkedHashSet<AngularAction>();
        for (final FrontEndView view : this.getViews())
        {
            actionForwards.addAll(((AngularView)view).getActionForwards());
        }
        return new ArrayList<AngularAction>(actionForwards);
    }

    /**
     * Represents a JSF use case.
     * @see AngularUseCase#getAllViews()
     */
    protected Collection<FrontEndView> handleGetAllViews()
    {
        final Set<FrontEndView> allViews = new LinkedHashSet<FrontEndView>();
        for (final FrontEndUseCase useCase : this.getAllUseCases())
        {
            allViews.addAll(useCase.getViews());
        }
        return allViews;
    }

    /**
     * The use case to which the portlet preferences belongs.
     * @see AngularUseCase#getPreferences()
     */
    protected Object handleGetPreferences()
    {
        AngularPortletPreferences preferences = null;
        final Collection<DependencyFacade> dependencies = this.getSourceDependencies();
        if (dependencies != null && !dependencies.isEmpty())
        {
            for (final DependencyFacade dependency : dependencies)
            {
                final Object target = dependency.getTargetElement();
                if (dependency.getTargetElement() instanceof AngularPortletPreferences)
                {
                    preferences = (AngularPortletPreferences)target;
                    break;
                }
            }
        }
        return preferences;
    }

    /**
     * Represents a JSF use case.
     * @see AngularUseCase#getRegistrationUseCases()
     */
    protected List<FrontEndUseCase> handleGetRegistrationUseCases()
    {
        final List<FrontEndUseCase> useCases = new ArrayList<FrontEndUseCase>(this.getAllUseCases());
        for (final Iterator<FrontEndUseCase> iterator = useCases.iterator(); iterator.hasNext();)
        {
            final FrontEndUseCase useCase = iterator.next();
            if (useCase instanceof AngularUseCase)
            {
                if (!((AngularUseCase)useCase).isRegistrationUseCase())
                {
                    iterator.remove();
                }
            }
            else
            {
                iterator.remove();
            }
        }
        return useCases;
    }
}