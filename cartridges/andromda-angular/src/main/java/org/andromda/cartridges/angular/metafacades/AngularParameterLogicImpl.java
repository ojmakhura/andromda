// license-header java merge-point
//
// Generated by: MetafacadeLogicImpl.vsl in andromda-meta-cartridge.
package org.andromda.cartridges.angular.metafacades;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.andromda.cartridges.angular.AngularGlobals;
import org.andromda.cartridges.angular.AngularProfile;
import org.andromda.cartridges.angular.AngularUtils;
import org.andromda.metafacades.uml.AssociationEndFacade;
import org.andromda.metafacades.uml.AttributeFacade;
import org.andromda.metafacades.uml.ClassifierFacade;
import org.andromda.metafacades.uml.EntityAttribute;
import org.andromda.metafacades.uml.EventFacade;
import org.andromda.metafacades.uml.FrontEndAction;
import org.andromda.metafacades.uml.FrontEndActivityGraph;
import org.andromda.metafacades.uml.FrontEndController;
import org.andromda.metafacades.uml.FrontEndForward;
import org.andromda.metafacades.uml.FrontEndParameter;
import org.andromda.metafacades.uml.FrontEndView;
import org.andromda.metafacades.uml.ModelElementFacade;
import org.andromda.metafacades.uml.TransitionFacade;
import org.andromda.metafacades.uml.TypeMappings;
import org.andromda.metafacades.uml.UMLMetafacadeProperties;
import org.andromda.metafacades.uml.UMLMetafacadeUtils;
import org.andromda.metafacades.uml.UMLProfile;
import org.andromda.metafacades.uml.UseCaseFacade;
import org.andromda.utils.StringUtilsHelper;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.collections4.Predicate;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;

/**
 * Represents a parameter in a Angular front-end.
 * MetafacadeLogic implementation for org.andromda.cartridges.angular.metafacades.AngularParameter.
 *
 * @see org.andromda.cartridges.angular.metafacades.AngularParameter
 */
public class AngularParameterLogicImpl
    extends AngularParameterLogic
{
    private static final long serialVersionUID = 34L;
    /**
     * Public constructor for AngularParameterLogicImpl
     * @see org.andromda.cartridges.angular.metafacades.AngularParameter
     */
    public AngularParameterLogicImpl (Object metaObject, String context)
    {
        super(metaObject, context);
    }

    /**
     * Overridden to make sure it's not an inputTable.
     *
     * @see org.andromda.metafacades.uml.FrontEndParameter#isTable()
     */
    public boolean isTable()
    {
        return (super.isTable() || this.isPageableTable()) && !this.isSelectable()
            && !this.isInputTable() && !this.isInputHidden();
    }
    //TODO remove after 3.4 release
    /**
     * Hack to keep the compatibility with Andromda 3.4-SNAPSHOT
     */
    /**
     * @see org.andromda.metafacades.uml.FrontEndParameter#getView()
     */
    public FrontEndView getView()
    {
        Object view = null;
        final EventFacade event = this.getEvent();
        if (event != null)
        {
            final TransitionFacade transition = event.getTransition();
            if (transition instanceof FrontEndAction)
            {
                final FrontEndAction action = (FrontEndAction)transition;
                view = action.getInput();
            }
            else if (transition instanceof FrontEndForward)
            {
                final FrontEndForward forward = (FrontEndForward)transition;
                if (forward.isEnteringView())
                {
                    view = forward.getTarget();
                }
            }
        }
        return (FrontEndView)view;
    }

    /**
     * @param columnName
     * @return tableColumnActions
     * @see org.andromda.cartridges.angular.metafacades.AngularParameter#getTableColumnActions(String)
     */
    protected List<FrontEndAction> handleGetTableColumnActions(final String columnName)
    {
        final List<FrontEndAction> columnActions = new ArrayList<FrontEndAction>();

        if (columnName != null)
        {
            final Set<FrontEndAction> actions = new LinkedHashSet<FrontEndAction>(this.getTableHyperlinkActions());
            actions.addAll(this.getTableFormActions());
            for (final FrontEndAction action : actions)
            {
                if (columnName.equals(action.getTableLinkColumnName()))
                {
                    columnActions.add(action);
                }
            }
        }

        return columnActions;
    }

    /**
     * @return maxLength
     * @see org.andromda.cartridges.angular.metafacades.AngularParameter#getMaxLength()
     */
    protected String handleGetMaxLength()
    {
        final Collection<Collection> vars=getValidatorVars();
        if(vars == null)
        {
            return null;
        }
        for(Iterator<Collection> it=vars.iterator(); it.hasNext();)
        {
            final Object[] values=(it.next()).toArray();
            if("maxlength".equals(values[0]))
            {
                return values[1].toString();
            }
        }
        return null;
    }

    //to be used in the range validator: "range - 1000" or "range 20 -".
    /** - */
    static final String UNDEFINED_BOUND="-";
    /** jakarta.validation.constraints.NotNull */
    static final String AN_REQUIRED = "@jakarta.validation.constraints.NotNull";
    /** org.hibernate.validator.constraints.URL */
    static final String AN_URL = "@org.hibernate.validator.constraints.URL";
    /** org.apache.myfaces.extensions.validator.baseval.annotation.LongRange */
    static final String AN_LONG_RANGE = "@org.apache.myfaces.extensions.validator.baseval.annotation.LongRange";
    /** org.apache.myfaces.extensions.validator.baseval.annotation.DoubleRange */
    static final String AN_DOUBLE_RANGE = "@org.apache.myfaces.extensions.validator.baseval.annotation.DoubleRange";
    /** org.hibernate.validator.constraints.Email */
    static final String AN_EMAIL = "@org.hibernate.validator.constraints.Email";
    /** org.hibernate.validator.constraints.CreditCardNumber */
    static final String AN_CREDIT_CARD = "@org.hibernate.validator.constraints.CreditCardNumber";
    /** jakarta.validation.constraints.Size */
    static final String AN_LENGTH = "@jakarta.validation.constraints.Size";
    /** org.apache.myfaces.extensions.validator.baseval.annotation.Pattern */
    static final String AN_PATTERN = "@org.apache.myfaces.extensions.validator.baseval.annotation.Pattern";
    /** org.apache.myfaces.extensions.validator.crossval.annotation.Equals */
    static final String AN_EQUALS = "@org.apache.myfaces.extensions.validator.crossval.annotation.Equals";

    @Override
    protected Collection<ModelElementFacade> handleGetImports() {
        HashSet<ModelElementFacade> imports = new HashSet<>();

        for(AttributeFacade attribute : this.getType().getAttributes()) {
            if(attribute.getType().isEnumeration() || !attribute.getType().getAttributes().isEmpty()) {
                imports.add(attribute.getType());
            }
        }

        if(this.getAction() != null && this.getAction().getController() != null) {
            imports.add(this.getAction().getController());
        }

        if(this.getView() != null) {
            for(FrontEndParameter _var : this.getView().getVariables() ) {
                AngularParameter var = (AngularParameter) _var;
                if(var.isComplex()) {
                    imports.add(var.getType());
                }
            }
        }
        
        if(this.getType() instanceof AngularModel) {
            imports.add(this.getType());
        }
        
        imports.addAll(this.getRestControllers());

        return imports;
    }

    private String removeWhitespaceFromName(String name) {

        String original = StringUtilsHelper.upperCamelCaseName(name);
        original = original.replace(" ", "");

        return original;
    }

    @Override
    protected String handleGetAngularTypeName() {

        if(this.isInputFile() || this.getType().isBlobType()) {
            return "File";
        }

        if(UMLMetafacadeUtils.isNumber(getType())) {
            return this.isMany() ? "number[]" : "number";
        }

        String type = AngularUtils.getDatatype(this.getGetterSetterTypeName());

        return type;
    }

    @Override
    protected String handleGetFilePath() {
        AngularView view = (AngularView) this.getView();
        return view.getViewPath() + '/' + this.getFileName() + ".component";
    }

    @Override
    protected String handleGetFileName() {
        String viewPart = StringUtilsHelper.toPhrase(this.getView().getName()).toLowerCase();
        String name = StringUtilsHelper.toPhrase(this.getName()).toLowerCase();
        return viewPart.replace(" ", "-") + "-" + name.replace(" ", "-");
    }

    @Override
    protected String handleGetImplementationFileName() {
        return this.getFileName();
    }

    @Override
    protected String handleGetImplementationFilePath() {
        AngularView view = (AngularView) this.getView();
        return view.getViewPath() + '/' + this.getFileName() + "-impl.component";
    }

    @Override
    protected String handleGetTableComponentName() {
        if(!this.isTable()) {
            return null;
        }
        String viewName = this.removeWhitespaceFromName(this.getView().getName());
        String tableName = StringUtilsHelper.capitalize(this.getName());
        return viewName + tableName + "Component";
    }

    @Override
    protected String handleGetTableComponentImplementationName() {

        if(!this.isTable()) {
            return null;
        }

        String viewName = this.removeWhitespaceFromName(this.getView().getName());
        String tableName = StringUtilsHelper.capitalize(this.getName());
        return viewName + tableName + "ImplComponent";
    }

    @Override
    protected String handleGetTableSelectorName() {
        String phrase = StringUtilsHelper.toPhrase(this.getView().getName() + '-' + this.getName()).toLowerCase();
        return phrase.replace(" ", "-");
    }

    @Override
    protected Collection handleGetRestControllers() {
        HashSet<AngularService> services = new HashSet<>();

        if(this.getAction() != null && this.getAction().getController() != null) {
            services.addAll(((AngularController)this.getAction().getController()).getAllRestControllers());

            if(this.getTableActions() != null) {
                for(FrontEndAction action : this.getTableActions()) {

                    if(action.getController() != null) {
                        services.addAll(((AngularController)action.getController()).getAllRestControllers());
                    }
                }
            }
        }

        return services;
    }

    // @Override
    // public String getGetterSetterTypeName() {
    //     String name = null;
    //     if (this.getUpper() > 1 || this.getUpper() == -1)
    //     {
    //         final TypeMappings mappings = this.getLanguageMappings();
    //         //TODO: Create Implementation types for declared types, with mappings from declaration -> implementation
    //         // TODO: Fix Metafacade models to properly reflect Unique/Ordered in associations, and update Impl classes
    //         /*if (this.handleIsUnique())
    //         {
    //             name =
    //                 this.isOrdered() ? mappings.getTo(UMLProfile.ORDERED_SET_TYPE_NAME)
    //                                  : mappings.getTo(UMLProfile.SET_TYPE_NAME);
    //         }
    //         else
    //         {*/
    //             name =
    //                 this.isOrdered() ? mappings.getTo(UMLProfile.LIST_TYPE_NAME)
    //                                  : mappings.getTo(UMLProfile.COLLECTION_TYPE_NAME);
    //         /*}*/

    //         // set this attribute's type as a template parameter if required
    //         if (BooleanUtils.toBoolean(
    //                 ObjectUtils.toString(this.getConfiguredProperty(UMLMetafacadeProperties.ENABLE_TEMPLATING))))
    //         {
    //             String type = this.getType().getName();
    //             if (this.getType().isPrimitive() || this.getLower() > 0)
    //             {
    //                 // Can't template primitive values, Objects only. Convert to wrapped.
    //                 type = this.getType().getWrapperName();
    //                 if (type == null)
    //                 {
    //                     // No wrapper name configured
    //                     type = this.getType().getName();
    //                 }
    //             }
    //             // Allow List<Type[]> implementations.
    //             /*// Don't apply templating to modeled array types
    //             if (this.getType().isArrayType())
    //             {
    //                 type = type.substring(0, type.length()-2);
    //             }*/
    //             /*Collection<GeneralizableElementFacade> specializations = this.getType().getAllSpecializations();
    //             if ((specializations != null && !specializations.isEmpty()))
    //             {
    //                 name += "<? extends " + type + '>';
    //             }
    //             else
    //             {*/
    //                 name += '<' + type + '>';
    //             /*}*/
    //         }
    //     }
    //     if (name == null && this.getType() != null)
    //     {
    //         name = this.getType().getName();
    //         // Special case: lower bound overrides primitive/wrapped type declaration
    //         // TODO Apply to all primitive types, not just booleans. This is a special case because of is/get Getters.
    //         if (this.getType().isBooleanType())
    //         {
    //             // Datatypes will be inconsistent with multiplicity but identifier attributes shouldn't be changed automatically
    //             if (this.getType().isPrimitive() && this.getLower() < 1 &&
    //                 (!(this instanceof EntityAttribute) || !((EntityAttribute) this).isIdentifier()))
    //             {
    //                 // Type is optional, should not be primitive
    //                 name = this.getType().getWrapperName();
    //                 if (name == null)
    //                 {
    //                     // No wrapper name configured
    //                     name = this.getType().getName();
    //                 }
    //             }
    //             /*else //if (this.getType().isPrimitive())
    //             {
    //                 // Type is required, should not be wrapped
    //             }*/
    //         }
    //     }

    //     return name;
    // }    


    @Override
    public String getGetterSetterTypeName()
    {
        String name = super.getGetterSetterTypeName();

        if(name.contains("<")) {
            String tmp = name.substring(0, name.indexOf("<"));
            name = tmp + "<" + getLanguageMappings().getTo(getType().getName()) + ">";
        }

        if(name.contains(".")) {
            name = name.substring(name.lastIndexOf(".") + 1);
        }

        return name;
    }
}