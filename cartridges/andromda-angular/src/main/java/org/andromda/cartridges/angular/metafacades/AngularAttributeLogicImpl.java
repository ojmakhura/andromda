// license-header java merge-point
//
// Generated by: MetafacadeLogicImpl.vsl in andromda-meta-cartridge.
package org.andromda.cartridges.angular.metafacades;

import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;

import org.andromda.cartridges.angular.AngularGlobals;
import org.andromda.cartridges.angular.AngularHelper;
import org.andromda.cartridges.angular.AngularProfile;
import org.andromda.metafacades.uml.ClassifierFacade;
import org.andromda.metafacades.uml.FrontEndAction;
import org.andromda.metafacades.uml.FrontEndParameter;
import org.andromda.metafacades.uml.FrontEndView;
import org.andromda.metafacades.uml.ModelElementFacade;
import org.andromda.metafacades.uml.ParameterFacade;
import org.andromda.utils.StringUtilsHelper;
import org.apache.commons.lang3.StringUtils;

/**
 * Represents an attribute on a classifier used by a JSF application.
 * MetafacadeLogic implementation for org.andromda.cartridges.angular.metafacades.AngularAttribute.
 *
 * @see org.andromda.cartridges.angular.metafacades.AngularAttribute
 */
public class AngularAttributeLogicImpl
    extends AngularAttributeLogic
{
    private static final long serialVersionUID = 34L;
    /**
     * Public constructor for AngularAttributeLogicImpl
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute
     */
    public AngularAttributeLogicImpl (Object metaObject, String context)
    {
        super(metaObject, context);
    }

    /**
     * The message key for this attribute.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getMessageKey()
     */
    protected String handleGetMessageKey()
    {
        final StringBuilder messageKey = new StringBuilder();
        if (!this.isNormalizeMessages())
        {
            final ClassifierFacade owner = this.getOwner();
            if (owner != null)
            {
                messageKey.append(StringUtilsHelper.toResourceMessageKey(owner.getName()));
                messageKey.append('.');
            }
        }
        final String name = this.getName();
        if (name != null && name.trim().length() > 0)
        {
            messageKey.append(StringUtilsHelper.toResourceMessageKey(name));
        }
        return messageKey.toString();
    }

    /**
     * The default value for the message key.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getMessageValue()
     */
    protected String handleGetMessageValue()
    {
        return StringUtilsHelper.toPhrase(super.getName());
    }

    /**
     * Indicates whether or not we should normalize messages.
     *
     * @return true/false
     */
    private boolean isNormalizeMessages()
    {
        final String normalizeMessages =
            Objects.toString(this.getConfiguredProperty(AngularGlobals.NORMALIZE_MESSAGES));
        return Boolean.valueOf(normalizeMessages).booleanValue();
    }

    /**
     * The dummy value to give the attribute when creating a dummy instance of this attribute's
     * owner.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getDummyValue()
     */
    protected String handleGetDummyValue()
    {
        final ClassifierFacade type = this.getType();
        if (type != null)
        {
            final String typeName = AngularHelper.getDatatype(type.getFullyQualifiedName());
            final String name = AngularHelper.getDatatype(this.getName());
            if ("string".equals(typeName))
            {
                return "'" + name + "-test" + "'";
            }
            if ("Date".equals(typeName))
            {
                return "new Date()";
            }

            if ("number".equals(typeName))
            {
                return "0";
            }
            if ("boolean".equals(typeName))
            {
                return "false";
            }

            //if (type.isArrayType()) return constructDummyArray();
            if (type.isSetType())
            {
                return "[]";
            }
            if (type.isCollectionType())
            {
                return "[]";
            }

            // maps and others types will simply not be treated
        }
        return "null";
    }

    /**
     * If this attributes represents a date or time this method will return the format in which it
     * must be represented. In the event this format has not been specified by the any tagged value
     * the default will be used.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getFormat()
     */
    protected String handleGetFormat()
    {
        // return AngularHelper.getFormat(
        //     (ModelElementFacade)this.THIS(),
        //     this.getType(),
        //     this.getDefaultDateFormat(),
        //     this.getDefaultTimeFormat());
        return null;
    }

    /**
     * Indicates if this parameter represents as an input text area widget.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputTextarea()
     */
    protected boolean handleIsInputTextarea()
    {
        return this.isInputType(AngularGlobals.INPUT_TEXTAREA);
    }

    /**
     * Indicates whether or not this parameter should be rendered as a text input widget.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputText()
     */
    protected boolean handleIsInputText()
    {
        return this.isInputType(AngularGlobals.INPUT_TEXT);
    }

    /**
     * Indicates whether or not this parameter represents an input "secret" widget (i.e. password).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputSecret()
     */
    protected boolean handleIsInputSecret()
    {
        return this.isInputType(AngularGlobals.INPUT_PASSWORD);
    }

    /**
     * Indicates whether or not this parameter represents an input select widget.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputSelect()
     */
    protected boolean handleIsInputSelect()
    {
        return this.isInputType(AngularGlobals.INPUT_SELECT);
    }

    /**
     * Indicates whether or not this parameter should be rendered as an input radio widget.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputRadio()
     */
    protected boolean handleIsInputRadio()
    {
        return this.isInputType(AngularGlobals.INPUT_RADIO);
    }

    /**
     * Indicates whether or not this type represents an input multibox.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputMultibox()
     */
    protected boolean handleIsInputMultibox()
    {
        return this.isInputType(AngularGlobals.INPUT_MULTIBOX);
    }

    /**
     * Indicates whether or not this parameter represents a hidden input widget.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputHidden()
     */
    protected boolean handleIsInputHidden()
    {
        return this.isInputType(AngularGlobals.INPUT_HIDDEN);
    }

    /**
     * Indicates whether or not this is a file input type.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputFile()
     */
    protected boolean handleIsInputFile()
    {
        boolean file = false;
        ClassifierFacade type = getType();
        if (type != null)
        {
            file = type.isFileType();
        }
        return file;
    }

    /**
     * Indicates if this parameter represents a checkbox widget.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputCheckbox()
     */
    protected boolean handleIsInputCheckbox()
    {
        boolean checkbox = this.isInputType(AngularGlobals.INPUT_CHECKBOX);
        if (!checkbox && this.getInputType().length() == 0)
        {
            final ClassifierFacade type = this.getType();
            checkbox = type != null ? type.isBooleanType() : false;
        }
        return checkbox;
    }

    /**
     * Gets the current value of the specified input type (or an empty string
     * if one isn't specified).
     *
     * @return the input type name.
     */
    private String getInputType()
    {
        return Objects.toString(this.findTaggedValue(AngularProfile.TAGGEDVALUE_INPUT_TYPE)).trim();
    }
    /**
     * Indicates whether or not this parameter is of the given input type.
     *
     * @param inputType the name of the input type to check for.
     * @return true/false
     */
    private boolean isInputType(final String inputType)
    {
        return inputType.equalsIgnoreCase(this.getInputType());
    }

    /**
     * The dummy value for a value list.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getValueListDummyValue()
     */
    protected String handleGetValueListDummyValue()
    {
        return this.constructDummyArray();
    }

    /**
     * Constructs a string representing an array initialization in Java.
     *
     * @return A String representing Java code for the initialization of an array.
     */
    private String constructDummyArray()
    {
        return AngularHelper.constructDummyArrayDeclaration(
            this.getName(),
            AngularGlobals.DUMMY_ARRAY_COUNT);
    }

    /**
     * The validator's 'validwhen' value, this is useful when the validation of a parameter depends
     * on the validation of others. See the apache commons-validator documentation for more
     * information.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getValidWhen()
     */
    protected String handleGetValidWhen()
    {
        return AngularHelper.getValidWhen(this);
    }

    /**
     * All validator types for this attribute.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getValidatorTypes()
     */
    protected Collection handleGetValidatorTypes()
    {
        return AngularHelper.getValidatorTypes(
            (ModelElementFacade)this.THIS(),
            this.getType());
    }

    /**
     * Indicates whether or not this attribute requires some kind of validation (the collection of
     * validator types is not empty).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isValidationRequired()
     */
    protected boolean handleIsValidationRequired()
    {
        return !this.getValidatorTypes().isEmpty();
    }

    /**
     * Indicates where or not the date format is to be strictly respected. Otherwise the date
     * formatter used for the representation of this date is to be set to lenient.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isStrictDateFormat()
     */
    protected boolean handleIsStrictDateFormat()
    {
        //return AngularHelper.isStrictDateFormat((ModelElementFacade)this.THIS());
        // TODO put your implementation here.
        return false;
    }

    /**
     * Indicates whether or not this parameter uses the equal validator.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isEqualValidator()
     */
    protected boolean handleIsEqualValidator()
    {
        //final String equal = AngularHelper.getEqual((ModelElementFacade)this.THIS());
        //return equal != null && equal.trim().length() > 0;
        return false;
    }

    /**
     * Indicates whether or not this is an table input type.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputTable()
     */
    protected boolean handleIsInputTable()
    {
        return this.getInputTableIdentifierColumns().length() > 0 || this.isInputType(AngularGlobals.INPUT_TABLE);
    }

    /**
     * Indicates whether or not there is an input type defined for this attribute.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isInputTypePresent()
     */
    protected boolean handleIsInputTypePresent()
    {
        boolean present = false;
        final ClassifierFacade type = this.getType();
        if (type != null)
        {
            present =
                (StringUtils.isNotBlank(this.getInputType()) || type.isDateType() || type.isBooleanType()) &&
                !this.isPlaintext();
        }
        return present;
    }

    /**
     * Indicates whether or not this attribute's value should be rendered as plain text (not as a
     * widget).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isPlaintext()
     */
    protected boolean handleIsPlaintext()
    {
        return this.isInputType(AngularGlobals.PLAIN_TEXT);
    }

    /**
     * A comma separated list of the input table identifier columns (these are the columns that
     * uniquely define a row in an input table).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getInputTableIdentifierColumns()
     */
    protected String handleGetInputTableIdentifierColumns()
    {
        return Objects.toString(this.findTaggedValue(AngularProfile.TAGGEDVALUE_INPUT_TABLE_IDENTIFIER_COLUMNS)).trim();
    }

    /**
     * The max length allowed in the input component
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getMaxLength()
     */
    protected String handleGetMaxLength()
    {
        final Collection<List<String>> vars = this.getValidatorVars(null);
        if(vars == null)
        {
            return null;
        }
        for(final List<String> values : vars)
        {
            if("maxlength".equals(values.get(0)))
            {
                return values.get(1);
            }
        }
        return null;
    }

    /**
     * Retrieves the name of the form property for this attribute by taking the name of the owner
     * property.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getFormPropertyName(ParameterFacade)
     */
    protected String handleGetFormPropertyName(ParameterFacade ownerParameter)
    {
        final StringBuilder propertyName = new StringBuilder();
        if (ownerParameter != null)
        {
            propertyName.append(ownerParameter.getName());
            propertyName.append('.');
        }
        final String name = this.getName();
        if (name != null && name.trim().length() > 0)
        {
            propertyName.append(name);
        }
        return propertyName.toString();
    }

    /**
     * Gets the unique id of this attribute on the form.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getFormPropertyId(ParameterFacade)
     */
    protected String handleGetFormPropertyId(ParameterFacade ownerParameter)
    {
        return StringUtilsHelper.lowerCamelCaseName(this.getFormPropertyName(ownerParameter));
    }

    /**
     * Gets backing list name for this attribute. This is useful if you want to be able to select
     * the attribute value from a list (i.e. a drop-down select input type).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getBackingListName(ParameterFacade)
     */
    protected String handleGetBackingListName(ParameterFacade ownerParameter)
    {
        final String backingListName =
            StringUtils.replace(
                Objects.toString(this.getConfiguredProperty(AngularGlobals.BACKING_LIST_PATTERN)),
                "{0}",
                this.getFormPropertyId(ownerParameter));
        return StringUtilsHelper.lowerCamelCaseName(backingListName);
    }

    /**
     * Gets the name of the label list for this parameter. The label list name is the name of the
     * list storing the labels for the possible values of this attribute (typically used for the
     * labels of a drop-down select lists).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getLabelListName(ParameterFacade)
     */
    protected String handleGetLabelListName(ParameterFacade ownerParameter)
    {
        return StringUtils.replace(
            Objects.toString(this.getConfiguredProperty(AngularGlobals.LABEL_LIST_PATTERN)),
            "{0}",
            this.getFormPropertyId(ownerParameter));
    }

    /**
     * Gets the name of the value list for this parameter; this list stores the possible values that
     * this attribute may be (typically used for the values of a drop-down select list).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getValueListName(ParameterFacade)
     */
    protected String handleGetValueListName(ParameterFacade ownerParameter)
    {
        return StringUtils.replace(
            Objects.toString(this.getConfiguredProperty(AngularGlobals.VALUE_LIST_PATTERN)),
            "{0}",
            this.getFormPropertyId(ownerParameter));
    }

    /**
     * Indicates whether or not this attribute is selectable according to its 'ownerParameter'.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isSelectable(FrontEndParameter)
     */
    protected boolean handleIsSelectable(FrontEndParameter ownerParameter)
    {
        boolean selectable = false;
        if (ownerParameter != null)
        {
            if (ownerParameter.isActionParameter())
            {
                selectable = this.isInputMultibox() || this.isInputSelect() || this.isInputRadio();
                final ClassifierFacade type = this.getType();

                if (!selectable && type != null)
                {
                    final String name = this.getName();
                    final String typeName = type.getFullyQualifiedName();

                    // - if the parameter is not selectable but on a targeting page it IS selectable we must
                    //   allow the user to set the backing list too
                    final Collection<FrontEndView> views = ownerParameter.getAction().getTargetViews();
                    for (final Iterator<FrontEndView> iterator = views.iterator(); iterator.hasNext() && !selectable;)
                    {
                        final Collection<FrontEndParameter> parameters = iterator.next().getAllActionParameters();
                        for (final Iterator<FrontEndParameter> parameterIterator = parameters.iterator();
                            parameterIterator.hasNext() && !selectable;)
                        {
                            final FrontEndParameter object = parameterIterator.next();
                            if (object instanceof AngularParameter)
                            {
                                final AngularParameter parameter = (AngularParameter)object;
                                final String parameterName = parameter.getName();
                                final ClassifierFacade parameterType = parameter.getType();
                                if (parameterType != null)
                                {
                                    final String parameterTypeName = parameterType.getFullyQualifiedName();
                                    if (name.equals(parameterName) && typeName.equals(parameterTypeName))
                                    {
                                        selectable =
                                            parameter.isInputMultibox() || parameter.isInputSelect() ||
                                            parameter.isInputRadio();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (ownerParameter.isControllerOperationArgument())
            {
                final String name = this.getName();
                for (final FrontEndAction action : ownerParameter.getControllerOperation().getDeferringActions())
                {
                    final Collection<FrontEndParameter> formFields = action.getFormFields();
                    for (final Iterator<FrontEndParameter> fieldIterator = formFields.iterator(); fieldIterator.hasNext() && !selectable;)
                    {
                        final FrontEndParameter object = fieldIterator.next();
                        if (object instanceof AngularParameter)
                        {
                            final AngularParameter parameter = (AngularParameter)object;
                            if (name.equals(parameter.getName()))
                            {
                                selectable = parameter.isSelectable();
                            }
                        }
                    }
                }
            }
        }
        return selectable;
    }

    /**
     * Gets the arguments for this parameter's validators.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getValidatorArgs(String)
     */
    protected Collection handleGetValidatorArgs(String validatorType)
    {
        // return AngularHelper.getValidatorArgs(
        //     (ModelElementFacade)this.THIS(),
        //     validatorType);
        // TODO put your implementation here.
        return null;
    }

    /**
     * Gets the name of the date formatter for this attribute by constructing the name from the
     * 'ownerParameter' (if this attribute represents a date).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getDateFormatter(AngularParameter)
     */
    protected String handleGetDateFormatter(AngularParameter ownerParameter)
    {
        final ClassifierFacade type = this.getType();
        return type != null && type.isDateType() ? this.getFormPropertyId(ownerParameter) + "DateFormatter" : null;
    }

    /**
     * Gets the name of the time formatter (if this parameter represents a time).
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getTimeFormatter(AngularParameter)
     */
    protected String handleGetTimeFormatter(AngularParameter ownerParameter)
    {
        final ClassifierFacade type = this.getType();
        return type != null && type.isTimeType() ? this.getFormPropertyId(ownerParameter) + "TimeFormatter" : null;
    }

    /**
     * Constructs and returns the backing value name given the 'ownerParameter'.
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getBackingValueName(ParameterFacade)
     */
    protected String handleGetBackingValueName(ParameterFacade ownerParameter)
    {
        final String backingListName =
            StringUtils.replace(
                Objects.toString(this.getConfiguredProperty(AngularGlobals.BACKING_VALUE_PATTERN)),
                "{0}",
                this.getFormPropertyId(ownerParameter));
        return org.andromda.utils.StringUtilsHelper.lowerCamelCaseName(backingListName);
    }

    /**
     * Indicates whether or not the backing value is required for this attribute (depending on the
     * 'ownerParameter').
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#isBackingValueRequired(FrontEndParameter)
     */
    protected boolean handleIsBackingValueRequired(FrontEndParameter ownerParameter)
    {
        boolean required = false;
        if (ownerParameter != null)
        {
            if (ownerParameter.isActionParameter())
            {
                required = this.isInputTable();
                final ClassifierFacade type = this.getType();

                if (!required && type != null)
                {
                    final String name = this.getName();
                    final String typeName = type.getFullyQualifiedName();

                    // - if the parameter is not selectable but on a targetting page it IS selectable we must
                    //   allow the user to set the backing list too
                    final Collection<FrontEndView> views = ownerParameter.getAction().getTargetViews();
                    for (final Iterator<FrontEndView> iterator = views.iterator(); iterator.hasNext() && !required;)
                    {
                        final Collection<FrontEndParameter> parameters = iterator.next().getAllActionParameters();
                        for (final Iterator<FrontEndParameter> parameterIterator = parameters.iterator();
                            parameterIterator.hasNext() && !required;)
                        {
                            final FrontEndParameter object = parameterIterator.next();
                            if (object instanceof AngularParameter)
                            {
                                final AngularParameter parameter = (AngularParameter)object;
                                final String parameterName = parameter.getName();
                                final ClassifierFacade parameterType = parameter.getType();
                                if (parameterType != null)
                                {
                                    final String parameterTypeName = parameterType.getFullyQualifiedName();
                                    if (name.equals(parameterName) && typeName.equals(parameterTypeName))
                                    {
                                        required = parameter.isInputTable();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (ownerParameter.isControllerOperationArgument())
            {
                final String name = this.getName();
                final Collection<FrontEndAction> actions = ownerParameter.getControllerOperation().getDeferringActions();
                for (final Iterator<FrontEndAction> actionIterator = actions.iterator(); actionIterator.hasNext();)
                {
                    final AngularAction action = (AngularAction)actionIterator.next();
                    final Collection<FrontEndParameter> formFields = action.getFormFields();
                    for (final Iterator<FrontEndParameter> fieldIterator = formFields.iterator();
                        fieldIterator.hasNext() && !required;)
                    {
                        final FrontEndParameter object = fieldIterator.next();
                        if (object instanceof AngularParameter)
                        {
                            final AngularParameter parameter = (AngularParameter)object;
                            if (name.equals(parameter.getName()))
                            {
                                required = parameter.isBackingValueRequired();
                            }
                        }
                    }
                }
            }
        }
        return required;
    }

    /**
     * Gets the validator args for this attribute
     * @see org.andromda.cartridges.angular.metafacades.AngularAttribute#getValidatorVars(AngularParameter)
     */
    protected Collection handleGetValidatorVars(AngularParameter ownerParameter)
    {
        // return AngularHelper.getValidatorVars(
        //     (ModelElementFacade)this.THIS(),
        //     this.getType(),
        //     ownerParameter);
        return null;
    }
}