// Generated by andromda-angular cartridge (view\components\component.ts.vsl) DO NOT EDIT
import {
  AfterViewInit,
  Component,
  inject,
  Input,
  OnDestroy,
  OnInit,
  ViewChild,
} from "@angular/core";
import {COMMA, ENTER} from '@angular/cdk/keycodes';
import {
  FormsModule,
  ReactiveFormsModule,
  FormGroup,
  FormControl,
  FormBuilder,
  Validators,
  FormArray,
} from "@angular/forms";
import { SelectItem } from "@app/utils/select-item";
#if($component.treePresent)
import { CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl } from '@angular/cdk/tree';
import { MatTreeModule, MatTreeNestedDataSource } from '@angular/material/tree';
import { TreeOption } from '@app/model/tree-option.model';
import { AsTreeNodePipe } from '@app/pipe/tree-node.pipe';
import { DynamicTreeNode } from '@app/model/dynamic-tree-node.model';
import {CollectionViewer, SelectionChange, DataSource} from '@angular/cdk/collections';
#end
#if($component.tableVariablesPresent)
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
#end
import { MatSelectChange } from '@angular/material/select';
import { MatRadioChange } from '@angular/material/radio';
import { MatCheckboxChange } from '@angular/material/checkbox';
import { MatChip, MatChipInput, MatChipInputEvent } from "@angular/material/chips";
import {MatAutocompleteSelectedEvent, MatAutocompleteModule} from '@angular/material/autocomplete';
##if($targetModal)
import { MatDialog } from '@angular/material/dialog';
##end
import { firstValueFrom, Observable, map, of, startWith, Subscription } from "rxjs";
import { CommonModule } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { SharedModule } from '@app/@shared';
import { MaterialModule } from '@app/material.module';
import { CsvModule } from '@ctrl/ngx-csv';
#set($fields = [])
#set($buttons = [])
#foreach($import in $component.imports)
#if($metafacadeWebUtils.isComponent($import))
import { ${import.name} } from '@app/components/${import.filePath}';
#else
#if($import.attributes && $import.attributes.size() > 0 && !$import.enumeration)
#if($import.type)
#set ( $rt = $fields.add($import.type) )
#else
#set ( $rt = $fields.add($import) )
#end
#end
#if ($import.restCount>0 && $stringUtils.isNotBlank($import.restPath))
import { $import.name } from '@app/${import.filePath}';
#elseif(${import.hasStereotype("FrontEndComponent")})
import { $import.implementationName } from '@app/components/${import.implementationFilePath}';
#elseif($import.tableComponentImplementationName)
import { $import.tableComponentImplementationName } from '@app/${import.implementationFilePath}';
#elseif($import.componentImplementationName)
import { $import.componentImplementationName } from '@app/${import.implementationFilePath}';
#elseif(${import.implementationFilePath})
import { $import.implementationName } from '@app/${import.implementationFilePath}';
#else
import { $import.name } from '@app/${import.filePath}';
#end
#end
#end
import { SearchObject } from '@app/model/search-object';

@Component({
  selector: "app-${component.selectorName}-base",
  template: "",
})
export abstract class ${component.name} implements OnInit, OnDestroy, AfterViewInit {

    separatorKeysCodes: number[] = [ENTER, COMMA];
    @Input() ${component.beanName}Form: FormGroup;
#if($component.treePresent)
    protected readonly TreeOption = TreeOption;

#end

#foreach($attribute in $component.attributes)
#if(!$attribute.inputButton)
#if($attribute.tree)
    ${attribute.name}TreeControl: NestedTreeControl<DynamicTreeNode>;
    ${attribute.name}DataSource: MatTreeNestedDataSource<DynamicTreeNode>;
    ${attribute.name}Subscription?: Subscription;
#elseif($attribute.component)
    @ViewChild('${attribute.name}') ${attribute.name}: ${attribute.type.implementationName};
#else
    @Input() ${attribute.name}?: ${attribute.getterSetterTypeName};
#if($angularUtils.isComplex($attribute) && !$angularUtils.isTable($attribute))
#foreach($attr in $attribute.type.attributes)
#set ($propertyId = "${attribute.name}${stringUtils.capitalize($attr.name)}")
#if($attr.inputType == "image" || $attr.inputFile)
    ${propertyId}Preview#if($attr.many)s: any[]#{else}: any#end = #if($attr.many)[]#else''#end;
    ${propertyId}SelectedFile#if($attr.many)s#end?: #if($attr.many)FileList#{else}File#end;
#end
#if($attr.inputSelect || $attr.inputMultibox)
#if(!$attribute.type.enumeration)
    ${attribute.name}$stringUtils.capitalize(${attr.name})FilterCtrl: FormControl = new FormControl();
    filter${attribute.name}$stringUtils.capitalize(${attr.name})() {}
    ${attribute.name}$stringUtils.capitalize(${attr.name})Compare(o1: ${attr.getterSetterTypeName} | any, o2: ${attr.getterSetterTypeName} | any) {
        return false;
    }
#end
    ${attribute.name}$stringUtils.capitalize(${attr.name})BackingList: ${attr.type.name}[] = [];
    ${attribute.name}$stringUtils.capitalize(${attr.name})FilteredList$: Observable<${attr.type.name}[] | any[]>;
    ${attribute.name}$stringUtils.capitalize(${attr.name})ChipControl: FormControl = new FormControl([]);
    ${attribute.name}$stringUtils.capitalize(${attr.name})Displays: string[] = [
#if($attr.type.attributes.size() > 0)
        '$attr.type.attributes.get(0).name'
#end
    ];
#elseif($attr.type.attributes.size() > 0 && (!$attr.inputSelect || !$attr.inputMultibox))
#set ($propertyId = "${attribute.name}${stringUtils.capitalize($attr.name)}")
    @ViewChild('${propertyId}ModalPaginator', {static: true}) ${propertyId}ModalPaginator: MatPaginator;
    @ViewChild('${propertyId}ModalSort', {static: true}) ${propertyId}ModalSort: MatSort;

    $stringUtils.pluralize(${propertyId})$: Observable<${attr.getterSetterTypeName}>;
    ${propertyId}SearchField: FormControl = new FormControl([]);
    ${propertyId}Select: ${attr.getterSetterTypeName}#if($attr.many || $attr.type.collectionType)[] = []#else = new  ${attr.getterSetterTypeName}()#end;

    $stringUtils.pluralize(${propertyId})DataSource = new MatTableDataSource<${attr.getterSetterTypeName}>([]);

    ${propertyId}ModalColumns = [
        'actions',
#foreach ($column in $attr.tableColumnNames)
#if($column.name)
#set($columnName = $column.name)
#else
#set($columnName = $column)
#end
        '$columnName',
#end
    ];
#end
#end
#end
#end
#if($attribute.inputSelect || $attribute.inputMultibox || $attribute.type.enumeration)
#if($attribute.type.enumeration)
    ${attribute.name}T: any = $attribute.getterSetterTypeName;
    ${attribute.name}Options = Object.keys(this.${attribute.name}T);
#else
    ${attribute.name}FilterCtrl: FormControl = new FormControl();
    ${attribute.name}Compare(o1: ${attribute.getterSetterTypeName} | any, o2: ${attribute.getterSetterTypeName} | any) {
        return false;
    }
    filter$stringUtils.capitalize(${attribute.name})() {}
    ${attribute.name}BackingList: ${attribute.getterSetterTypeName}[] = [];
    ${attribute.name}FilteredList$: Observable<${attribute.getterSetterTypeName}[] | any[]> = of([]);
    ${attribute.name}ChipControl: FormControl = new FormControl([]);
    ${attribute.name}Displays: string[] = [
#if($attribute.type.attributes.size() > 0)
        '$attribute.type.attributes.get(0).name'
#end
    ];
#end
#end
#end

#if($angularUtils.isTable($attribute) && !$attribute.component)
#set ($proId = "$attribute.name")
#set ($cols = "")
    ${proId}Columns = [
#foreach ($column in $attribute.tableColumnNames)
#if($column.name)
#set($columnName = $column.name)
#else
#set($columnName = $column)
#end
        '$columnName',
#end
    ];

    ${proId}ModalColumns = [
        'actions',
        ...this.${proId}Columns
    ];

    @ViewChild('${proId}Paginator', {static: true}) ${proId}Paginator: MatPaginator;
    @ViewChild('${proId}Sort', {static: true}) ${proId}Sort: MatSort;

    @ViewChild('${proId}ModalPaginator', {static: true}) ${proId}ModalPaginator: MatPaginator;
    @ViewChild('${proId}ModalSort', {static: true}) ${proId}ModalSort: MatSort;

    $stringUtils.pluralize(${proId})$: Observable<${attribute.getterSetterTypeName}[]>;
    $stringUtils.pluralize(${proId})DataSource = new MatTableDataSource<${attribute.getterSetterTypeName}>([]);
    ${proId}SearchField: FormControl = new FormControl([]);
    ${proId}Select: ${attribute.getterSetterTypeName}#if($attribute.many || $attribute.type.collectionType)[] = []#else = {}#end;
#end
#if($attribute.inputType == "image" || $attribute.inputFile)
    ${attribute.name}Preview#if($attribute.many)s: any[]#{else}: any#end = #if($attribute.many)[]#else''#end;
    ${attribute.name}SelectedFile#if($attribute.many)s#end?: #if($attribute.many)FileList#{else}File#end;
#end
#end

    private formBuilder = inject(FormBuilder);
    constructor(
    ) {
#foreach($attribute in $component.attributes)
#set ($propertyId = $attribute.name)
#if($attribute.tree)
    this.${attribute.name}TreeControl = new NestedTreeControl<DynamicTreeNode>(
      (node) => node.children
    );
    this.${attribute.name}DataSource = new MatTreeNestedDataSource<DynamicTreeNode>();

#elseif($attr.inputMultibox && !$attribute.component)

        this.${propertyId}FilteredList$ = this.${propertyId}ChipControl.valueChanges.pipe(
            startWith(null),
            map((value: string | null) => (value ? this._${propertyId}Filter(value) : this.${propertyId}BackingList.slice())),
        );
#elseif(!$angularUtils.isSimpleType($attribute.type) && !$attribute.component)
#foreach($attr in $attribute.type.attributes)
#set($attrPropertyId = "${propertyId}$stringUtils.capitalize(${attr.name})")
#if($attr.inputMultibox && !$attr.component)

        this.${attrPropertyId}FilteredList$ = this.${attrPropertyId}ChipControl.valueChanges.pipe(
            startWith(null),
            map((fruit: string | null) => (fruit ? this._${attrPropertyId}Filter(fruit) : this.${attrPropertyId}BackingList.slice())),
        );
#end
#end
#end
#end
    }

    #if($component.treePresent)async #{end}ngOnInit() {
        if(!this.${component.beanName}Form) {
            this.initForm();
        }
#foreach($attribute in $component.attributes)
#if($attribute.tree)
        
        await this.load${stringUtils.capitalize($attribute.name)}RootNodes();

#end
#end
    }

    ngOnDestroy() {}

    ngAfterViewInit() {

    }

    initForm() {
        this.${component.beanName}Form = this.formBuilder.group({
#foreach($attribute in $component.attributes)
#if(!$attribute.inputButton && !$attribute.component && !$attribute.tree)
#if($angularUtils.isTable($attribute) || $attribute.many || $attribute.type.collectionType)
#if($angularUtils.isSimpleType($attribute.type))
            $attribute.name: this.formBuilder.array(this.${attribute.name} ? this.${attribute.name} : []),
#else
            $attribute.name: this.create${attribute.type.name}Array(this.${attribute.name}),
#end
#elseif(!$angularUtils.isSimpleType($attribute.type))
            $attribute.name: this.create${attribute.type.name}Group(this.${attribute.name}),
#else
#set ($validators = "")
#if($attribute.required || $attribute.inputEmail || $attribute.minLength || $attribute.maxLength || $attribute.min || $attribute.max)
#set ($validators = ", [")
#if($attribute.required)
#set ($validators = "${validators}Validators.required, ")
#end
#if($attribute.inputEmail)
#set ($validators = "${validators}Validators.email, ")
#end
#if($attribute.minLength)
#set ($validators = "${validators}Validators.minLength($attribute.minLength), ")
#end
#if($attribute.maxLength)
#set ($validators = "${validators}Validators.maxLength($attribute.maxLength), ")
#end
#if($attribute.min)
#set ($validators = "${validators}Validators.min($attribute.min), ")
#end
#if($attribute.max)
#set ($validators = "${validators}Validators.max($attribute.max), ")
#end
#set ($validators = "$validators]")
#end
#set ($val = "${component.beanName}.${attribute.name}")
            $attribute.name: [{value: this.${attribute.name}, disabled: false}$validators],
#end
#end
#end
        });
    }

#set($fieldSet = $angularUtils.getFacadeSet($fields))
#foreach($field in $fieldSet)
#if(!$field.inputButton)
#if($field.type)
#set ($typeName = "$field.getterSetterTypeName")
#else
#set ($typeName = "$field.name")
#end

    create${typeName}Group(value?: $typeName): FormGroup {
        return this.formBuilder.group({
#if($field.generalization)
#foreach($attribute in $field.generalization.attributes)
#if(!$attribute.inputButton)
#if($angularUtils.isSimpleType($attribute))
            $attribute.name: [value?.$attribute.name],
#end
#end
#end
#end
#foreach($attribute in $field.attributes)
#if($angularUtils.isSimpleType($attribute))
            $attribute.name: [value?.$attribute.name],
#end
#end
        });
    }

    create${typeName}Array(values?: $typeName[]): FormArray {
        if(values) {
            let formArray: FormArray = this.formBuilder.array([]);
            values?.forEach(value => formArray.push(this.create${typeName}Group(value)))

            return formArray;
        } else {
            return new FormArray([] as any);
        }
    }

#end
#end

#foreach($attribute in $component.attributes)
#if(!$attribute.inputButton && !$attribute.component)
#if($attribute.tree)
    handleLoad${stringUtils.capitalize($attribute.name)}RootNodes(): Observable<any> {}

    load${stringUtils.capitalize($attribute.name)}RootNodes() {
        let rootNodes = await firstValueFrom(
            this.handleLoad${stringUtils.capitalize($attribute.name)}RootNodes()
        );
        this.${attribute.name}DataSource.data = rootNodes.map((x) => new DynamicTreeNode(0, x));

        this.${attribute.name}Subscription = this.${attribute.name}TreeControl.expansionModel.changed.subscribe(
            (change) => {
                if (change.added || change.removed) {
                    this.handle${stringUtils.capitalize($attribute.name)}TreeControl(change);
                }
            }
        );
    }

    // TODO: more methods
    private handle${stringUtils.capitalize($attribute.name)}TreeControl(change: SelectionChange<DynamicTreeNode>) {
        if (change.added) {
            change.added.forEach((x) => this.toggle${stringUtils.capitalize($attribute.name)}Node(x, true));
        }
        if (change.removed) {
        change.removed
            .slice()
            .reverse()
            .forEach((x) => this.toggle${stringUtils.capitalize($attribute.name)}Node(x, false));
        }
    }

  // Should be modified to load child nodes
  protected handleLoad${stringUtils.capitalize($attribute.name)}ChildNodes(node: DynamicTreeNode): Observable<any> {
    
    return of([]);
  }

  private async toggle${stringUtils.capitalize($attribute.name)}Node(node: DynamicTreeNode, expand: boolean) {
    // If the node is asking to be expanded...
    if (expand) {
      // And the node hasn't already had its children loaded...
      if (node.children.value.length == 0) {
        // Set the loading indicator to true
        node.loading.set(true);
        // Retrieve the new nodes from the server
        let children = await firstValueFrom(
          this.handleLoad${stringUtils.capitalize($attribute.name)}ChildNodes(node)
        );
        // Convert them to our DynamicTreeNode
        let nodes = children.map(
          (x, index) => new DynamicTreeNode(node.level + 1, x, node)
        );
        // Set the last node on the set to have the "last node" property, so the "load more" button is shown
        console.log(nodes)
        nodes[nodes.length - 1].options.update((x) => x.add(TreeOption.Last));
        // Send the updated nodes into the BehaviourSubject
        node.children.next(nodes);
        // Set the loading indicator to false
        node.loading.set(false);
      }
    }
  }

  // Should be modified to suit context
  protected handleLoadMore${stringUtils.capitalize($attribute.name)}(node: DynamicTreeNode): Observable<any> {
    return of([]);

  }

  async loadMore${stringUtils.capitalize($attribute.name)}(node: DynamicTreeNode) {

    // Set the loading indicator to true for the node
    node.loading.set(true);
    // Retrieve the next set of nodes from the server
    let childData = await firstValueFrom(
      this.handleLoadMore${stringUtils.capitalize($attribute.name)}(node)
    );
    // Convert them to DynamicTreeNode. Set the parent of the new nodes (not this node, this nodes parent)
    let childNodes = childData.map(
      (x) => new DynamicTreeNode(node.level, x, node.parent)
    );
    // Retrieve the existing children array
    let existingChildren = node.parent?.children.value;
    if (existingChildren) {
      // Remove any "last node" option from existing nodes in this array
      existingChildren.forEach((x) =>
        x.options.update((y) => {
          y.delete(TreeOption.Last);
          return y;
        })
      );

      // Build the new array from the old nodes, and the new nodes we just received
      let newChildArray = [...existingChildren, ...childNodes];
      // Set the new data of the parent, and notify the tree that the nodes have updated
      node.parent?.children.next(newChildArray);
    }
    // Set the loading indicator back to false
    node.loading.set(false);
  }

  // Should be modified to suit context
  track${stringUtils.capitalize($attribute.name)}By(_: number, node: DynamicTreeNode) {
    return ``;
  }

#elseif($angularUtils.isTable($attribute) || $attribute.many || $attribute.type.collectionType)
#set ($controlType = "FormArray")
#elseif($angularUtils.isComplex($attribute) && !$attribute.component)
#set ($controlType = "FormGroup")
#else
#set ($controlType = "FormControl")
#end
#set ($propertyId = $attribute.name)    
    get ${propertyId}Control(): $controlType {
        return this.${component.beanName}Form?.get('$attribute.name') as $controlType;
    }

#if($attribute.inputMultibox)
    ${propertyId}Remove(i: number){
        this.${propertyId}Control?.removeAt(i);
    }

    ${propertyId}Add(event: MatChipInputEvent){
        this.${propertyId}Control.push(new FormControl());
    }
    
    ${propertyId}Selected(event: MatAutocompleteSelectedEvent): void {
    }

#end
#if($angularUtils.isComplex($attr) && !$attribute.type.enumeration && !$attribute.many)
    ${propertyId}AddDialog(){}

    ${propertyId}Clear(){}

#end

#if(!$angularUtils.isSimpleType($attribute.type))
#foreach($attr in $attribute.type.attributes)
#if($angularUtils.isTable($attr) || $attr.many || $attr.type.collectionType)
#set ($attrControlType = "FormArray")
#elseif($angularUtils.isComplex($attr) && !$attr.component)
#set ($attrControlType = "FormGroup")
#else
#set ($attrControlType = "FormControl")
#end
#set($attrPropertyId = "${propertyId}$stringUtils.capitalize(${attr.name})")
    get ${attrPropertyId}Control(): $attrControlType {
        return this.${propertyId}Control?.get('$attr.name') as $attrControlType;
    }

#if($attr.inputMultibox)
    ${attrPropertyId}Remove(index: number){

        if (index >= 0) {
            this.${attrPropertyId}Control.removeAt(index);
        }
    }

    ${attrPropertyId}Add(event: MatChipInputEvent){
        this.${attrPropertyId}Control.push(new FormControl([event.value]));
        event.chipInput!.clear();
    }
    
    ${attrPropertyId}Selected(event: MatAutocompleteSelectedEvent): void {
        this.${attrPropertyId}Control.push(new FormControl([event.option.value]));
        this.${attrPropertyId}ChipControl.setValue(null);
    }

    private _${attrPropertyId}Filter(value: string): SelectItem[] {
        const filterValue = value.toLowerCase();
    
        return this.${attrPropertyId}BackingList.filter(item => item.label.toLowerCase().includes(filterValue));
    }

#end
#if($angularUtils.isComplex($attr) && !$attr.type.enumeration && !$attr.many)
    ${attrPropertyId}AddDialog(){}

    ${attrPropertyId}Clear(){}

    ${attrPropertyId}Selected(event: MatCheckboxChange, row: number){}

    ${attrPropertyId}Search(){}

    addSelected$stringUtils.capitalize(${attrPropertyId})(){}

#end
#if($attr.inputType == "image" || $attr.inputFile)
#set ($deleteFunc = "deleteFromSelected$stringUtils.capitalize(${attrPropertyId})(#if($attr.many)index: number#end)")
#if($attr.inputType == "image")
#if($attr.many)
    private reloadSelected$stringUtils.capitalize(${attrPropertyId})(files: File[]) {
        this.${attrPropertyId}Previews = [];
        if (files && files.length > 0) {
            const numberOfFiles = files.length;
            for (let i = 0; i < numberOfFiles; i++) {
                const reader = new FileReader();
    
                reader.onload = (e: any) => {
                    this.${attrPropertyId}Previews.push(e.target.result);
                };
    
                reader.readAsDataURL(files[i]);
            }
        }

    }

#end
#set( $displayName = "${attrPropertyId}Previews#if($attr.many)s#end")
#set ($item = "preview")
#else
#set( $displayName = "${attrPropertyId}Control.value")
#set ($item = "file")
#end
    $deleteFunc {
#if($attr.many)
        this.${attrPropertyId}Control.removeAt(index);
#if($attr.inputType == "image")
        this.${attrPropertyId}Previews.splice(index, 1);
        this.reloadSelected$stringUtils.capitalize(${attrPropertyId})(this.${attrPropertyId}Control.value);
#end
#else
        this.${attrPropertyId}Control.setValue(null);
#if($attr.inputType == "image")
        this.${attrPropertyId}Preview = null;
#end
#end
    }

#if($attr.many)
    ${attrPropertyId}SelectFiles(event: any): void {
        this.${attrPropertyId}SelectedFiles = event.target.files;
  
#if($attr.inputType == "image")
        this.${attrPropertyId}Previews = [];
#end
        if (this.${attrPropertyId}SelectedFiles && this.${attrPropertyId}SelectedFiles[0]) {
            const numberOfFiles = this.${attrPropertyId}SelectedFiles.length;
            for (let i = 0; i < numberOfFiles; i++) {
#if($attr.inputType == "image")
                const reader = new FileReader();
  
                reader.onload = (e: any) => {
                    console.log(e.target.result);
                    this.${attrPropertyId}Previews.push(e.target.result);
                };
  
                reader.readAsDataURL(this.${attrPropertyId}SelectedFiles[i]);
#end
                this.${attrPropertyId}Control.push(this.formBuilder.control(this.${attrPropertyId}SelectedFiles[i]));
            }
        }
    }

#else
    ${attrPropertyId}SelectFile(event: any): void {

        for (let i = 0; i < event.target.files.length; i++) {
            const file = event.target.files[i];

#if($attr.inputType == "image")
            var reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = (_event) => {
                this.${attrPropertyId}Preview.push(reader.result);
            };
#end

            this.${attrPropertyId}Control.setValue(file);
        }
    }

#end
#end
#end
#end
#elseif($attribute.inputButton)
    on${stringUtils.capitalize(${attribute.name})}Click() {
    }

#end
#if($attribute.inputType == "image" || $attribute.inputFile)
#set ($deleteFunc = "deleteFromSelected$stringUtils.capitalize(${propertyId})(#if($attribute.many)index: number#end)")
#if($attribute.inputType == "image")
#if($attribute.many)
    private reloadSelected$stringUtils.capitalize(${propertyId})(files: File[]) {
        this.${propertyId}Previews = [];
        if (files && files.length > 0) {
            const numberOfFiles = files.length;
            for (let i = 0; i < numberOfFiles; i++) {
                const reader = new FileReader();
    
                reader.onload = (e: any) => {
                    this.${propertyId}Previews.push(e.target.result);
                };
    
                reader.readAsDataURL(files[i]);
            }
        }

    }

#end
#set( $displayName = "${propertyId}Previews#if($attribute.many)s#end")
#set ($item = "preview")
#else
#set( $displayName = "${propertyId}Control.value")
#set ($item = "file")
#end
    $deleteFunc {
#if($attribute.many)
        this.${propertyId}Control.removeAt(index);
#if($attribute.inputType == "image")
        this.${propertyId}Previews.splice(index, 1);
        this.reloadSelected$stringUtils.capitalize(${propertyId})(this.${propertyId}Control.value);
#end
#else
        this.${propertyId}Control.setValue(null);
        this.${propertyId}Preview = null;
#end
    }
    
#if($attribute.many)
    ${propertyId}SelectFiles(event: any): void {
        this.${propertyId}SelectedFiles = event.target.files;
#if($attribute.inputType == "image")
        this.${propertyId}Previews = [];
#end
        if (this.${propertyId}SelectedFiles && this.${propertyId}SelectedFiles[0]) {
            const numberOfFiles = this.${propertyId}SelectedFiles.length;
            for (let i = 0; i < numberOfFiles; i++) {
#if($attribute.inputType == "image")
                const reader = new FileReader();
    
                reader.onload = (e: any) => {
                    this.${propertyId}Previews.push(e.target.result);
                };
    
                reader.readAsDataURL(this.${propertyId}SelectedFiles[i]);
#end
                this.${propertyId}Control.push(this.formBuilder.control(this.${propertyId}SelectedFiles[i]));
            }
        }
    }

#else
    ${propertyId}SelectFile(event: any): void {

        for (let i = 0; i < event.target.files.length; i++) {
            const file = event.target.files[i];

#if($attribute.inputType == "image")
            var reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = (_event) => {
                this.${propertyId}Preview = reader.result;
            };
#end
            this.${propertyId}Control.setValue(file);
        }
    }

#end
#end
#end
}