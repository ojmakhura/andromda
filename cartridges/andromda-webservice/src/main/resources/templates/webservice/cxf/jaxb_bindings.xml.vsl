#if ($umlUtils.shouldOutput($service))
<?xml version="1.0" encoding="UTF-8"?>
##<bindings jxb:version=#if ($cxfVersion.startsWith("2.0"))"2.0"#else"2.1"#end
#set ($cxf21=$cxfVersion.substring(0,3).compareTo("2.1")>0)
<bindings jxb:extensionBindingPrefixes="xjc"
    wsdlLocation="../${service.name}.wsdl"
    xmlns="http://java.sun.com/xml/ns/jaxws"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
    xmlns:jxb="http://java.sun.com/xml/ns/jaxb"
    xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
    xmlns:jaxws="http://java.sun.com/xml/ns/jaxws"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    targetNamespace="http://java.sun.com/xml/ns/jaxws"
    xsi:schemaLocation="http://java.sun.com/xml/ns/jaxws http://java.sun.com/xml/ns/jaxws/wsdl_customizationschema_2_0.xsd
    http://java.sun.com/xml/ns/jaxb http://java.sun.com/xml/ns/jaxb/bindingschema_2_0.xsd">
    <!-- Generated by andromda-webservice cartridge (cxf/jaxb_bindings.xml.vsl) on $webServiceUtils.date DO NOT EDIT! -->
    <!-- Disable wrapped operation inputs/outputs: Allows unwrapped methods in service implementation -->
    <!-- WSDL operations are still wrapped in request/response -->
    <!-- Change the Service Endpoint Interface class name from the default <Service>.java to <Service>${seiSuffix}.java -->
## Using a variable for single quote is ugly, but it's the easiest way to provide those literals inside quoted strings
#set ($q="'")
    <bindings node="wsdl:definitions/wsdl:portType">
        <class name="${service.name}${seiSuffix}"/>
    </bindings>
    <!-- Change the Endpoint Impl class name from the default <Service>PortTypeImpl.java to <Service>${seiSuffix}Client -->
    <bindings node="wsdl:definitions/wsdl:service[@name = $q${service.name}$q]">
       <class name="${service.name}${seiSuffix}Client"/>
    </bindings>
#foreach ($operation in $service.allowedOperations)
#if (!$operation.rest)
##    <!-- $service.packageName $operation.packageName $operation.name $service -->
#foreach($exception in $operation.exceptions)
## Assumes the exception is called 'Exception' or Fault
#set ($faultName=$exception.name.replace("Exception", "Fault"))
    <!-- change the generated exception class package from default service package $service.packageName-->
    <bindings node="wsdl:definitions/wsdl:portType[@name=$q${service.qName}$q]/wsdl:operation[@name=$q$operation.operationName$q]/wsdl:fault[@name=$q$faultName$q]">
#if (!$exception.packageName.equals($service.packageName))
        <package name="$exception.packageName"/>
#end
        <!-- Avoid Exception_Exception class in code created from wsdl Exception -->
        <class name="$exception.name"/>
    </bindings>
#end
#if (!$operation.operationName.equals($operation.name))
    <!-- change the generated exception class package from default service package $service.packageName-->
    <bindings node="wsdl:definitions/wsdl:portType[@name=$q${service.qName}$q]/wsdl:operation[@name=$q$operation.operationName$q]">
        <!-- Implmented service operation name is different from exposed operation name -->
        <method name="$operation.name"/>
    </bindings>
#end
#end
#end
    <bindings node="wsdl:definitions/wsdl:types/xs:schema[1]">
      <!-- Preserve underscore instead of using it as a word break in class/attribute/literal names -->
      <!-- Generate IsSet methods for optional elements -->
#if (!$cxf21)
      <!-- CXF 2.1 will not work unless jxb:extensionBindingPrefixes declared here. Causes an error with RAD 7.5. -->
#end
      <jxb:globalBindings#if ($cxf21) jxb:extensionBindingPrefixes="xjc" xmlns:jxb="http://java.sun.com/xml/ns/jaxb" xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"#end

      choiceContentProperty="false" collectionType="java.util.ArrayList" underscoreBinding="asWordSeparator"
        enableJavaNamingConventions="true" generateIsSetMethod="false"#if (!$cxf21) generateElementProperty="false"#end>
        <!-- Add implements Serializable with SerialVersionUID=1L-->
        <jxb:serializable uid="1"/>
#if (!$cxf21)
        <!-- Bug in CXF 2.0.x: bindings are not allowing any xjc: elements. -->
#elseif ($simpleBindingMode && ($pluralizeAssociationEndNames || $pluralizeAttributeNames || $pluralizeParameterNames))
        <!-- XJC binding extension with simple binding, which prevents most object name collisions by assuming type is uniquely used -->
        <xjc:simple/>
#end
        <!-- Change the xs:date databinding from the default XMLGregorianCalendar. Creates org.w3._2001.xmlschema.Adapter1 class -->
        <!-- Default XJC binding is XMLGregorianCalendar, must match java cartridge mapping -->
        <!-- Date=$webServiceUtils.getTypeMapping($service.languageMappings, "Date") Time=$webServiceUtils.getTypeMapping($service.languageMappings, "Time") DateTime=$webServiceUtils.getTypeMapping($service.languageMappings, "DateTime") Integer=$webServiceUtils.getTypeMapping($service.languageMappings, "Integer") Decimal=$webServiceUtils.getTypeMapping($service.languageMappings, "Decimal") -->
        <!-- See http://cxf.apache.org/docs/wsdl-to-java.html -->
#set ($dateMapping = $webServiceUtils.getTypeMapping($service.languageMappings, "Date"))
#if ($stringUtils.isBlank($XMLDateAdapter))
#if ($dateMapping.equals("java.util.Date"))
        <jxb:javaType xmlType="xs:date" name="java.util.Date"
                      parseMethod="org.apache.cxf.xjc.runtime.DataTypeAdapter.parseDateTime"
                      printMethod="org.apache.cxf.xjc.runtime.DataTypeAdapter.printDateTime"/>
#elseif ($dateMapping.equals("java.util.Calendar"))
        <jxb:javaType xmlType="xs:date" name="java.util.Calendar"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseDateTime"
                      printMethod="javax.xml.bind.DatatypeConverter.printDateTime"/>
#end
#else
#if ($dateMapping.equals("java.util.Date"))
#if (!$cxf21)
        <!-- Requires custom developed datatype bindings for both print and parse methods -->
        <!--jxb:javaType xmlType="xs:date" name="java.util.Date"
                      parseMethod="com.xxx.DatatypeConverter.parseXsDate"
                      printMethod="com.xxx.DatatypeConverter.printXsDate"/-->
#else
        <xjc:javaType xmlType="xs:date" name="java.util.Date" adapter="$XMLDateAdapter"/>
#end
#elseif ($dateMapping.equals("java.util.Calendar"))
#if (!$cxf21)
        <jxb:javaType xmlType="xs:date" name="java.util.Calendar"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseDate"
                      printMethod="javax.xml.bind.DatatypeConverter.printDate"/>
#else
        <xjc:javaType xmlType="xs:date" name="java.util.Calendar" adapter="$XMLDateAdapter"/>
#end
#else
        <xjc:javaType xmlType="xs:date" name="$dateMapping" adapter="$XMLDateAdapter"/>
#end
#end
#set ($timeMapping = $webServiceUtils.getTypeMapping($service.languageMappings, "Time"))
#if ($stringUtils.isBlank($XMLTimeAdapter))
#if ($timeMapping.equals("java.util.Date"))
        <jxb:javaType xmlType="xs:time" name="java.util.Date"
                      parseMethod="org.apache.cxf.xjc.runtime.DataTypeAdapter.parseTime"
                      printMethod="org.apache.cxf.xjc.runtime.DataTypeAdapter.printTime"/>
#elseif ($timeMapping.equals("java.util.Calendar"))
        <jxb:javaType xmlType="xs:time" name="java.util.Calendar"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseTime"
                      printMethod="javax.xml.bind.DatatypeConverter.printTime"/>
#end
#else
#if ($timeMapping.equals("java.util.Date"))
#if (!$cxf21)
        <!-- Requires custom developed datatype bindings -->
        <!--jxb:javaType xmlType="xs:time" name="java.util.Date"
                      parseMethod="com.xxx.DatatypeConverter.parseXsTime"
                      printMethod="com.xxx.DatatypeConverter.printXsTime"/-->
#else
        <xjc:javaType xmlType="xs:time" name="java.util.Date" adapter="$XMLTimeAdapter"/>
#end
#elseif ($timeMapping.equals("java.util.Calendar"))
#if (!$cxf21)
        <xjc:javaType xmlType="xs:time" name="java.util.Calendar"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseTime"
                      printMethod="javax.xml.bind.DatatypeConverter.printTime"/>
#else
        <xjc:javaType xmlType="xs:time" name="java.util.Calendar" adapter="$XMLTimeAdapter"/>
#end
#else
        <xjc:javaType xmlType="xs:time" name="$timeMapping" adapter="$XMLTimeAdapter"/>
#end
#end
#set ($datetimeMapping = $webServiceUtils.getTypeMapping($service.languageMappings, "DateTime"))
#if ($stringUtils.isBlank($XMLDateTimeAdapter))
#if ($datetimeMapping.equals("java.util.Date"))
        <jxb:javaType xmlType="xs:dateTime" name="java.util.Date"
                      parseMethod="org.apache.cxf.xjc.runtime.DataTypeAdapter.parseDateTime"
                      printMethod="org.apache.cxf.xjc.runtime.DataTypeAdapter.printDateTime"/>
#elseif ($datetimeMapping.equals("java.util.Calendar"))
        <jxb:javaType xmlType="xs:dateTime" name="java.util.Calendar"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseDateTime"
                      printMethod="javax.xml.bind.DatatypeConverter.printDateTime"/>
#end
#elseif ($stringUtils.isNotBlank($XMLDateTimeAdapter))
#if ($datetimeMapping.equals("java.util.Date") || $datetimeMapping.equals("java.sql.Timestamp"))
#if (!$cxf21)
        <!-- Requires custom developed datatype bindings -->
        <!--jxb:javaType xmlType="xs:dateTime" name="java.util.Date"
                      parseMethod="com.xxx.DatatypeConverter.parseXsDateTime"
                      printMethod="com.xxx.DatatypeConverter.printXsDateTime"/-->
#else
        <xjc:javaType xmlType="xs:dateTime" name="java.util.Date" adapter="$XMLDateTimeAdapter"/>
#end
#elseif ($datetimeMapping.equals("java.util.Calendar"))
#if (!$cxf21)
        <jxb:javaType xmlType="xs:dateTime" name="$datetimeMapping"
                      parseMethod="javax.xml.bind.DatatypeConverter.parseDateTime"
                      printMethod="javax.xml.bind.DatatypeConverter.printDateTime"/>
#else
        <xjc:javaType xmlType="xs:dateTime" name="$datetimeMapping" adapter="$XMLDateTimeAdapter"/>
#end
##elseif ($datetimeMapping.equals("java.sql.Timestamp"))
##if (!$cxf21)
##        <jxb:javaType xmlType="xs:dateTime" name="java.sql.Timestamp" adapter="$XMLTimestampAdapter"/-->
##                      parseMethod="com.xxx.DatatypeConverter.parseTimestamp"
##                      printMethod="com.xxx.DatatypeConverter.printTimestamp"/>
##else
##        <xjc:javaType xmlType="xs:dateTime" name="java.sql.Timestamp" adapter="$XMLTimestampAdapter"/>
##end
#else
        <xjc:javaType xmlType="xs:dateTime" name="$datetimeMapping" adapter="$XMLDateTimeAdapter"/>
#end
#end
## Binding moved to individual XSD elements so that primitive datatypes remain primitive
#if ($stringUtils.isNotBlank($XMLBooleanAdapter))
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "Boolean").equals("Boolean") || $webServiceUtils.getTypeMapping($service.languageMappings, "Boolean").equals("java.lang.Boolean"))
        <!-- Each boolean attribute with required=false must be bound to Boolean, instead of globally -->
#if (!$cxf21))
        <!--xjc:javaType xmlType="xs:boolean" name="boolean"
                      parseMethod="com.xxx.DatatypeConverter.parseBoolean"
                      printMethod="com.xxx.DatatypeConverter.printBoolean"/-->
#else
        <!--xjc:javaType xmlType="xs:boolean" name="Boolean" adapter="$XMLBooleanAdapter"/-->
#end
#end
#else
        <!-- Bug in CXF 2.1.x: bindings are wrapped Boolean even if attribute is not optional. Use this to make everything wrapped Boolean.
        <xjc:javaType xmlType="xs:boolean" name="boolean" adapter="com.xxx.adapter.BooleanAdapter"/ -->
#end
#if ($stringUtils.isNotBlank($XMLIntegerAdapter))
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "Integer").equals("Integer") || $webServiceUtils.getTypeMapping($service.languageMappings, "Integer").equals("java.lang.Integer"))
        <!-- Default XJC binding is BigInteger, must match java cartridge mapping -->
#if (!$cxf21)
        <!--xjc:javaType xmlType="xs:integer" name="Integer"
                      parseMethod="com.xxx.DatatypeConverter.parseInteger"
                      printMethod="com.xxx.DatatypeConverter.printInteger"/-->
#else
        <xjc:javaType xmlType="xs:integer" name="Integer" adapter="$XMLIntegerAdapter"/>
#end
#end
#end
#if ($stringUtils.isNotBlank($XMLDecimalAdapter))
#if ($webServiceUtils.getTypeMapping($service.languageMappings, "Decimal").equals("Double") || $webServiceUtils.getTypeMapping($service.languageMappings, "Decimal").equals("java.lang.Double"))
        <!-- Default XJC binding is BigInteger, must match java cartridge mapping -->
#if (!$cxf21)
        <!-- Requires custom developed datatype bindings -->
        <!--xjc:javaType xmlType="xs:decimal" name="Double"
                      parseMethod="com.xxx.DatatypeConverter.parseDecimal"
                      printMethod="com.xxx.DatatypeConverter.printDecimal"/-->
#else
        <xjc:javaType xmlType="xs:decimal" name="Double" adapter="$XMLDecimalAdapter"/>
#end
#end
#end
      </jxb:globalBindings>
    </bindings>
</bindings>
#end