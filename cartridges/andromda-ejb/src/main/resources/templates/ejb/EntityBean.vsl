// license-header java merge-point
/* Autogenerated by AndroMDA (EntityBean.vsl) - do not edit */
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end

#if (!$entity.identifiers.empty)
#set ($identifier = $entity.identifiers.iterator().next())
#end
/**
 * Autogenerated EJB implementation class for ${entity.name}
 *
$entity.getDocumentation(" * ")
 *
#if ($entity.abstract)
 * @ejb.bean generate="false"
#else
 * @ejb.bean generate="true"
#end
 *     name="$entity.name"
 *     type="CMP"
 *     cmp-version="2.x"
 *     view-type="local"
 *     local-jndi-name = "${entity.jndiName}/Local"
 *     reentrant="True"
#if (!$identifier.complex)
 *     primkey-field = "$identifier.name"
#end
#set ($automaticKey = $entity.findTaggedValue("andromda_ejb_automaticKey"))
#if ($automaticKey == "true")
 *
 * @weblogic.automatic-key-generation
 *     generator-type="${entity.sqlType}"
 *     generator-name="KEYGEN${entity.name}"
 *     key-cache-size="1"
 #end
 *
 * @jboss.container-configuration name="Instance Per Transaction CMP 2.x EntityBean"
 * @jboss.tuned-updates
 *
 * @ejb.interface generate="false" local-class="${entity.fullyQualifiedName}"
 * @ejb.home generate="false" local-class="${entity.fullyQualifiedName}LocalHome"
 * @ejb.pk generate="false" class="$javaConverter.getJavaLangTypeName($identifier.type.fullyQualifiedName)"
 *
 * @ejb.transaction.type type="$entity.transactionType"
 *
## Only generate persistence tags for concrete EJBs.
#if(!$entity.abstract)
 * @ejb.persistence table-name="$entity.tableName"
 *
#end
#foreach($envEntry in $entity.getEnvironmentEntries(true))
#set ($value = $envEntry.defaultValue)
## Add string delimiters if they are not already present
#if (!$value.startsWith('"') || !$value.endsWith('"'))
#set ($value = "$value")
#end
 * @ejb.env-entry
 *     name="$envEntry.name"
 *     type="$envEntry.type.fullyQualifiedName"
 *     value="$value"
 *
#end
#foreach ( $dependency in $entity.sourceDependencies )
#if ($dependency.hasStereotype("EntityRef") || $dependency.hasStereotype("ServiceRef"))
#set ($reference = $dependency.targetElement)
 * @ejb.ejb-ref
 *     ejb-name="$reference.name"
 *     view-type="$reference.viewType"
 *     ref-name="ejb/${reference.name}BeanRef"
 *
#end
#if ($dependency.hasStereotype("ResourceRef"))
#set ($superclass = $dependency.targetElement)
#set ($jndiRef = $dependency.findTaggedValue("andromda_ejb_resource-ref_jndi-name"))
#set ($resAuth = $dependency.findTaggedValue("andromda_ejb_resource-ref_res-auth"))
#if (!$resAuth)
#set ($resAuth = "Container")
#end
#set ($resName = $dependency.name)
#if (!$resName || $resName == "")
#set ($resName = $reference.name)
#end
 * @ejb.resource-ref
 *     res-ref-name="resource/$resName"
 *     res-type="$reference.type.fullyQualifiedName"
 *     res-auth="$resAuth"
 *
#if ($jndiRef)
 * @jboss.resource-ref
 *     res-ref-name="resource/$resName"
 *     jndi-name="$jndiRef"
 *
 * @websphere.bean
 *
#end
#end
#end
#foreach ( $finder in $entity.getQueryOperations(true))
#if($finder.findTaggedValue("andromda_ejb_query_dialect") == "JBossQL")
 * @ejb.finder signature="$finder.getterSetterReturnTypeName $finder.signature"
 *             query="This finder method is only supported on the JBoss application server"
 * @jboss.query signature="$finder.getterSetterReturnTypeName $finder.signature"
 *             query="$finder.query"
#else
 * @ejb.finder signature="$finder.getterSetterReturnTypeName $finder.signature"
 *             query="$finder.query"
#end
#if ($finder.transactionType)
 *               transaction-type="$finder.transactionType"
#end
#set ($wlQuery = $finder.findTaggedValue("andromda_ejb_query_weblogic", false))
#if    ($wlQuery)
 * @weblogic.finder signature="$finder.type.fullyQualifiedName $finder.signature"
 *                query="$wlQuery"
#end
 *
#end## finder operations
 */
public abstract class ${entity.name}Bean
#if($entity.generalization)
    extends ${entity.generalization.fullyQualifiedName}BeanImpl
#end
    implements jakarta.ejb.EntityBean
{
    // ----------- constant definitions -----------
#foreach($constant in $entity.getConstants(true))
    private static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;
#end

    // -- accessors for environment entries --
#foreach($envEntry in $entity.getEnvironmentEntries(true))
    /**
     * Get <em>${envEntry.name}</em> environment entry.
$envEntry.getDocumentation("     * ")
     *
## Only expose the method to the component interface if it is public.
#if($envEntry.visibility == "public")
     * @ejb.interface-method
#end
     */
    $envEntry.visibility $envEntry.type.fullyQualifiedName ${constant.getterName}()
    {
        javax.naming.InitialContext initialContext = null;
        try
        {
            initialContext = new javax.naming.InitialContext();
            return (${envEntry.type.fullyQualifiedName}}) initialContext.lookup("java:comp/env/$envEntry.name");
        }
        catch (javax.naming.NamingException cause)
        {
            RuntimeException ex = new IllegalStateException(
                "Cannot access environment entry \"$envEntry.name\".");
            // In order to set the exception cause on JDK 1.4
            // and stay JDK 1.3 compatible nonetheless, we need
            // a bit of reflection magic here...
            try
            {
                java.lang.reflect.Method initCause =
                  ex.getClass().getMethod("initCause",
                                        new Class[] {Throwable.class});
                initCause.invoke(ex, new Object[] { cause });
            }
            catch (Throwable throwable)
            {
               // Ignore any errors here - we simply make do without the cause
            }
            throw ex;
        }
        finally
        {
            try
            {
                if (initialContext != null)
                {
                    initialContext.close();
                }
            }
            catch (javax.naming.NamingException ignore)
            {
                // Silently ignore naming exceptions at cleanup time
            }
        }

## If the env-entry is public, expose it to the home interface as well
#if($envEntry.visibility == "public")

    /**
     * Home interface method for accessing {@link #${attribute.getterName}}.
     * @ejb.home-method
     * @see ${esc.hash}${envEntry.getterName}
     */
     public $envEntry.type.fullyQualifiedName ejbHomeGet${envEntry.name}()
     {
         return ${envEntry.getterName};
     }
#end
#end

    // -- accessors for constants --
#foreach($constant in $entity.getConstants(true))
    /**
     * Get the <code>$constant.name</code> constant
$constant.getDocumentation("     * ")
#if ($constant.visibility == "public")
     *
     * @ejb.interface-method
#end
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}()
    {
        return $constant.name;
    }

## If the constant is public, expose it to the home interface as well
#if($constant.visibility == "public")

    /**
     * Home interface method for accessing {@link #${attribute.getterName}}.
     * @ejb.home-method
     * @see ${esc.hash}${constant.getterName}
     */
     public $constant.type.fullyQualifiedName ejbHomeGet${constant.name}()
     {
         return $constant.getterName;
     }
#end
#end

    // --------------- attributes ---------------------
#foreach ( $attribute in $entity.attributes)
#set ($visibility = $attribute.visibility)
    /**
     * Get the $attribute.name property.
$attribute.getDocumentation("     * ")
     *
#if ($attribute.identifier)
     * @ejb.pk-field
#end
     * @ejb.persistence
     *     column-name="${attribute.columnName}"
     *       jdbc-type="${attribute.jdbcType}"
     *        sql-type="${attribute.sqlType}"
#if ($attribute.transactionType)
     * @ejb.transaction type="$attribute.transactionType"
#end
#set ($weblogicDataType = $att.findTaggedValue("andromda_persistence_column_weblogicDataType", false))
#if ($weblogicDataType)
     * @weblogic.dbms-column-type $weblogicDataType
#end
     *
## Only expose the method to the interfaces if it is public. The method
## visibility must be public because of CMP semantics
#if($visibility == "public")
     * @ejb.interface-method
#end
     */
    public abstract $attribute.type.fullyQualifiedName ${attribute.getterName}();

    /**
     * Set the $attribute.name property.
     * @param value the new value
## We need to generate a public set method even for readonly or proteced
## attributes because of CMP semantics.
## But we don't need to expose it on the interface
#if($visibility == "public" && !$attribute.readOnly)
     * @ejb.interface-method
#end
#if ($attribute.transactionType)
     * @ejb.transaction type="$attribute.transactionType"
#end
     */
    public abstract void ${attribute.setterName}($attribute.type.fullyQualifiedName value);

#end

    // ------------- CMR relations ------------------
## If the class is abstract, generate abstract methods for all CMR relations so that they
## are accessible in the *BeanImpl class
#if ($entity.abstract)
#foreach ( $associationEnd in $entity.entityRelations) )
#set ($target = $associationEnd.otherEnd)
#if(!($associationEnd.association.findTaggedValue("andromda_ejb_generateCMR") == "false"))
#set ($targetRoleName = $associationEnd.otherEnd.name)
#set ($targetTypeName = $associationEnd.relationType)

   /**
    * Get the ${associationEnd.otherEnd.name}
$associationEnd.otherEnd.getDocumentation("    * ")
    * @ejb.interface-method
    */
    public abstract $associationEnd.relationType ${target.getterName}();

   /**
    * Set the ${associationEnd.otherEnd.name}
#if(!$associationEnd.otherEnd.readOnly)
    * @ejb.interface-method
#end
    */
    public abstract void ${target.setterName}($associationEnd.relationType ${associationEnd.otherEnd.name});
#end
#end ## foreach

#end
## Generate the real CMR methods.
#foreach ( $associationEnd in $entity.allEntityRelations )
#set ($target = $associationEnd.otherEnd)
## relations not flagged as CMR are generated below under business methods
#if(!($associationEnd.association.findTaggedValue("andromda_ejb_generateCMR") == "false"))

   /**
    * Get the ${target.name}
$target.getDocumentation("    * ")
    *
    * @ejb.interface-method
    * @ejb.relation
    *    name="$associationEnd.association.relationName"
    *    role-name="${associationEnd.association.relationName}:${associationEnd.name}"
#if (!$associationEnd.navigable)
## THIS IS ONLY FOR UNIDIRECTIONAL RELATIONSHIPS
    *    target-ejb="$target.type.name"
    *    target-role-name="${associationEnd.association.relationName}:${target.name}"
#if ($associationEnd.many2One || $associationEnd.many2Many)
    *    target-multiple="true"
#end
#else
    *    target-ejb="$target.type.name"
#end
    *
#if ($transactionType)
    * @ejb.transaction type="$associationEnd.association.transactionType"
    *
#end
#if($associationEnd.many2Many) ## relation table only on the view side
   * @jboss.relation-table table-name = "${associationEnd.association.tableName}"
    * @jboss.relation-mapping style="relation-table"
    *
    * @weblogic.relation
    *   join-table-name="${associationEnd.association.tableName}"
    *
#end
#if(!$associationEnd.navigable)
    * UNIDIRECTIONAL RELATIONSHIP
    *
#if($associationEnd.many2Many)
#foreach ($identifier in $associationEnd.otherEnd.type.identifiers)
    * @jboss.relation
    *     fk-column = "${associationEnd.otherEnd.columnName}"
    *     related-pk-field = "${identifier.name}"
    *
    * @weblogic.column-map
    *   foreign-key-column="${associationEnd.otherEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#foreach ($identifier in $associationEnd.type.identifiers)
    * @jboss.target-relation
    *     fk-column = "${associationEnd.columnName}"
    *     related-pk-field = "${identifier.name}"
    *
    * @weblogic.target-column-map
    *   foreign-key-column="${associationEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#elseif($associationEnd.many2One)
##The one-end is on the other side
#foreach ($identifier in $associationEnd.otherEnd.type.identifiers)
    * @jboss.relation
    *     fk-column="${associationEnd.otherEnd.columnName}"
    *     related-pk-field="${identifier.name}"
    *
    * @weblogic.column-map
    *   foreign-key-column="${associationEnd.otherEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#elseif($associationEnd.one2One)
#if($associationEnd.aggregation || $associationEnd.composition)
## COMPOSITION / AGGREGATION END
#foreach ($identifier in $associationEnd.type.identifiers)
    * @jboss.target-relation
    *     fk-column = "${associationEnd.columnName}"
    *     related-pk-field = "${identifier.name}"
    *
    * @weblogic.target-column-map
    *   foreign-key-column="${associationEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#else
## OTHER END
#foreach ($identifier in $associationEnd.otherEnd.type.identifiers)
    * @jboss.relation
    *     fk-column="${associationEnd.otherEnd.columnName}"
    *     related-pk-field="${identifier.name}"
    *
    * @weblogic.column-map
    *   foreign-key-column="${associationEnd.otherEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#end
#elseif($associationEnd.one2Many)
#foreach ($identifier in $associationEnd.type.identifiers)
    * @jboss.target-relation
    *     fk-column = "${associationEnd.columnName}"
    *     related-pk-field = "${identifier.name}"
    *
    * @weblogic.target-column-map
    *   foreign-key-column="${associationEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#end
#else
    * BIDIRECTIONAL RELATIONSHIP
    *
#if($associationEnd.many2Many)
#foreach ($identifier in $associationEnd.otherEnd.type.identifiers)
    * @jboss.relation
    *     fk-column = "${associationEnd.otherEnd.columnName}"
    *     related-pk-field = "${identifier.name}"
    *
    * @weblogic.column-map
    *   foreign-key-column="${associationEnd.otherEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#elseif($associationEnd.many2One)
#foreach ($identifier in $associationEnd.otherEnd.type.identifiers)
    * @jboss.relation
    *     fk-column = "${associationEnd.otherEnd.columnName}"
    *     related-pk-field = "${identifier.name}"
    *
    * @weblogic.column-map
    *   foreign-key-column="${associationEnd.otherEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#elseif($associationEnd.one2One)
#if($associationEnd.aggregation || $associationEnd.composition)
## COMPOSITION / AGGREGATION END
#foreach ($identifier in $associationEnd.type.identifiers)
    * @jboss.target-relation
    *     fk-column = "${associationEnd.columnName}"
    *     related-pk-field = "${identifier.name}"
    *
    * @weblogic.target-column-map
    *   foreign-key-column="${associationEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#else
## OTHER END
#foreach ($identifier in $associationEnd.otherEnd.type.identifiers)
    * @jboss.relation
    *     fk-column="${associationEnd.otherEnd.columnName}"
    *     related-pk-field="${identifier.name}"
    *
    * @weblogic.column-map
    *   foreign-key-column="${associationEnd.otherEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#end
#elseif($associationEnd.one2Many)
##The one-end is here
#foreach ($identifier in $associationEnd.type.identifiers)
    * @jboss.target-relation
    *     fk-column = "${associationEnd.columnName}"
    *     related-pk-field = "${identifier.name}"
    *
    * @weblogic.target-column-map
    *   foreign-key-column="${associationEnd.columnName}"
    *   key-column="${identifier.columnName}"
    *
#end
#end
#end
    */
    public abstract $associationEnd.relationType ${target.getterName}();

   /**
    * Set the ${associationEnd.otherEnd.name}
#if(!$associationEnd.otherEnd.readOnly)
    * @ejb.interface-method
#end
#if ($associationEnd.association.transactionType)
    * @ejb.transaction type="$associationEnd.association.transactionType"
#end
    */
    public abstract void ${target.setterName}($associationEnd.relationType ${associationEnd.otherEnd.name});
#end
#end ## foreach

    // ---------------- business and select methods  ----------------------
## Generate business methods for relations flagged as non-CMR even when the class
## is abstract. That way, we can implement them in the base class
#foreach ( $associationEnd in $entity.entityRelations)
#set ($target = $associationEnd.otherEnd)
#if($associationEnd.association.findTaggedValue("andromda_ejb_generateCMR") == "false")

   /**
    * Get the ${associationEnd.otherEnd.name}
$associationEnd.otherEnd.getDocumentation("     * ")
    *
    * @ejb.interface-method
#if ($associationEnd.association.transactionType)
    * @ejb.transaction type="$associationEnd.association.transactionType"
#end
    */
    public abstract $associationEnd.relationType ${target.getterName}();

   /**
    * Set the ${associationEnd.otherEnd.name}
    * @ejb.interface-method
#if ($associationEnd.association.transactionType)
    * @ejb.transaction type="$associationEnd.association.transactionType"
#end
    */
    public abstract void ${target.setterName}($associationEnd.relationType ${associationEnd.otherEnd.name});
#end
#end ## foreach

#foreach ( $operation in $entity.businessOperations)
#set ($signature = $operation.signature)
#set ($interfaceType = "interface")
#set ($visibility = $operation.visibility.toString())
## Public static methods are exposed on the home
## interface instead of the component interface
#if ($visibility == "public" && $operation.static)
#set ($interfaceType = "home")
#set ($signature = "ejbHome${stringUtils.capitalize($signature)}")
#end
   /**
$operation.getDocumentation("    * ")
    *
## Only public methods have transactions and are exported to the interfaces
#if ($visibility == "public")
    * @ejb.${interfaceType}-method
#if ($operation.transactionType)
    * @ejb.transaction type="$operation.transactionType"
#end
#end
    */
#set ($returnType = $operation.getterSetterReturnTypeName)
#if ($operation.exceptionsPresent)
    $visibility abstract $returnType $signature
        throws $operation.exceptionList;
#else
    $visibility abstract $returnType $signature;
#end
#end
#foreach ($operation in $entity.getSelectMethods(false))
#set($queryString = "")
#set($queryString = $operation.findTaggedValue("andromda_ejb_query"))
#if($queryString == "")
#set($queryString = "SELECT DISTINCT OBJECT(c) FROM $entity.name AS c")
#if($operation.arguments.size() >0 )
#set($queryString = "${queryString} WHERE")
#foreach($prm in $operation.arguments)
#set($queryString="${queryString} c.$prm.name = ?$velocityCount")
#if($velocityCount != $operation.arguments.size())
#set($queryString = "${queryString} AND")
#end
#end
#end
#end
#set ($returnType = $operation.getterSetterReturnTypeName)
   /**
$operation.getDocumentation("    * ")
    *
    * @ejb.select query="$queryString"
    */
    public abstract $returnType $operation.signature
    throws jakarta.ejb.FinderException;
#end##if operation.stereotype = "SelectMethod"

    // ---------------- create methods --------------------
## Handle explicitly defined create methods. Since we can't know
## what the user intended to do with the arbitrary parameters to these methods,
## we generate an abstract ejbCreateImpl() and delegate the implementation to
## the user.
#foreach ($operation in $entity.getCreateMethods(true))
    /**
#if (!$entity.abstract)
     * Implementation for the
     * {@link #ejbCreate($operation.argumentTypeNames)}
     * create method.
#else
     * Implementation for create methods in derived classes. This method will be called from
     * the autogenerated  <code>ejbCreate($operation.argumentTypeNames)</code>
     * methods in concrete subclasses of this abstract EJB.
#end
     *
     * This extra implementation method is necessary to avoid
     * problems with different primary key classes.
     */
    protected abstract void createImpl(${operation.typedArgumentList})
        throws jakarta.ejb.CreateException;

    /**
$operation.getDocumentation("    * ")
     */
    public $identifier.type.fullyQualifiedName ejbCreate(${operation.typedArgumentList})
        throws jakarta.ejb.CreateException
    {
        createImpl($operation.argumentNames);
        return $identifier.type.javaNullString;
    }

    /**
$operation.getDocumentation("    * ")
     */
    public void ejbPostCreate(${operation.typedArgumentList})
    {
    }

#end

## Autogenerate a create method implementation with all attributes.
#set ($allAttributes = $transform.filterByVisibility($entity.allInstanceAttributes, "public"))
#set ($inheritedAttributes = $transform.filterByVisibility($entity.inheritedInstanceAttributes, "public"))
#set ($instanceAttributes = $transform.filterByVisibility($entity.instanceAttributes, "public"))

    /**
     * Implementation for the create method with all CMP attributes.
     * This method calls the super class implementation for inherited
     * CMP fields and sets all CMP fields defined in this class to the
     * values provided by the parameters. Override this method in the
     * implementation class if you need different behaviour.
     *
     * This extra implementation method is necessary to avoid
     * problems with different primary key classes.
     *
#foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the ${attribute.name} property
#end
     */
    protected void createImpl($transform.getAttributesAsList($allAttributes, true, true))
        throws jakarta.ejb.CreateException
    {
#if(!$inheritedAttributes.empty)
        super.createImpl($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
#if (!$identifier.complex)
#if ($identifier.type.stringType)
        if ($identifier.name == null)
        {
            $identifier.name = new java.rmi.server.UID().toString();
        }

#end
#end
#foreach ( $attribute in $instanceAttributes)
        ${attribute.setterName}(${attribute.name});
#end
    }

## Only generate create methods with all CMP and CMR fields for concrete EJBs,
## and only if it is not explicitly switched off
#if ($entity.syntheticCreateMethodAllowed)
    /**
     * Create method with all CMP attribute values.
#foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the $attribute.name property
#end
     * @ejb.create-method
     * @return <code>null</code> as required by the EJB specification for CMP
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $identifier.type.fullyQualifiedName ejbCreate($transform.getAttributesAsList($allAttributes, true, true))
        throws jakarta.ejb.CreateException
    {
        createImpl($transform.getAttributesAsList($allAttributes, false, true));
        return $identifier.type.javaNullString;
    }

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true))
        throws jakarta.ejb.CreateException
    {
#if(!$inheritedAttributes.empty)
        // Call postCreate method for the super type
        super.ejbPostCreate($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
    }
#set ($relations = $entity.allEntityRelations)
#if (!$relations.empty)
#if ($entity.syntheticCreateMethodAllowed)
    /**
     * Create method with all CMP attribute values and CMR relations.
#foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the $attribute.name property
#end
#foreach ($relation in $relations)
     * @param $relation.otherEnd.name Value for the ${relation.otherEnd.name} relation role
#end
     * @ejb.create-method
     * @return <code>null</code> as required by the EJB specification for CMP
     *         (chapter 10.5.2, "Bean Provider's entity bean instance's view")
     */
    public $identifier.type.fullyQualifiedName ejbCreate($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.empty), #end#foreach ($relation in $relations)${relation.relationType} $relation.otherEnd.name#if($velocityCount != $relations.size()), #end#end)
           throws jakarta.ejb.CreateException
    {
        // Call ejbCreate method for the CMP attributes
        ejbCreate($transform.getAttributesAsList($allAttributes, false, true));
        // Relations cannot be set in ejbCreate() - this is done in ejbPostCreate()
        return $identifier.type.javaNullString;
    }

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true)#if(!$allAttributes.empty), #end#foreach ($relation in $relations)${relation.relationType} $relation.otherEnd.name#if($velocityCount != $relations.size()), #end#end)
        throws jakarta.ejb.CreateException
    {
        // Call postCreate method for the CMP attributes
        ejbPostCreate($transform.getAttributesAsList($allAttributes, false, true));
        // Set the CMR relations
#foreach ($relation in $relations)
        ${relation.otherEnd.setterName}($relation.otherEnd.name);
#end
    }
#end
#end
#end
    // ---------------- accessor methods for bean references ---------------
#foreach ($valueRef in $entity.valueDependencies)
#set ($reference = $valueRef.targetElement)
    /**
     * @ejb.interface-method
     */
    public ${reference.fullyQualifiedName} get${reference.name}()
    {
         ${reference.fullyQualifiedName} valueObject = new ${reference.fullyQualifiedName}();
#foreach ($attr in $reference.getAttributes(true))
#if ($entity.isAttributePresent($attr.name) || $entity.isOperationPresent($attr.getterName))
        valueObject.${attr.setterName}(${attr.getterName}());
#end
#end
        return valueObject;
     }

    /**
     * @ejb.interface-method
     */
     public void set${reference.name}(${reference.fullyQualifiedName} valueObject)
     {
#foreach ($attr in $reference.getAttributes(true))
#if ((${entity.isAttributePresent($attr.name)} || $entity.isOperationPresent($attr.setterName))&& !${entity.isIdentifierPresent($attr.name)})
        ${attr.setterName}(valueObject.${attr.getterName}());
#end
#end
     }

#end
#foreach ($dependency in $entity.sourceDependencies)
#if ($dependency.hasStereotype("EntityRef") || $dependency.hasStereotype("ServiceRef"))
#set ($reference = $dependency.targetElement)
#if ($reference.viewType == "local")
#set ($homeInterfaceName = "${reference.name}LocalHome")
#set ($fqHomeInterfaceName = "${reference.fullyQualifiedName}LocalHome")
    /**
     * Get the local home interface of the ${reference.name} bean.
     * The home interface is obtained from the initial context
     * by looking up the bean reference name.
     * @return local home interface for ${reference.name}.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}()
        throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext =
            new javax.naming.InitialContext();
        try
        {
            // Local homes shouldn't be narrowed, as there is no RMI involved.
            ${fqHomeInterfaceName} home =
                (${fqHomeInterfaceName}) initialContext.lookup("java:/comp/env/ejb/${reference.name}BeanRef");
            return home;
        }
        finally
        {
            initialContext.close();
        }
    }
#end
#if ($reference.viewType == "remote")
#set ($homeInterfaceName = "${reference.name}Home")
#set ($fqHomeInterfaceName = "${reference.fullyQualifiedName}Home")
    /**
     * Get the remote home interface of the ${reference.name} bean.
     * The home interface is obtained from the initial context
     * by looking up the bean reference name.
     * @return remote home interface for ${reference.name}. Lookup using bean ref name.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}()
        throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext =
            new javax.naming.InitialContext();
        try
        {
            Object home =
                 initialContext.lookup("java:/comp/env/ejb/${reference.name}BeanRef");
            return ($fqHomeInterfaceName)
                   javax.rmi.PortableRemoteObject.narrow(home,
                   ${fqHomeInterfaceName}.class);
        }
        finally
        {
            initialContext.close();
        }
    }
#end
#end
#if ($dependency.hasStereotype("ResourceRef"))
#set ($reference = $dependency.targetElement)
#set ($resClassName = "$reference.fullyQualifiedName")
#set ($resName = $dependency.name)
#if (!$resName || $resName == "")
#set ($resName = $reference.name)
#end
    /**
     * Get the ${resName} resource.
     * The resource is obtained by looking up
     * <code>java:/comp/env/resource/$resName</code> in JNDI
     * @return the ${resName} resource
     */
    protected static ${resClassName} get${stringUtils.capitalize($resName)}()
        throws javax.naming.NamingException
    {
        javax.naming.InitialContext initialContext =
            new javax.naming.InitialContext();
        try
        {
            Object resource =
                 initialContext.lookup("java:/comp/env/resource/$resName");
            return ($resClassName) resource;
        }
        finally
        {
            initialContext.close();
        }
    }
#end
#end

    private jakarta.ejb.EntityContext ctx;

    public void setEntityContext(jakarta.ejb.EntityContext ctx)
    {
        this.ctx = ctx;
    }

    public void unsetEntityContext()
    {
        ctx = null;
    }

    public void ejbRemove()
        throws jakarta.ejb.RemoveException
    {
    }

    public void ejbLoad()
    {
    }

    public void ejbStore()
    {
    }

    public void ejbPassivate()
    {
    }

    public void ejbActivate()
    {
    }
}