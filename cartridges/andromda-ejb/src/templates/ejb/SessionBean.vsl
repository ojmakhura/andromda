// license-header java merge-point
/* Autogenerated by AndroMDA - do not edit
 * 
 * TEMPLATE:    SessionBean.vsl in andromda-ejb-cartridge
 * MODEL CLASS: ${service.validationName}
#foreach ($stereotype in $service.stereotypes)
 * STEREOTYPE:  ${stereotype.name}
#end
*/
// To generate ejb-jar.xml for this project, Enable XDoclet
// (creates xdoclet-build.xml) with the following configuration updates:
// <path id="project.classpath"><pathelement location="common/target/classes"/>
// <fileset dir="core/target/src-gen"  includes="**/*.java" >
// <deploymentdescriptor validateXML="true"  destDir="core/target/classes/META-INF" >

#if ($stringUtils.isNotBlank($service.packageName))
package $service.packageName;
#end

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;
import javax.naming.NamingException;

/**
 * Autogenerated EJB implementation class for the $service.name session bean.
$service.getDocumentation(" * ")
 *
#if ($service.abstract)
 * @ejb.bean generate="false"
#else
 * @ejb.bean generate="true"
#end
 *     name="$service.name"
 *     display-name="${service.name}StatelessSessionBean"
 *     description="Stateless Session bean representing the Service ${service.name}"
 *     type="$service.type"
 *     view-type="$service.viewType"
 *     jndi-name = "${service.jndiName}/Remote"
 *     local-jndi-name = "${service.jndiName}/Local"
 *
 * @ejb.interface
 *     local-class="${service.fullyQualifiedName}Local"
 *     remote-class="${service.fullyQualifiedName}"
 * @ejb.home
 *     local-class="${service.fullyQualifiedName}LocalHome"
 *     remote-class="${service.fullyQualifiedName}Home"
 * @ejb.transaction type="$service.transactionType"
 *
 * @ejb.util generate="physical"
 *
#foreach($envEntry in $service.getEnvironmentEntries(true))
#set ($value = $envEntry.defaultValue)
## Add string delimiters if they are not already present
#if (!$value.startsWith('"') || !$value.endsWith('"'))
#set ($value = "$value")
#end
 * @ejb.env-entry
 *     name="$envEntry.name"
 *     type="$envEntry.type.fullyQualifiedName"
 *     value="$value"
 *
#end
#foreach ( $dependency in $service.sourceDependencies )
#if ($dependency.hasStereotype("EntityRef") || $dependency.hasStereotype("ServiceRef"))
#set ($reference = $dependency.targetElement)
 * @ejb.ejb-ref
 *     ejb-name="${reference.name}"
 *     view-type="$reference.viewType"
 *     ref-name="ejb/${reference.name}BeanRef"
 *
#end
#if ($dependency.hasStereotype("ResourceRef"))
#set ($reference = $dependency.targetElement)
#set ($jndiRef = $dependency.findTaggedValue("@andromda.ejb.resource-ref.jndi-name"))
#set ($resAuth = $dependency.findTaggedValue("@andromda.ejb.resource-ref.res-auth"))
#if (!$resAuth)
#set ($resAuth = "Container")
#end
#set ($resName = $dependency.name)
#if (!$resName)
#set ($resName = $reference.name)
#end
 * @ejb.resource-ref
 *     res-ref-name="resource/$resName"
 *     res-type="${reference.fullyQualifiedName}"
 *     res-auth="$resAuth"
 *
#if ($jndiRef)
 * @jboss.resource-ref
 *     res-ref-name = "resource/$resName"
 *     jndi-name = "$jndiRef"
 *
 * @weblogic.resource-description
 *	res-ref-name= "resource/$resName"
 *	jndi-name= "$jndiRef"
 *
 * @websphere.bean
#end
#end
#end
 */
public abstract class ${service.name}Bean
#if($service.generalization)
    extends ${service.generalization.fullyQualifiedName}BeanImpl
#end
    implements SessionBean
{
    // ----------- constant definitions -----------
#foreach($constant in $service.getConstants(true))
    private static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;
#end

    // -- accessors for environment entries --
#foreach($envEntry in $service.getEnvironmentEntries(true))
    /**
     * Get <em>${envEntry.name}</em> environment entry.
$envEntry.getDocumentation("     * ")
     *
## Only expose the method to the component interface if it is public.
#set ($visibility = $envEntry.visibility)
#if($visibility == "public")
     * @ejb.interface-method view-type = "remote"
#end
     */
    $visibility $envEntry.type.fullyQualifiedName ${envEntry.getterName}()
    {
        javax.naming.InitialContext initialContext = null;
        try 
        {
            initialContext = new javax.naming.InitialContext();
            return (${envEntry.type.fullyQualifiedName}) initialContext.lookup("java:comp/env/$envEntry.name");
        } 
        catch (NamingException cause)
        {
            RuntimeException ex = new IllegalStateException(
                "Cannot access environment entry \"$envEntry.name\".");
            // In order to set the exception cause on JDK 1.4
            // and stay JDK 1.3 compatible nonetheless, we need
            // a bit of reflection magic here...
            try 
            {
                java.lang.reflect.Method initCause =
                  ex.getClass().getMethod("initCause",
                                        new Class[] {Throwable.class});
                initCause.invoke(ex, new Object[] { cause });
            } 
            catch (Throwable t) 
            {
               // Ignore any errors here - we simply make do without the cause
            }
            throw ex;
        } 
        finally 
        {
            try 
            {
                if (initialContext != null) 
                { 
                    initialContext.close(); 
                }
            } 
            catch (NamingException ignore)
            {
                // Silently ignore naming exceptions at cleanup time
            }
        }
    }
#end

    // -- accessors for constants --
#foreach($constant in $service.getConstants(true))
    /**
     * Get the <code>$constant.name</code> constant
$constant.getDocumentation("     * ")
#if ($constant.visibility == "public")
     *
     * @ejb.interface-method
#end
     */
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}()
    {
        return $constant.name;
    }

## If the constant is public, expose it to the home interface as well
#if($constant.visibility == "public")

    /**
     * Home interface method for accessing {@link #${attribute.getterName}}.
     * @ejb.home-method
     * @see ${esc.hash}${constant.getterName}
     */
     public $constant.type.fullyQualifiedName ejbHomeGet${constant.name}() 
     {
         return ${constant.getterName}();
     }
#end
#end

#set ($instanceAttributes = $service.instanceAttributes)
#if(!$instanceAttributes.empty)
    // --------------- attributes ---------------------
#foreach ( $attribute in $instanceAttributes)
#set ($visibility = $attribute.visibility)
    /** The $attribute.name property */
    private $attribute.type.fullyQualifiedName $attribute.name;

    /**
     * Get the ${attribute.name} property
$attribute.getDocumentation("     * ")
     *
#if ($attribute.transactionType)
     * @ejb.transaction type="$attribute.transactionType"
#end
#if($visibility == "public")
     * @ejb.interface-method
#end
     */
    $visibility $attribute.type.fullyQualifiedName ${attribute.getterName}() 
    {
       return $attribute.name;
    }

## Only generate a setter if the attribute is not read-only
## Note: It's no use to generate final fields for read-only attributes because
## the fields are likely to be initialized in ejbActivate() or a similiar
## method and not in the constructor.
#if (!$attribute.readOnly)
    /**
     * Set the $attribute.name property
     * @param value the new value
#if($visibility == "public")
     * @ejb.interface-method
#end
#if ($attribute.transactionType)
     * @ejb.transaction type="$attribute.transactionType"
#end
     */
    $visibility void ${attribute.setterName}($attribute.type.fullyQualifiedName value) 
    {
       this.$attribute.name = value;
    }

#end
#end
#end
    // ---------------- business methods  ----------------------

#foreach ( $operation in $service.businessOperations)
#set ($visibility = $operation.visibility)
#set ($returnType = $operation.getterSetterReturnTypeName)
   /**
$operation.getDocumentation("    * ")
    * Do not call this method: Call the service implementation method ${service.fullyQualifiedName}Impl.${operation.name}
#foreach ( $parameter in $operation.parameters)
## Return parameter is included in list of parameters (annoying)
#if (${parameter.name} != "ReturnResult" && ${parameter.name} != "" && ${parameter.name} != $operation.returnType.name)
    * @param $parameter.name
#end
#end
#if ($operation.returnTypePresent)
    * @return $returnType
#end
#foreach ( $exception in $operation.exceptions)
    * @throws $exception.fullyQualifiedName
#end
## Only public methods have transactions and are exported to the interfaces
#if ($visibility == "public")
    * @ejb.interface-method view-type = "remote"
#if ($operation.transactionType)
    * @ejb.transaction type="$operation.transactionType"
#end
#end
    */
## This is public because CDoclet generates a ServiceSession object which extends the bean, which would have to implement an abstract method
#if ($operation.exceptionsPresent)
    $visibility abstract $returnType $operation.signature throws $operation.exceptionList
#else
    $visibility abstract $returnType $operation.signature
#end
    {
        throw new EJBException("Call the service implementation method ${service.fullyQualifiedName}Impl.${operation.name}");
    }

#end

    // ---------------- create methods --------------------
## Handle explicitly defined create methods. Since we can't know
## what the user intended to do with the arbitrary parameters to these methods,
## we generate an abstract ejbCreate() and delegate the implementation to the user.
#foreach ( $operation in $service.getCreateMethods(false))

    /**
$operation.getDocumentation("    * ")
     * Abstract ejbCreate() delegates the implementation to ${service.name}Impl.
     *
     * @ejb.create-method
     * @throws CreateException
     */
    public abstract void ejbCreate($operation.typedArgumentList);

    public void ejbPostCreate($operation.typedArgumentList) 
    {
    }
#end
## Default create method with no arguments.

   /**
    * @throws CreateException
## Only expose the method to the interface for concrete EJBs
#if (!$service.abstract)
    * @ejb.create-method
#end
    */
    public void ejbCreate() throws CreateException
    {
        // Documented empty block - avoid compiler warning
    }

    /**
     * @throws CreateException
     */
    public void ejbPostCreate() throws CreateException
    {
        // Documented empty block - avoid compiler warning
    }

## Autogenerated create method with all attributes. Only present for stateful beans.
#set ($allAttributes = $service.allInstanceAttributes)
#if (!$allAttributes.empty)
    /**
     * Create method with all attribute values.
#set ($inheritedAttributes = $service.inheritedInstanceAttributes)
#foreach($attribute in $allAttributes)
     * @param $attribute.name Value for the ${attribute.name} property
#end
     * @ejb.create-method
     */
    public void ejbCreate($transform.getAttributesAsList($allAttributes, true, true))
           throws CreateException
    {
#if(!$inheritedAttributes.empty)
        // Call ejbCreate method for the super type
        super.ejbCreate($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
#foreach ( $attribute in $service.instanceAttributes)
## Don't use a setter here - we may have none if the attribute is marked readonly
        this.$attribute.name = $attribute.name;
#end
    }

    public void ejbPostCreate($transform.getAttributesAsList($allAttributes, true, true)) 
        throws CreateException
    {
#if(!$inheritedAttributes.empty)
        // Call postCreate method for the super type
        super.ejbPostCreate($transform.getAttributesAsList($inheritedAttributes, false, true));
#end
    }
#end
#if ($service.sourceDependencies.size() > 0)

    // ---------------- accessor methods for bean references ---------------
#end
#foreach ( $dependency in $service.sourceDependencies )
#if ($dependency.hasStereotype("EntityRef") || $dependency.hasStereotype("ServiceRef"))
#set ($reference = $dependency.targetElement)
#if ($reference.viewType == "local")
#set ($homeInterfaceName = "${reference.name}LocalHome")
#set ($fqHomeInterfaceName = "${reference.fullyQualifiedName}LocalHome")

    /**
     * Get the local home interface of the ${reference.name} bean.
     * The home interface is obtained from the initial context
     * by looking up the bean reference name.
     * @return local home interface for ${reference.name}.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() 
        throws NamingException
    {
        javax.naming.InitialContext initialContext = new javax.naming.InitialContext();
        try 
        {
            // Local homes shouldn't be narrowed, as there is no RMI involved.
            ${fqHomeInterfaceName} home =
                (${fqHomeInterfaceName}) initialContext.lookup("java:/comp/env/ejb/${reference.name}BeanRef");
            return home;
        } 
        finally 
        {
            initialContext.close();
        }
    }
#end
#if ($reference.viewType == "remote")
#set ($homeInterfaceName = "${reference.name}Home")
#set ($fqHomeInterfaceName = "${reference.fullyQualifiedName}Home")

    /**
     * Get the remote home interface of the ${reference.name} bean.
     * The home interface is obtained from the initial context
     * by looking up the bean reference name.
     * @return remote home interface for ${reference.name}. Lookup using bean ref name.
     */
    protected static ${fqHomeInterfaceName} get${homeInterfaceName}() 
        throws NamingException
    {
        javax.naming.InitialContext initialContext = new javax.naming.InitialContext();
        try 
        {
            Object home =
                 initialContext.lookup("java:/comp/env/ejb/${reference.name}BeanRef");
            return ($fqHomeInterfaceName)
                   javax.rmi.PortableRemoteObject.narrow(home,
                   ${fqHomeInterfaceName}.class);
        } 
        finally 
        {
            initialContext.close();
        }
    }
#end
#end
#if ($dependency.hasStereotype("ResourceRef"))
#set ($reference = $dependency.targetElement)
#set ($resClassName = "$referencedClass.fullyQualifiedName}")
#set ($resName = $dependency.name)
#if (!$resName)
#set ($resName = $reference.name)
#end
    /**
     * Get the ${resName} resource.
     * The resource is obtained by looking up
     * <code>java:/comp/env/resource/$resName</code> in JNDI
     * @return the ${resName} resource
     */
    protected static ${resClassName} get${stringUtils.capitalize($resName)}()
        throws NamingException
    {
        javax.naming.InitialContext initialContext =
            new javax.naming.InitialContext();
        try 
        {
            Object resource =
                 initialContext.lookup("java:/comp/env/resource/$resName");
            return ($resClassName) resource;
        } 
        finally 
        {
            initialContext.close();
        }
    }
#end
#end

    private SessionContext context;

    /**
     * @see SessionBean#setSessionContext(SessionContext)
     */
    public void setSessionContext(SessionContext ctx)
    {
        this.context = ctx;
    }

    /**
     * Additional method to allow getting a reference to the SessionContext for logging
     *
     * @return SessionContext - a reference to the EJB SessionContext object
     */
    public SessionContext getSessionContext()
    {
        return this.context;
    }

    /**
     * @see SessionBean#ejbRemove()
     */
    public void ejbRemove() 
    {
        // Documented empty block - avoid compiler warning
    }

    /**
     * @see SessionBean#ejbPassivate()
     */
    public void ejbPassivate()
    {
        // Documented empty block - avoid compiler warning
    }

    /**
     * @see SessionBean#ejbActivate()
     */
    public void ejbActivate()
    {
        // Documented empty block - avoid compiler warning
    }
}