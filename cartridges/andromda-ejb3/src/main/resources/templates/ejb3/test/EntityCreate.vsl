#if ($umlUtils.shouldOutput($entity) && !$entity.abstract)
#parse("templates/ejb3/Globals.vm")
#set ($generatedFile = "${stringUtils.replace($entity.fullyQualifiedEntityName,'.','/')}Create.java")
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by test/EntityCreate.vsl in andromda-ejb3-cartridge.
//
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;

#end
import java.util.List;
import jakarta.persistence.EntityManager;
import jakarta.persistence.TypedQuery;
//import org.andromda.dbtest.JPAJUnitAncestor;
#set ($associations = $entity.entityRelations)
#if (!$associations.empty)
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
#end
##
## If the entity is in the middle of an inheritance hierarchy
## it cannot be:
##
## 1. an embeddable superclass
## 2. an abstract class
##
##
## If the entity is explicitly defined as a mapped superclass then use the standard entity name
## If explicit business operations are modelled on the entity, then the entity naming convention differs
## All other entities have the standard entity name
##

/**
 * Autogenerated Entity constructor class for ${entity.entityName} which creates
 * an Entity instance using dummy/default values for all properties, with a method for
 * minimal properties (only required), all properties, and an update from minimal to update the rest of the properties.
 * It assumes that Entities only have relations to other entities, so those constructors can be used.
 *
 * Autogenerated by AndroMDA ejb3\test\EntityConstructor.vsl on $umlUtils.date
 *
$entity.getDocumentation(" * ")
 */
public class ${entity.entityName}Create
##if($entity.requiresGeneralizationMapping && !$entity.generalization.interface && !$entity.generalization.abstract)
##if($entity.embeddableSuperclassGeneralizationExists && $entity.generalization.entityImplementationRequired)
##    extends ${entity.generalization.fullyQualifiedEntityEmbeddableName}Create
##else
##    extends ${entity.generalization.fullyQualifiedName}Create
##end
##end
#foreach($general in $entity.allGeneralizations)
#if ($general.name.equals("AbstractEntity") || $general.name.equals("AuditedEntity") || $general.name.equals("AbstractVersionedEntity") || $general.name.equals("AbstractAuditedVersionedEntity") || $general.name.startsWith("AbstractPersistent"))
#set ($jpaFramework=true)
#end
#end
{
#if (!$associations.empty)
    private static Logger LOGGER = LogManager.getLogger(${entity.entityName}Create.class);

#end
    /**
     * Create an Entity $entity.name with all attributes and associations set
     * @param em EntityManager used within this transaction
     * @return $entity.fullyQualifiedName
     */
    public static ${entity.fullyQualifiedName} createEntity(EntityManager em)
    {
        $entity.fullyQualifiedName entity = new ${entity.fullyQualifiedName}();
#if ($entity.compositePrimaryKeyPresent)
        ${entity.entityName}PK pk = ${entity.entityName}Create.createEntityPK(true);
#end
#set ($properties = $entity.getAttributes(true))
## Set the value for all properties including ancestor properties
        // Identifier attributes
#foreach ($property in $properties)
##        // $property.type.fullyQualifiedName $property.name identifier=$property.identifier usingAssignedIdentifier=$entity.usingAssignedIdentifier property=$property type=$property.type
#if (!$property.transient && $property.identifier && ($entity.usingAssignedIdentifier || $property.generatorTypeNone) && !$entity.compositePrimaryKeyPresent)
       #if ($property.type.abstract) //#end entity.${property.setterName}($umlUtils.createConstructor($property, $property.many, $entity));
#end
#end

#if (!$associations.empty)
        //EntityManager em = jakarta.persistence.Persistence.createEntityManagerFactory(org.andromda.dbtest.JPAJUnitAncestor.PERSISTENCE_UNIT).createEntityManager();
        // Entity Associations which need to be retrieved
#end
#foreach ($end in $associations)
## The dependent entity owned by this association should have been created already
## If not owned, assoc/column is nullable. Don't want recursive create on bidirectional relationship.
#set ($thisEnd = $end.otherEnd)
#if (!$thisEnd.transient && !$thisEnd.readOnly && $end.owning)
##        // name=$thisEnd.name oName=$thisEnd.name owning=$end.owning other=$thisEnd.owning identifier=$end.identifier otherIdentifier=$thisEnd.identifier FQN=$thisEnd.type.fullyQualifiedName identifiers=$entityUtils.getIdentifierAttributes($thisEnd.type, true).size()
#set ($endVar = $thisEnd.name)
##set ($endVar = $stringUtils.uncapitalize($thisEnd.type.name))
        $thisEnd.type.fullyQualifiedName $endVar = ${thisEnd.type.fullyQualifiedName}Create.findFirst(em);
        $endVar = em.merge($endVar);
        LOGGER.info("${entity.name}.createEntity merged: " + $endVar);
#if ($thisEnd.many)
        java.util.Set<$thisEnd.type.fullyQualifiedName> ${endVar}List = new java.util.HashSet<$thisEnd.type.fullyQualifiedName>();
        ${endVar}List.add($endVar);
        entity.${thisEnd.setterName}(${endVar}List);
#elseif ($thisEnd.identifier && $entity.compositePrimaryKeyPresent)
        pk.${thisEnd.setterName}($endVar);
#else
        entity.${thisEnd.setterName}($endVar);
#end
##        // identifier=$end.identifier identifier=$thisEnd.identifier
##if ($thisEnd.identifier && $entity.compositePrimaryKeyPresent)
##        // $identifier.name $identifier.type.name $thisEnd.type.name $identifier.owner.compositePrimaryKeyPresent $thisEnd.type.compositePrimaryKeyPresent $identifier.owner $identifier
##        pk.${identifier.setterName}(${endVar}#if($thisEnd.type.compositePrimaryKeyPresent).getPk()#end.${identifier.getterName}());
##end
##end
#end
#end

#foreach ($property in $properties)
        // $property.type.fullyQualifiedName $property.getterSetterTypeName $property.fullyQualifiedName transient=$property.transient identifier=$property.identifier usingAssignedIdentifier=$entity.usingAssignedIdentifier many=$property.many type=$property.type property=$property
##        // Transient=$property.hasStereotype("Transient") stereotypes=$property.stereotypeNames.size() #foreach($name in $property.stereotypeNames)$name #end
#if (!$property.transient && !$property.readOnly && !$property.identifier)
        // Updatable property
       #if ($property.type.abstract) //#end entity.${property.setterName}($umlUtils.createConstructor($property, $property.many, $entity));
#end
#end

#foreach ($property in $properties)
##        // $property.type.fullyQualifiedName $property.fullyQualifiedName transient=$property.transient identifier=$property.identifier usingAssignedIdentifier=$entity.usingAssignedIdentifier many=$property.many property=$property type=$property.type
##        // Transient=$property.hasStereotype("Transient") stereotypes=$property.stereotypeNames.size() #foreach($name in $property.stereotypeNames)$name #end
#if ($property.transient)
        // Transient property
       #if ($property.type.abstract)//#end entity.${property.setterName}($umlUtils.createConstructor($property, $property.many, $entity));
#end
#end
#if ($jpaFramework)
        // Populate create/update date, create/update user
        entity.populateDefaultAuditData();
#end
#if ($entity.compositePrimaryKeyPresent)
        entity.setPk(pk);
#end
        return entity;
    }
#if ($entity.compositePrimaryKeyPresent)

    /**
     * Create an Entity $entity.name Primary Key class with all attributes and associations set
     * @param assignIdentifiers If the entity is using assigned identifiers
     * @return $entity.fullyQualifiedName
     */
    public static $entity.fullyQualifiedEntityCompositePrimaryKeyName createEntityPK(boolean assignIdentifiers)
    {
        $entity.fullyQualifiedEntityCompositePrimaryKeyName pk = new ${entity.fullyQualifiedEntityCompositePrimaryKeyName}();
## identifierAttributes includes associations also. Only set attribute values here, assoc is set in .create()
#set ($identifiers = $entityUtils.getIdentifiers($entity, true))
#foreach ($identifier in $identifiers)
##        // $identifier.associationEndFacadeMetaType $identifier.attributeFacadeMetaType $identifier
#if ($identifier.attributeFacadeMetaType)
#set ($constructor=$umlUtils.createConstructor($identifier, $identifier.many, $entity))
        pk.${identifier.setterName}($constructor);
#end
#end
        return pk;
    }
#end

    /**
     * Create an Entity ${entity.entityName} with all attributes and associations set
     * @param em EntityManager used to findAll
     * @return ${entity.entityName}
     */
    public static List<${entity.entityName}> findAll(EntityManager em)
    {
        //EntityManager em = JPAJUnitAncestor.createEntityManager();
        TypedQuery<${entity.entityName}> query = em.createNamedQuery("${entity.entityName}.findAll", ${entity.entityName}.class);
        List<${entity.entityName}> results = query.getResultList();
        return results;
    }

    /**
     * Return a persisted Entity ${entity.entityName} with all attributes and associations set
     * Used to set persistent association relationships in related entities.
     * @param em EntityManager used to findFirst
     * @return ${entity.entityName}
     */
    public static ${entity.entityName} findFirst(EntityManager em)
    {
        ${entity.entityName} entity = null;
        //EntityManager em = JPAJUnitAncestor.createEntityManager();
        TypedQuery<${entity.entityName}> query = em.createNamedQuery("${entity.entityName}.findAll", ${entity.entityName}.class);
        List<${entity.entityName}> results = query.getResultList();
        if (!results.isEmpty())
        {
            entity = results.get(0);
        }
        else
        {
            entity = createEntity(em);
            em.persist(entity);
        }
        return entity;
    }
}
#end