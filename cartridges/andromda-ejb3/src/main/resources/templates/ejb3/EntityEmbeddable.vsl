// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: EntityEmbeddable.vsl in andromda-ejb3-cartridge.
//
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end
##
## If the entity is in the middle of an inheritance hierarchy
## it cannot be:
##
## 1. an embeddable superclass
## 2. an abstract class
##
## 
#if ($entity.entityImplementationRequired || $entity.embeddableSuperclass)
#**##set ($generatedFile = "${stringUtils.replace($entity.fullyQualifiedEntityEmbeddableName,'.','/')}.java")
#else
#**##set ($generatedFile = "${stringUtils.replace($entity.fullyQualifiedEntityName,'.','/')}.java")
#end

#set ($identifier = $entity.identifiers.iterator().next())
/**
 * Autogenerated POJO EJB#if ($entity.entityImplementationRequired || $entity.embeddableSuperclass) mapped super#end class for ${entity.entityName} containing the 
 * bulk of the entity implementation.
 *
 * This is#if ($entity.entityImplementationRequired || $entity.embeddableSuperclass) a mapped super class and#end autogenerated by AndroMDA using the EJB3
 * cartridge.
 *
 * DO NOT MODIFY this class.
 *
$entity.getDocumentation(" * ")
 *
 */
##
## Only set the Entity annotation if it is explicity defined as an embeddable super class
## or business operations exist(implementation is required).
##
#if ($entity.entityImplementationRequired || $entity.embeddableSuperclass)
@javax.persistence.MappedSuperclass
#else
@javax.persistence.Entity
##
## Include the Table annotation for a base class in single table inheritence hierarchy
## but not in the subclasses.  Include in all classes for joined and table per class
## inheritance hierarchies.
##
## If a class is manually specified as an embeddable superclass, add
## the Table annotation to the subclass, not to the base superclass.
##
#**##if (!$entity.entityImplementationRequired && ($entity.requiresSpecializationMapping || ($entity.requiresGeneralizationMapping && ($entity.embeddableSuperclassGeneralizationExists || $entity.inheritanceTablePerClass || $entity.inheritanceJoined))))
@javax.persistence.Table(name = "${entity.tableName}")
#**##end
#**##if ($entity.listenerEnabled)
@javax.persistence.EntityListeners({${entity.fullyQualifiedEntityListenerName}.class})
#**##end
##
## Only include the inheritance related annotations for inheritance mapping
## that doesn't involve embeddable superclass hierarchy.
##
#**##if ($entity.requiresSpecializationMapping)
@javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType.${entity.inheritanceStrategy})
##
## Discriminator components only apply to single table mapping strategy
##
#*  *##if ($entity.inheritanceSingleTable)
#*    *##set ($argExists = false)
@javax.persistence.DiscriminatorColumn(#if ($entity.discriminatorColumn)name = "${entity.discriminatorColumn}"#set ($argExists = true)#end#if ($entity.discriminatorType)#if ($argExists), #end#**#discriminatorType = javax.persistence.DiscriminatorType.${entity.discriminatorType}#set ($argExists = true)#end#if ($entity.discriminatorColumnDefinition)#if ($argExists), #end#**#columnDefinition = "${entity.discriminatorColumnDefinition}"#set ($argExists = true)#end#if ($entity.discriminatorLength > 0)#if ($argExists), #end#**#length = ${entity.discriminatorLength}#end)
@javax.persistence.DiscriminatorValue("${entity.discriminatorValue}")
#*  *##end
#**##elseif ($entity.requiresGeneralizationMapping && $entity.inheritanceSingleTable)
##
## Only include the DiscriminatorValue annotation for subclasses if
## the inheritance strategy is single table mapping strategy.
##
@javax.persistence.DiscriminatorValue("${entity.discriminatorValue}")
#**##end
#**##if ($entity.cacheEnabled)
@org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.${entity.cacheType})
#**##end
##
## If super class is a mapped superclass, then include named queries from it
##
#**##if ($entity.embeddableSuperclassGeneralizationExists)
#*  *##set ($finders = $entity.getQueryOperations(true))
#**##else
#*  *##set ($finders = $entity.getQueryOperations(false))
#**##end
#**##if (!$finders.empty)
@javax.persistence.NamedQueries
({
#*  *##if ($entity.genericFinders)
    @javax.persistence.NamedQuery(name = "${entity.name}.findAll", query = "select $stringUtils.uncapitalize(${entity.name}) from ${entity.name} AS $stringUtils.uncapitalize(${entity.name})")#if (!$finders.empty),#end

#*  *##end
#*  *##foreach ($finder in $finders)
    @javax.persistence.NamedQuery(name = "${entity.name}.${finder.name}", query = "${finder.query}")#if($velocityCount != $finders.size()), #end

#*  *##end
})
#**##else
#*  *##if ($entity.genericFinders)
@javax.persistence.NamedQuery(name = "${entity.name}.findAll", query = "select $stringUtils.uncapitalize(${entity.name}) from ${entity.name} AS $stringUtils.uncapitalize(${entity.name})")#if (!$finders.empty),#end
    
#*  *##end
#**##end
#end
public#if ($entity.entityImplementationRequired || $entity.embeddableSuperclass) abstract class ${entity.entityEmbeddableName}#else class ${entity.entityName}#end

#if($entity.requiresGeneralizationMapping)
#**##if($entity.embeddableSuperclassGeneralizationExists)
    extends ${entity.generalization.fullyQualifiedEntityEmbeddableName}
#**##else
    extends ${entity.generalization.fullyQualifiedName}
#**##end
#end
    implements java.io.Serializable
#if (!$entity.interfaceAbstractions.empty)
        , $entity.implementedInterfaceList
#end
{

    private static final long serialVersionUID = ${entity.serialVersionUID}L;
#set ($constants = $entity.getConstants(true))
#if (!$constants.empty)

    // ----------- Constant Definitions -------------
    
#**##foreach ($constant in $constants)
    @javax.persistence.Transient
    public static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;
    
#**##end
#end
##
## Only declase instance attributes that are NOT inherited.
## If a mapped superclass then don't generate auto identifier - but include
## normal defined identifier if one is defined.
##
#if ($entity.embeddableSuperclass && $entity.dynamicIdentifiersPresent)
#**##set ($attributes = $entity.getInstanceAttributes(false, false))
#else
#**##set ($attributes = $entity.instanceAttributes)
#end
#if (!$attributes.empty)

    // ----------- Attribute Definitions ------------

##
## If composite PK attribute declaration
##
#**##if ($entity.compositePrimaryKeyPresent)
    private ${entity.fullyQualifiedEntityCompositePrimaryKeyName} pk;
#**##end
##
## Only include identifier attributes if a composite primary key is NOT present
##
#**##foreach ($attribute in $attributes)
#*  *##if ($entity.compositePrimaryKeyPresent && $attribute.identifier)
#*    *##set ($doAttribute = false)
#*  *##else
#*    *##set ($doAttribute = true)
#*  *##end
#*  *##if ($doAttribute)
##
## Check for overriding LOB type
##
    private #if ($stringUtils.isNotBlank($attribute.lobType))${attribute.lobType}#else${attribute.type.fullyQualifiedName}#end $attribute.name;
#*  *##end
#**##end

#end
#set ($entityRelations = $entity.allEntityRelations)
#if (!$entityRelations.empty)

    // --------- Relationship Definitions -----------
    
#**##foreach ($associationEnd in  $entityRelations)
#*  *##set ($target = $associationEnd.otherEnd)
#*  *##if ($target.navigable)
    private $target.getterSetterTypeName ${target.name};
#*  *##end
#**##end
#end
#if (!$entityRelations.empty)

    // ---- Manageable Display Attributes (Transient) -----
    
##
## For manageable entities where the display attribute differs from identifier
## we need to specify a labels attribute which is transient (specified by annotation)
## on getter.  A display attribute differs from the identifier if modelled by
## the Unique stereotype.
##
#**##foreach ($associationEnd in  $entityRelations)
#*  *##set ($target = $associationEnd.otherEnd)
#*  *##if ($target.navigable)
#*    *##if ($target.type.manageable && $target.type.manageableDisplayAttribute.name != $target.type.identifer.name)
#*      *##if ($target.many)
    private java.util.Collection<${target.type.manageableDisplayAttribute.type.fullyQualifiedName}> ${target.labelName};        		// Manageable display attribute
#*      *##else
    private $target.type.manageableDisplayAttribute.type.fullyQualifiedName ${target.labelName};       // Manageable display attribute
#*      *##end
#*    *##end
#*  *##end
#**##end

#end
    // --------------- Constructors -----------------
    
    /**
     * Default empty constructor
     */
    public #if ($entity.entityImplementationRequired || $entity.embeddableSuperclass)${entity.entityEmbeddableName}#else${entity.entityName}#end()
    { 
        // default null constructor
    }
    
## Autogenerate a constructor implementation with all attributes.
#set ($allAttributes = $transform.filterByVisibility($entity.allInstanceAttributes, "public"))
#set ($inheritedAttributes = $transform.filterByVisibility($entity.inheritedInstanceAttributes, "public"))
#set ($instanceAttributes = $transform.filterByVisibility($entity.instanceAttributes, "public"))
#if ($entity.syntheticCreateMethodAllowed && !$transform.filterUpdatableAttributes($allAttributes, $entity.compositePrimaryKeyPresent).empty)
    /**
     * Implementation for the constructor with all POJO attributes except auto incremented identifiers.
     * This method sets all POJO fields defined in this class to the values provided by 
     * the parameters.
     *
#**##foreach($attribute in $transform.filterUpdatableAttributes($allAttributes, $entity.compositePrimaryKeyPresent))
     * @param $attribute.name Value for the ${attribute.name} property
#**##end
     */
    public #if ($entity.entityImplementationRequired || $entity.embeddableSuperclass)${entity.entityEmbeddableName}#else${entity.entityName}#end($entity.getAttributesAsList($allAttributes, true, true, false)) 
    {
#**##if(!$inheritedAttributes.empty)
        super($entity.getAttributesAsList($inheritedAttributes, false, true, false));
#**##end
#**##foreach ($attribute in $transform.filterUpdatableAttributes($instanceAttributes, $entity.compositePrimaryKeyPresent))
        ${attribute.setterName}(${attribute.name});
#**##end
    }
#end

#set ($relations = $entity.allEntityRelations)
#if (!$relations.empty)
#**##if ($entity.syntheticCreateMethodAllowed)
    /**
     * Constructor with all POJO attribute values and CMR relations.
     *
#*  *##foreach($attribute in $transform.filterUpdatableAttributes($allAttributes, $entity.compositePrimaryKeyPresent))
     * @param $attribute.name Value for the ${attribute.name} property
#*  *##end
#*  *##foreach ($relation in $relations)
     * @param $relation.otherEnd.name Value for the ${relation.otherEnd.name} relation role
#*  *##end
     */
    public #if ($entity.entityImplementationRequired || $entity.embeddableSuperclass)${entity.entityEmbeddableName}#else${entity.entityName}#end($entity.getAttributesAsList($allAttributes, true, true, false)#if(!$allAttributes.empty), #end#foreach ($relation in $relations)${relation.otherEnd.getterSetterTypeName} $relation.otherEnd.name#if($velocityCount != $relations.size()), #end#end)
    {
#*  *##foreach ($attribute in $transform.filterUpdatableAttributes($instanceAttributes, $entity.compositePrimaryKeyPresent))
        ${attribute.setterName}(${attribute.name});
#*  *##end
        
        // Set the CMR relations
#*  *##foreach ($relation in $relations)
        ${relation.otherEnd.setterName}($relation.otherEnd.name);
#*  *##end
    }
#**##end
#end

#foreach ($operation in $entity.getCreateMethods(true))
#**##set ($opArguments = $transform.getArgumentsAsList(${operation.argumentNames}))
    /**
     * Explicitly defined constuctor with specified args list.
$operation.getDocumentation("    * ")
#**##foreach($attribute in $opArguments)
     * @param $attribute Value for the $attribute property
#**##end
     */
    public #if ($entity.entityImplementationRequired || $entity.embeddableSuperclass)${entity.entityEmbeddableName}#else${entity.entityName}#end(${operation.typedArgumentList}) 
    {
#**##foreach($attribute in $opArguments)
        this.${attribute} = $attribute;
#**##end
    }
    
#end
#if ($entity.compositePrimaryKeyPresent)
    /**
     * Constructor with composite primary key arg only
     *
     * @param pk Composite primary key
     */
    public #if ($entity.entityImplementationRequired || $entity.embeddableSuperclass)${entity.entityEmbeddableName}#else${entity.entityName}#end(${entity.fullyQualifiedEntityCompositePrimaryKeyName} pk)
    {
        this.pk = pk;
    }
    
#end
#if (!$constants.empty)

    // --------- Constant Accessors ----------
    
#**##foreach($constant in $constants)
    /**
     * Get the <code>$constant.name</code> constant
$constant.getDocumentation("     * ")
     */
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}()
    {
        return $constant.name;
    }
    
#**##end
#end
#if ($entity.compositePrimaryKeyPresent)

    // ----- Composite PK Accessors ------

    /**
     * Return the composite primary key for ${entity.entityName}
     *
     * @return The composite primary key
     */
    @javax.persistence.EmbeddedId
#**##set ($identifiers = $entity.getIdentifiers())
#**##if (!$identifiers.empty)
    @javax.persistence.AttributeOverrides
    ({
#*  *##foreach ($attribute in $identifiers)
        @javax.persistence.AttributeOverride(name = "${attribute.name}", column = @javax.persistence.Column(name = "${attribute.columnName}"#if ($attribute.unique), unique = ${attribute.unique}#end#if (!$attribute.columnNullable), nullable = ${attribute.columnNullable}#end#if ($attribute.columnLength), length = ${attribute.columnLength}#end#if ($attribute.columnDefinition), columnDefinition = "${attribute.columnDefinition}"#end#if ($attribute.columnPrecision), precision = ${attribute.columnPrecision}#end#if ($attribute.columnScale), scale = ${attribute.columnScale}#end))#if($velocityCount != $identifiers.size()),#end
        
#*  *##end
    })
#**##end
    public ${entity.fullyQualifiedEntityCompositePrimaryKeyName} getPk()
    {
        return this.pk;
    }
    
    /**
     * Set the composite primary key for ${entity.entityName}
     *
     * @param pk The composite primary key
     */
    public void setPk(${entity.fullyQualifiedEntityCompositePrimaryKeyName} pk)
    {
        this.pk = pk;
    }
    
#end
#if (!$attributes.empty)

    // -------- Attribute Accessors ----------

#**##foreach ($attribute in $attributes)
##
## Only include accessors for identifier attributes if entity does not 
## have a composite primary key
##
#*  *##if ($entity.compositePrimaryKeyPresent && $attribute.identifier)
#*    *##set ($doAttributeAccessors = false)
#*  *##else
#*    *##set ($doAttributeAccessors = true)
#*  *##end
#*  *##if ($doAttributeAccessors)
#*    *##set ($visibility = $attribute.visibility)
    /**
     * Get the $attribute.name property.
$attribute.getDocumentation("     * ")
     * @return $attribute.type.fullyQualifiedName The value of ${attribute.name}
     */
##
## If attribute is transient ONLY add Transient annotation
##
#*    *##if ($attribute.transient)
    @javax.persistence.Transient
#*    *##else
#*      *##if ($attribute.identifier)
    @javax.persistence.Id
#*        *##if ($attribute.sequenceGeneratorType)
    @javax.persistence.SequenceGenerator(name = "${attribute.generatorName}"#if ($attribute.sequenceGeneratorType), sequenceName = "${attribute.generatorSourceName}"#end#if ($attribute.sequenceGeneratorType), initialValue = ${attribute.generatorInitialValue}#end#if ($attribute.generatorAllocationSize), allocationSize = ${attribute.generatorAllocationSize}#end)
#*        *##elseif ($attribute.tableGeneratorType)
    @javax.persistence.TableGenerator(name = "${attribute.generatorName}"#if ($attribute.tableGeneratorType), table = "${attribute.generatorSourceName}"#end#if ($attribute.generatorPkColumnValue), pkColumnValue = "${attribute.generatorPkColumnValue}"#end#if ($attribute.generatorInitialValue), initialValue = ${attribute.generatorInitialValue}#end#if ($attribute.generatorAllocationSize), allocationSize = ${attribute.generatorAllocationSize}#end)
#*        *##end
#*        *##if (!$attribute.generatorTypeNone)
    @javax.persistence.GeneratedValue(strategy = javax.persistence.GenerationType.${attribute.generatorType}#if ($attribute.sequenceGeneratorType || $attribute.tableGeneratorType), generator = "${attribute.generatorName}"#end)
#*        *##end
#*      *##end
#*      *##if ($attribute.version)
    @javax.persistence.Version
#*      *##end
#*      *##if ($attribute.lob)
##
## Add if LOB type is specified - do not set LOB type as of PFD Spec - inferred from type.
## Also sepcify Fetch type in Basic annotation if set to EAGER since 
## default fetch type for LOB annotation is LAZY.
##
    @javax.persistence.Lob
#*        *##if ($attribute.eager)
    @javax.persistence.Basic(fetch = javax.persistence.FetchType.EAGER)
#*        *##end
#*      *##end
#*      *##if ($attribute.containsEmbeddedObject)
    @javax.persistence.Embedded
    @javax.persistence.AttributeOverrides
    ({
#*        *##foreach ($embeddedAttribute in $attribute.type.attributes)
        @javax.persistence.AttributeOverride(name = "${embeddedAttribute.name}", column = @javax.persistence.Column(name = "${embeddedAttribute.columnName}"#if ($embeddedAttribute.unique), unique = ${embeddedAttribute.unique}#end#if (!$embeddedAttribute.columnNullable), nullable = ${embeddedAttribute.columnNullable}#end#**#, insertable = ${embeddedAttribute.insertEnabled}, updatable = ${embeddedAttribute.updateEnabled}#if ($embeddedAttribute.columnLength), length = ${embeddedAttribute.columnLength}#end#if ($embeddedAttribute.columnDefinition), columnDefinition = "${embeddedAttribute.columnDefinition}"#end#if ($embeddedAttribute.columnPrecision), precision = ${embeddedAttribute.columnPrecision}#end#if ($embeddedAttribute.columnScale), scale = ${embeddedAttribute.columnScale}#end))#if($velocityCount != $attribute.type.attributes.size()),#end

#*        *##end
    })
#*      *##else
    @javax.persistence.Column(name = "${attribute.columnName}"#if ($attribute.unique), unique = ${attribute.unique}#end#if (!$attribute.columnNullable), nullable = ${attribute.columnNullable}#end#**#, insertable = ${attribute.insertEnabled}, updatable = ${attribute.updateEnabled}#if ($attribute.columnLength), length = ${attribute.columnLength}#end#if ($attribute.columnDefinition), columnDefinition = "${attribute.columnDefinition}"#end#if ($attribute.columnPrecision), precision = ${attribute.columnPrecision}#end#if ($attribute.columnScale), scale = ${attribute.columnScale}#end)
#*      *##end
#*      *##if (!$attribute.lob && $attribute.lazy)
##
## Only add the fetch type property for LAZY hints - default is EAGER
##
    @javax.persistence.Basic(fetch = javax.persistence.FetchType.LAZY)
#*      *##end
#*      *##if ($stringUtils.isNotBlank($attribute.temporalType))
    @javax.persistence.Temporal(javax.persistence.TemporalType.${attribute.temporalType})
#*      *##end
#*      *##if ($stringUtils.isNotBlank($attribute.enumerationType))
    @javax.persistence.Enumerated(javax.persistence.EnumType.${attribute.enumerationType})
#*      *##end
#*    *##end
##
## Override attribute type if attribute is a LOB and lob type is specified
##
    public #if ($stringUtils.isNotBlank($attribute.lobType))${attribute.lobType}#else${attribute.type.fullyQualifiedName}#end ${attribute.getterName}()
    {
        return $attribute.name;
    }

##
## Allow only if attribute is not a version attribute since they are 
## set by the container - No setter method is made available.
##
    /**
     * Set the $attribute.name property.
     * @param value the new value
     */
   #if (!$attribute.version) public#else protected#end void ${attribute.setterName}(#if ($stringUtils.isNotBlank($attribute.lobType))${attribute.lobType}#else${attribute.type.fullyQualifiedName}#end value)
    {
        this.${attribute.name} = value;
    }
    
#*  *##end
#**##end
#end

    // ------------- Relations ------------------

#foreach ($associationEnd in $entity.allEntityRelations)
#**##set ($target = $associationEnd.otherEnd)
#**##if($target.navigable)
#*  *##if ($associationEnd.many2One)
##
## MANY TO ONE RELATIONSHIP
##
## Default fetch type: EAGER
## Has optional feature
##
    /**
     * Get the ${target.name}
     *
     * @return $target.getterSetterTypeName
     */
##
## If target association is transient ONLY add Transient annotation
##
#*    *##if ($target.transient)
    @javax.persistence.Transient
#*    *##else
#*      *##set ($argExists = false)
    @javax.persistence.ManyToOne(#if (!$target.optional)optional = false#set ($argExists = true)#end#if ($target.cascadeType)#if ($argExists), #end#**#cascade = {${target.cascadeType}}#set ($argExists = true)#end#if ($target.lazy)#if ($argExists), #end#**#fetch = javax.persistence.FetchType.LAZY#end)
##
## Add the JoinColumns annotation if the target entity has a composite primary key
## Otherwise add the JoinColumn annotation.
##
#*      *##if (!$target.type.compositePrimaryKeyPresent)
    @javax.persistence.JoinColumn(name = "$stringUtils.upperCase(${target.name})"#if ($associationEnd.columnDefinition), columnDefinition = "${associationEnd.columnDefinition}"#end)
#*      *##else
#*        *##set ($identifiers = $target.type.getIdentifiers())
    @javax.persistence.JoinColumns
    ({
#*        *##foreach ($attribute in $identifiers)
        @javax.persistence.JoinColumn(name = "$stringUtils.upperCase(${target.name})_${attribute.columnName}", referencedColumnName = "${attribute.columnName}")#if($velocityCount != $identifiers.size()),#end
        
#*        *##end
    })
#*      *##end
#*    *##end
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

#*    *##if(!$target.readOnly)
   /**
    * Set the ${target.name}
    *
    * @param ${target.name}
    */
    public void ${target.setterName}($target.getterSetterTypeName ${target.name})
    {
        this.${target.name} = ${target.name};
    }
    
#*    *##end
#*  *##elseif ($associationEnd.one2Many)
##
## ONE TO MANY RELATIONSHIP
##
## Include the mappedBy element for bidirection relationships ONLY
## Default fetch type: LAZY
## If orderBy element is not specified, container assumes PK ordering
##
    /**
     * Get the ${target.name} Collection
     *
     * @return $target.getterSetterTypeName
     */
##
## If target association is transient ONLY add Transient annotation
##
#*    *##if ($target.transient)
    @javax.persistence.Transient
#*    *##else
#*      *##set ($argExists = false)
    @javax.persistence.OneToMany(#if ($target.cascadeType)cascade = {${target.cascadeType}}#set ($argExists = true)#end#if ($associationEnd.navigable)#if ($argExists) ,#end#**#mappedBy = "${associationEnd.name}"#set ($argExists = true)#end#if ($target.eager)#if ($argExists), #end#**#fetch = javax.persistence.FetchType.EAGER#end)
#*      *##if ($target.hasTaggedValue("@andromda.persistence.orderBy"))
#*        *##if ($stringUtils.isNotEmpty(${target.orderByClause}))
    @javax.persistence.OrderBy("${target.orderByClause}")
#*        *##else
    @javax.persistence.OrderBy
#*        *##end
#*      *##end
#*      *##if ($target.associationCacheEnabled)
    @org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.${target.cacheType})
#*      *##end
#*    *##end
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }
    
    /**
     * Set the ${target.name}
     *
     * @param ${target.name}
     */
    public void ${target.setterName} (${target.getterSetterTypeName} ${target.name})
    {
        this.${target.name} = ${target.name};
    }
    
#*  *##elseif ($associationEnd.one2One)
##
## ONE TO ONE RELATIONSHIP
##
## Default fetch type: EAGER
## Add the optional feature on the owning side of a One-to-One relationship
##
    /**
     * Get the ${target.name}
     *
     * @return $target.getterSetterTypeName
     */
##
## If target association is transient ONLY add Transient annotation
##
#*    *##if ($target.transient)
    @javax.persistence.Transient
#*    *##else
#*      *##set ($argExists = false)
    @javax.persistence.OneToOne(#if($associationEnd.owning)#if (!$target.optional)optional = false#set ($argExists = true)#end#end#if ($target.cascadeType)#if ($argExists), #end#**#cascade = {${target.cascadeType}}#set ($argExists = true)#end#if(!$associationEnd.owning)#if ($argExists), #end#**#mappedBy = "${associationEnd.name}"#set ($argExists = true)#end#if ($target.lazy)#if ($argExists), #end#**#fetch = javax.persistence.FetchType.LAZY#end)
#*      *##if($associationEnd.owning)
##
## Add the JoinColumns annotation if the target entity has a composite primary key
## Otherwise add the JoinColumn annotation.
##
#*        *##if (!$target.type.compositePrimaryKeyPresent)
    @javax.persistence.JoinColumn(name = "$stringUtils.upperCase(${target.name})"#if ($associationEnd.columnDefinition), columnDefinition = "${associationEnd.columnDefinition}"#end)
#*        *##else
#*          *##set ($identifiers = $target.type.getIdentifiers())
    @javax.persistence.JoinColumns
    ({
#*          *##foreach ($attribute in $identifiers)
        @javax.persistence.JoinColumn(name = "$stringUtils.upperCase(${target.name})_${attribute.columnName}", referencedColumnName = "${attribute.columnName}")#if($velocityCount != $identifiers.size()),#end
        
#*          *##end
    })
#*        *##end
#*      *##end
#*    *##end
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

#*    *##if(!$target.readOnly)
   /**
    * Set the ${target.name}
    *
    * @param ${target.name}
    */
    public void ${target.setterName}($target.getterSetterTypeName ${target.name})
    {
        this.${target.name} = ${target.name};
    }
    
#*    *##end
#*  *##elseif ($associationEnd.many2Many)
##
## MANY TO MANY RELATIONSHIP
##
## Default fetch type: LAZY
##
    /**
     * Get the ${target.name} Collection
     *
     * @return $target.getterSetterTypeName
     */
##
## If target association is transient ONLY add Transient annotation
##
#*    *##if ($target.transient)
    @javax.persistence.Transient
#*    *##else
#*      *##set ($argExists = false)
    @javax.persistence.ManyToMany(#if ($target.cascadeType)cascade = {${target.cascadeType}}#set ($argExists = true)#end#if(!$associationEnd.owning)#if ($argExists), #end#**#mappedBy = "${associationEnd.name}"#set ($argExists = true)#end#if ($target.eager)#if ($argExists), #end#**#fetch = javax.persistence.FetchType.EAGER#end)
## Use Aggregation and Composition to determine owning side
#*      *##if (${associationEnd.association.tableName})
#*        *##if($associationEnd.owning)
##
## Add the JoinTable annotation on the owning side
##
    @javax.persistence.JoinTable
    (
        name = "${associationEnd.association.tableName}",
        joinColumns = {#set ($identifiers = $entity.getIdentifiers())#foreach ($attribute in $identifiers)@javax.persistence.JoinColumn(name = "${attribute.columnName}")#if($velocityCount != $identifiers.size()), #end#end#**#},
        inverseJoinColumns = {#set ($identifiers = $target.type.getIdentifiers())#foreach ($attribute in $identifiers)@javax.persistence.JoinColumn(name = "${attribute.columnName}")#if($velocityCount != $identifiers.size()), #end#end#**#}
    )
#*        *##end
#*      *##end
#*      *##if ($target.hasTaggedValue("@andromda.persistence.orderBy"))
#*        *##if ($stringUtils.isNotEmpty(${target.orderByClause}))
    @javax.persistence.OrderBy("${target.orderByClause}")
#*        *##else
    @javax.persistence.OrderBy
#*        *##end
#*      *##end
#*      *##if ($target.associationCacheEnabled)
    @org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.${target.cacheType})
#*      *##end
#*    *##end
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }
    
    /**
     * Set the ${target.name}
     *
     * @param ${target.name}
     */
    public void ${target.setterName} (${target.getterSetterTypeName} ${target.name})
    {
        this.${target.name} = ${target.name};
    }
    
#*  *##end
#**##end
#end
#foreach ($associationEnd in $entity.allEntityRelations)
#**##set ($target = $associationEnd.otherEnd)
#**##if($target.navigable)
##
## For manageable entities where the display attribute differs from identifier
## we need to specify a labels attribute which is transient (specified by annotation)
## on getter.  A display attribute differs from the identifier if modelled by
## the Unique stereotype.
##
#*  *##if ($target.type.manageable && $target.type.manageableDisplayAttribute.name != $target.type.identifer.name)
#*    *##if ($velocityCount == 1)
    // -------- Manageable Attribute Display -----------
    
#*    *##end
    /**
     * Get the ${target.labelName}
     *
     * @return #if ($target.many)java.util.Collection<${target.type.manageableDisplayAttribute.type.fullyQualifiedName}>#else${target.type.manageableDisplayAttribute.type.fullyQualifiedName}#end
     
     */
    @javax.persistence.Transient
    public #if ($target.many)java.util.Collection<${target.type.manageableDisplayAttribute.type.fullyQualifiedName}>#else${target.type.manageableDisplayAttribute.type.fullyQualifiedName}#end ${target.getterLabelName}()
    {
        return this.${target.labelName};
    }
    
    /**
     * Set the ${target.labelName}
     *
     * @param ${target.labelName}
     */
    public void ${target.setterLabelName} (#if ($target.many)java.util.Collection<${target.type.manageableDisplayAttribute.type.fullyQualifiedName}>#else${target.type.manageableDisplayAttribute.type.fullyQualifiedName}#end ${target.labelName})
    {
        this.${target.labelName} = ${target.labelName};
    }
    
#*  *##end
#**##end
#end
}