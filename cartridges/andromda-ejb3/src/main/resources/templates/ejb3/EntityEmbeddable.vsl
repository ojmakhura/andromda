#if ($umlUtils.shouldOutput($entity))
#parse("templates/ejb3/Globals.vm")
// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by EntityEmbeddable.vsl in andromda-ejb3-cartridge on $umlUtils.date.
//
#if ($stringUtils.isNotBlank($entity.packageName))
package $entity.packageName;
#end
##
## If the entity is in the middle of an inheritance hierarchy
## it cannot be:
##
## 1. an embeddable superclass
## 2. an abstract class
##
##
## If the entity is explicitly defined as a mapped superclass then use the standard entity name
## If explicit business operations are modelled on the entity, then the entity naming convention differs
## All other entities have the standard entity name
##
#if ($entity.entityImplementationRequired)
#set ($generatedFile = "${stringUtils.replace($entity.fullyQualifiedEntityEmbeddableName,'.','/')}.java")
#else
#set ($generatedFile = "${stringUtils.replace($entity.fullyQualifiedEntityName,'.','/')}.java")
#end

#set ($identifier = $entity.identifier)
/**
$entity.getDocumentation(" * ")
 *
 * Autogenerated POJO EJB#if ($entity.entityImplementationRequired || $entity.embeddableSuperclass) mapped super#end class for ${entity.entityName} containing the
 * bulk of the entity implementation.
 *
 * This is#if ($entity.entityImplementationRequired || $entity.embeddableSuperclass) a mapped super class and#end autogenerated by AndroMDA using the EJB3
 * cartridge.
 *
 * DO NOT MODIFY this class.
 */
##
## Only set the Entity annotation if it is explicitly defined as an embeddable super class
## or business operations exist(implementation is required).
##
#if ($entity.entityImplementationRequired || $entity.embeddableSuperclass)
@jakarta.persistence.MappedSuperclass
#else
@jakarta.persistence.Entity
#**##if ($entity.seamComponent)
/**
 * Use components.xml to define Seam components
 * @org.jboss.seam.annotations.Name("${entity.seamComponentName}")
 */
#*  *##if ($stringUtils.isNotBlank($entity.seamComponentScopeType))
/**
 * Use components.xml to define Seam component scope type
 * @org.jboss.seam.annotations.Scope(org.jboss.seam.ScopeType.${entity.seamComponentScopeType})
 */
#*  *##end
#**##end
##
## Include the Table annotation for a base class in single table inheritence hierarchy
## but not in the subclasses, regardless of multiple levels in the inhiertance hierarchy.
##
## Include in all classes for joined and table per class
## inheritance hierarchies.
##
## If a class is manually specified as an embeddable superclass, add
## the Table annotation to the subclass, not to the base superclass.
##
#**##if (!$entity.entityImplementationRequired && (($entity.requiresSpecializationMapping && !$entity.requiresGeneralizationMapping) || !$entity.requiresGeneralizationMapping || ($entity.requiresGeneralizationMapping && ($entity.embeddableSuperclassGeneralizationExists || $entity.inheritanceTablePerClass || $entity.inheritanceJoined))))
## TODO: For all non PK fields Add: @Table uniqueConstraints=@jakarta.persistence.UniqueConstraint(name="unique_constraint_name", columnNames="A_NAME")
@jakarta.persistence.Table(name="${entity.tableName}")
#**##end
#**##if ($entity.listenerEnabled)
@jakarta.persistence.EntityListeners({${entity.fullyQualifiedEntityListenerName}.class})
#**##end
##
## Only include the inheritance related annotations for inheritance mapping
## that doesn't involve embeddable superclass hierarchy.
##
## Only include the inheritance and discriminator column mapping for the top level class
## in the hierarchy, regardless of the number of levels in the hierarchy.
##
#**##if ($entity.requiresSpecializationMapping && !$entity.requiresGeneralizationMapping)
@jakarta.persistence.Inheritance(strategy=jakarta.persistence.InheritanceType.${entity.inheritanceStrategy})
##
## Discriminator components only apply to single table mapping strategy
##
#*  *##if ($entity.inheritanceSingleTable)
#*    *##set ($argExists = false)
@jakarta.persistence.DiscriminatorColumn(#if ($entity.discriminatorColumn)name="${entity.discriminatorColumn}"#set ($argExists = true)#end#if ($entity.discriminatorType)#if ($argExists), #end#**#discriminatorType=jakarta.persistence.DiscriminatorType.${entity.discriminatorType}#set ($argExists = true)#end#if ($entity.discriminatorColumnDefinition)#if ($argExists), #end#**#columnDefinition="${entity.discriminatorColumnDefinition}"#set ($argExists = true)#end#if ($entity.discriminatorLength > 0)#if ($argExists), #end#**#length=${entity.discriminatorLength}#end)
@jakarta.persistence.DiscriminatorValue("${entity.discriminatorValue}")
#*  *##end
#**##elseif ($entity.requiresGeneralizationMapping && $entity.inheritanceSingleTable && !$entity.embeddableSuperclassGeneralizationExists)
##
## Only include the DiscriminatorValue annotation for subclasses if
## the inheritance strategy is single table mapping strategy.
##
@jakarta.persistence.DiscriminatorValue("${entity.discriminatorValue}")
#**##end
#**##if ($hibernateExtensionEnabled && $entity.cacheEnabled)
@org.hibernate.annotations.Cache(usage=org.hibernate.annotations.CacheConcurrencyStrategy.${entity.cacheType})
#**##end
##
## If super class is a mapped superclass, then include named queries from it
##
#**##if ($entity.embeddableSuperclassGeneralizationExists)
#*  *##set ($finders = $entity.getQueryOperations(true))
#**##else
#*  *##set ($finders = $entity.getQueryOperations(false))
#**##end
#set ($entityIdVariable = $stringUtils.uncapitalize($entity.name).substring(0,1))
#**##if (!$finders.empty)
@jakarta.persistence.NamedQueries
({
#*  *##if ($entity.genericFinders && !$entity.finderFindAllExists)
    @jakarta.persistence.NamedQuery(name="${entity.name}.findAll", query="SELECT $entityIdVariable FROM ${entity.name} AS $entityIdVariable")#if (!$finders.empty),#end

#*  *##end
#*  *##foreach ($finder in $finders)
    @jakarta.persistence.NamedQuery(name="${entity.name}.${finder.name}", query="${finder.query}")#if($velocityCount != $finders.size()), #end

#*  *##end
})
#**##else
#*  *##if ($entity.genericFinders)
@jakarta.persistence.NamedQuery(name="${entity.name}.findAll", query="SELECT $entityIdVariable FROM ${entity.name} AS $entityIdVariable")#if (!$finders.empty),#end

#*  *##end
#**##end
#end
public#if ($entity.entityImplementationRequired) abstract class ${entity.entityEmbeddableName}#else#if($entity.abstract) abstract#end class ${entity.entityName}#end

#if($entity.requiresGeneralizationMapping)
#**##if($entity.embeddableSuperclassGeneralizationExists && $entity.generalization.entityImplementationRequired)
    extends ${entity.generalization.fullyQualifiedEntityEmbeddableName}
#**##else
    extends ${entity.generalization.fullyQualifiedName}
#**##end
#elseif ($entity.generalization)
    extends ${entity.generalization.fullyQualifiedName}
#end
#foreach($general in $entity.allGeneralizations)
#if ($general.name.equals("AbstractEntity") || $general.name.equals("AuditedEntity") || $general.name.equals("AbstractVersionedEntity") || $general.name.equals("AbstractAuditedVersionedEntity") || $general.name.startsWith("AbstractPersistent"))
#set ($jpaFramework=true)
#end
#end
##    // $entity.generalization $entity.generalization.fullyQualifiedName $entity.generalization.name $jpaFramework
##
## Do not implement Comparable for (implicit or explicitly defined) mapped superclass
## or for a subclass in an inheritance hierarchy.
##
    implements java.io.Serializable#if (!$entity.entityImplementationRequired && !$entity.embeddableSuperclass && !$entity.requiresGeneralizationMapping && !$jpaFramework), Comparable<${entity.entityName}>#end## no newline
#if (!$entity.interfaceAbstractions.empty)
, $entity.implementedInterfaceList
#end
#if ($jpaFramework)
, com.wdpr.jpa.simple.services.GenericCRUDService.GenericallyCRUDable<$entity.name>
#end
{
    private static final long serialVersionUID = ${entity.serialVersionUID}L;
#set ($constants = $entity.getConstants(true))
#if (!$constants.empty)

    // ----------- $constants.size() Constant Definitions -------------
#**##foreach ($constant in $constants)
    @jakarta.persistence.Transient
    public static final $constant.type.fullyQualifiedName $constant.name = $constant.defaultValue;

#**##end
#end
## Composite PK may be an identifier on an association
##
#**##if ($entity.compositePrimaryKeyPresent)
    protected ${entity.fullyQualifiedEntityCompositePrimaryKeyName} pk;
#**##end
##
## Only declare instance attributes that are NOT inherited.
## If a mapped superclass then don't generate auto identifier - but include
## normal defined identifier if one is defined.
##
#if ($entity.embeddableSuperclass && $entity.dynamicIdentifiersPresent)
#**##set ($attributes = $entity.getInstanceAttributes(false, false))
##    // embeddable attributes: $attributes
#else
#**##set ($attributes = $entity.getInstanceAttributes(false, true))
#end
#if (!$attributes.empty)

    // ----------- $attributes.size() Attribute Definitions ------------
## Only include identifier attributes if a composite primary key is NOT present
##
##    // $attributes.size() $attributes
#**##foreach ($attribute in $attributes)
#*  *##if ($entity.compositePrimaryKeyPresent && $attribute.identifier)
#*    *##set ($doAttribute = false)
#*  *##else
#*    *##set ($doAttribute = true)
#*  *##end
##    // $attribute.fullyQualifiedName $attribute.identifier $attribute.owner ${attribute.getterSetterTypeName} $doAttribute
#*  *##if ($doAttribute)
##
## Check for overriding LOB type
## If the attribute is used in optimistic locking, make public, otherwise make protected
##
    #if (!$attribute.transient && $attribute.version)public#else#**#protected#end #if ($stringUtils.isNotBlank($attribute.lobType))${attribute.lobType}#else${attribute.getterSetterTypeName}#end $attribute.name;
#*  *##end
#**##end
#end
#set ($entityRelations = $entity.allEntityRelations)
#if (!$entityRelations.empty)

    // --------- $entityRelations.size() Relationship Definitions -----------
#**##foreach ($associationEnd in  $entityRelations)
#*  *##set ($target = $associationEnd.otherEnd)
##if ($target.navigable && (!$target.hasStereotype("Identifier") || !$entity.compositePrimaryKeyPresent))
##    // $target.name $target.getterSetterTypeName id=$target.hasStereotype("Identifier") pk=$entity.compositePrimaryKeyPresent nav=$target.navigable
#*  *##if ($target.navigable)
#*    *##if ($target.many)
    protected $target.getterSetterTypeName $target.name = new ${umlUtils.getImplCollection($target.getterSetterTypeName)}();
#*    *##elseif (!$target.hasStereotype("Identifier") || !$entity.compositePrimaryKeyPresent)
    protected $target.getterSetterTypeName $target.name;
#*    *##end
#*  *##end
#**##end
#end
#if (!$entityRelations.empty)

    // ---- Manageable Display Attributes (Transient) -----
##
## For manageable entities where the display attribute differs from identifier
## we need to specify a labels attribute which is transient (specified by annotation)
## on getter.  A display attribute differs from the identifier if modelled by
## the Unique stereotype.
##
#**##foreach ($associationEnd in  $entityRelations)
#*  *##set ($target = $associationEnd.otherEnd)
#*  *##if ($target.navigable)
#*    *##if ($target.type.manageable && $target.type.manageableDisplayAttribute.name != $target.type.identifier.name)
#*      *##if ($target.many)
    protected java.util.Collection<${target.type.manageableDisplayAttribute.type.fullyQualifiedName}> ${target.labelName};    // Manageable display attribute
#*      *##else
    protected $target.type.manageableDisplayAttribute.type.fullyQualifiedName ${target.labelName};    // Manageable display attribute
#*      *##end
#*    *##end
#*  *##end
#**##end
#end
#if (!$constants.empty)

    // --------- $constants.size() Constant Accessors ----------
#**##foreach($constant in $constants)
    /**
$constant.getDocumentation("     * ")
     * Get the <code>$constant.name</code> constant
     * @return $constant.type.fullyQualifiedName
     */
    $constant.visibility $constant.type.fullyQualifiedName ${constant.getterName}()
    {
        return this.$constant.name;
    }
#**##end
#end
#if ($entity.compositePrimaryKeyPresent)

    // ----- Composite PK Accessors ------
    /**
     * Return the composite primary key for ${entity.entityName}
     * @return The composite primary key
     */
    @jakarta.persistence.EmbeddedId
#**##set ($identifiers = $entity.identifiers)
#**##set ($identifierAttributes = $entityUtils.getIdentifierAttributes($entity, true))
#**##if (!$identifiers.empty)
    @jakarta.persistence.JoinColumns({
#*  *##foreach ($property in $identifierAttributes)
##foreach ($attribute in $identifiers)
##        @jakarta.persistence.JoinColumn(name="${property.columnName}"#if ($property.unique), unique=${property.unique}#end#if (!$property.columnNullable), nullable=${property.columnNullable}#end)#if($velocityCount != $identifierAttributes.size()),#end
        @jakarta.persistence.JoinColumn(name="${property.columnName}"#if (!$property.columnNullable), nullable=${property.columnNullable}#end)#if($velocityCount != $identifierAttributes.size()),#end

#*  *##end
    })
#**##end
    public ${entity.fullyQualifiedEntityCompositePrimaryKeyName} getPk()
    {
        return this.pk;
    }

    /**
     * Set the composite primary key for ${entity.entityName}
     * @param pkIn The composite primary key
     */
    public void setPk(${entity.fullyQualifiedEntityCompositePrimaryKeyName} pkIn)
    {
        this.pk = pkIn;
    }
#end
#if (!$attributes.empty)

    // -------- $attributes.size() Attribute Accessors ----------
#**##foreach ($attribute in $attributes)
##    // $attribute.fullyQualifiedName identifier=$attribute.identifier $attribute.owner.fullyQualifiedName
##
## Only include accessors for identifier attributes if entity does not
## have a composite primary key
##
#*  *##if ($entity.compositePrimaryKeyPresent && ($attribute.identifier || $attribute.owner.fullyQualifiedName!=$entity.fullyQualifiedName))
#*    *##set ($doAttributeAccessors = false)
#*  *##else
#*    *##set ($doAttributeAccessors = true)
#*  *##end
#*  *##if ($doAttributeAccessors)
#*    *##set ($visibility = $attribute.visibility)
#if ($stringUtils.isNotBlank($attribute.lobType))
#set ($typeName=$attribute.lobType)
#else
#set ($typeName=$attribute.getterSetterTypeName)
#end
    /**
$attribute.getDocumentation("     * ")
     * Get the $attribute.name property.
     * @return $typeName The value of ${attribute.name}
##     * identifier=$attribute.identifier transient=$attribute.transient version=$attribute.version lob=$attribute.lobType containsEmbeddedObject=$attribute.containsEmbeddedObject
##     * generatorType=$attribute.generatorType generatorTypeSequence=$attribute.generatorTypeSequence generatorTypeGeneric=$attribute.generatorTypeGeneric
     */
##
## If attribute is transient ONLY add Transient annotation
##
#*    *##if ($attribute.transient)
    @jakarta.persistence.Transient
#*    *##elseif (!$attribute.version)
#*      *##if ($attribute.identifier)
    @jakarta.persistence.Id
## If the identifier is owned by another entity, it can't be generated on this entity - foreign identifier type
#*        *##if ($attribute.owner.fullyQualifiedName.equals($entity.fullyQualifiedName))
#*        *##if ($attribute.generatorTypeSequence)
    @jakarta.persistence.SequenceGenerator(name="${attribute.generatorName}"#if ($attribute.generatorTypeSequence), sequenceName="${attribute.generatorSourceName}"#end#if ($attribute.generatorTypeSequence), initialValue=${attribute.generatorInitialValue}#end#if ($attribute.generatorAllocationSize), allocationSize=${attribute.generatorAllocationSize}#end)
#*        *##elseif ($attribute.generatorTypeTable)
    @jakarta.persistence.TableGenerator(name="${attribute.generatorName}"#if ($attribute.generatorTypeTable), table="${attribute.generatorSourceName}"#end#if ($attribute.generatorPkColumnValue), pkColumnValue="${attribute.generatorPkColumnValue}"#end#if ($attribute.generatorInitialValue), initialValue=${attribute.generatorInitialValue}#end#if ($attribute.generatorAllocationSize), allocationSize=${attribute.generatorAllocationSize}#end)
#*        *##end
#*        *##if (!$attribute.generatorTypeNone)
#*          *##if ($attribute.generatorTypeGeneric)
    @jakarta.persistence.GeneratedValue(generator="${attribute.generatorName}")
#*          *##else
##    @jakarta.persistence.GeneratedValue(generator="${attribute.generatorName}", strategy=jakarta.persistence.GenerationType.${attribute.generatorType})
    @jakarta.persistence.GeneratedValue(strategy=jakarta.persistence.GenerationType.${attribute.generatorType}#if ($attribute.generatorTypeSequence || $attribute.generatorTypeTable || $attribute.owner.fullyQualifiedName!=$entity.fullyQualifiedName), generator="${attribute.generatorName}"#end)
#*          *##end
#*        *##end
#*        *##if ($attribute.generatorTypeGeneric && $hibernateExtensionEnabled)
    @org.hibernate.annotations.GenericGenerator(name="${attribute.generatorName}", strategy="${attribute.generatorGenericStrategy}")
## Identifier attribute from 1:1 association identifier relationship
#*        *##elseif ($attribute.owner.fullyQualifiedName!=$entity.fullyQualifiedName)
    @org.hibernate.annotations.GenericGenerator(name="${attribute.generatorName}", strategy="foreign", parameters=@org.hibernate.annotations.Parameter(name="property", value="$stringUtils.uncapitalize($attribute.owner.name)"))
#*        *##end
#*      *##end
#*      *##end
#*      *##if ($attribute.lob)
##
## Add if LOB type is specified - do not set LOB type as of PFD Spec - inferred from type.
## Also sepcify Fetch type in Basic annotation if set to EAGER since
## default fetch type for LOB annotation is LAZY.
##
    @jakarta.persistence.Lob
#*        *##if ($attribute.eager)
    @jakarta.persistence.Basic(fetch=jakarta.persistence.FetchType.EAGER)
#*        *##end
#*      *##end
#*      *##if ($attribute.containsEmbeddedObject)
    @jakarta.persistence.Embedded
##
## Render AttributeOverrides if attributes exist on the embedded object
##
#*        *##if (!$attribute.type.attributes.empty)
    @jakarta.persistence.AttributeOverrides
    ({
#*          *##foreach ($embeddedAttribute in $attribute.type.attributes)
        @jakarta.persistence.AttributeOverride(name="${embeddedAttribute.name}", column=@jakarta.persistence.Column(name="${attribute.columnName}_${embeddedAttribute.columnName}"#if ($embeddedAttribute.unique), unique=${embeddedAttribute.unique}#end#if (!$embeddedAttribute.columnNullable), nullable=${embeddedAttribute.columnNullable}#end#**#, insertable=${embeddedAttribute.insertEnabled}, updatable=${embeddedAttribute.updateEnabled}#if ($embeddedAttribute.columnLength), length=${embeddedAttribute.columnLength}#end#if ($embeddedAttribute.columnDefinition), columnDefinition="${embeddedAttribute.columnDefinition}"#end#if ($embeddedAttribute.columnPrecision), precision=${embeddedAttribute.columnPrecision}#end#if ($embeddedAttribute.columnScale), scale=${embeddedAttribute.columnScale}#end))#if($velocityCount != $attribute.type.attributes.size()),#end

#*          *##end
    })
#*        *##end
##
## Render AssociationOverrides for embedded object if associations exist on the embedded object
##
#*        *##if (!$attribute.type.associationEnds.empty)
    @jakarta.persistence.AssociationOverrides
    ({
#*          *##foreach ($associationEnd in $attribute.type.associationEnds)
#*            *##set ($target = $associationEnd.otherEnd)
#*            *##if (!$target.type.compositePrimaryKeyPresent)
        @jakarta.persistence.AssociationOverride(name="${target.name}", joinColumns=@jakarta.persistence.JoinColumn(name="${attribute.columnName}_$stringUtils.upperCase($target.name)"#if ($associationEnd.columnDefinition), columnDefinition="${associationEnd.columnDefinition}"#end))#if($velocityCount != $attribute.type.associationEnds.size()),#end

#*            *##else
#*              *##set ($identifiers = $target.type.identifiers)
        @jakarta.persistence.AssociationOverride(name="${target.name}",
            joinColumns =
            {
#*              *##foreach ($attribute in $identifiers)
## TODO JoinColumn name doesn't make sense here, should be a column name
                @jakarta.persistence.JoinColumn(name="${attribute.columnName}_$stringUtils.upperCase($target.name)_$attribute.columnName", referencedColumnName="${attribute.columnName}")#if($velocityCount != $identifiers.size()),#end

#*              *##end
            })#if($velocityCount != $attribute.type.associationEnds.size()),#end

#*            *##end
#*          *##end
    })
#*        *##end
#*      *##else
    @jakarta.persistence.Column(name="${attribute.columnName}"#if ($attribute.unique), unique=${attribute.unique}#end#if (!$attribute.columnNullable), nullable=${attribute.columnNullable}#end#**#, insertable=${attribute.insertEnabled}, updatable=${attribute.updateEnabled}#if ($attribute.columnLength), length=${attribute.columnLength}#end#if ($attribute.columnDefinition), columnDefinition="${attribute.columnDefinition}"#end#if ($attribute.columnPrecision), precision=${attribute.columnPrecision}#end#if ($attribute.columnScale), scale=${attribute.columnScale}#end)
#*      *##end
#*      *##if (!$attribute.lob && $attribute.lazy)
##
## Only add the fetch type property for LAZY hints - default is EAGER
##
    @jakarta.persistence.Basic(fetch=jakarta.persistence.FetchType.LAZY)
#*      *##end
#*      *##if ($stringUtils.isNotBlank($attribute.temporalType))
    @jakarta.persistence.Temporal(jakarta.persistence.TemporalType.${attribute.temporalType})
#*      *##end
#*      *##if ($stringUtils.isNotBlank($attribute.enumerationType))
    @jakarta.persistence.Enumerated(jakarta.persistence.EnumType.${attribute.enumerationType})
#*      *##end
##    // nullable=$attribute.columnNullable identifier=$attribute.identifier unique=$attribute.unique lower=$attribute.lower required=$attribute.required genType=$attribute.generatorType $attribute
#*        *##if (!$attribute.columnNullable && (!$attribute.identifier || $attribute.generatorTypeNone))
    @jakarta.validation.constraints.NotNull(message="${attribute.name} is required")
#*        *##end
##set ($hibernateType = $attribute.findTaggedValue("andromda_hibernate_type"))
#*      *##if ($hibernateExtensionEnabled && $stringUtils.isNotBlank($attribute.overrideType))
    @org.hibernate.annotations.Type(type="$attribute.overrideType")
#*      *##elseif ($attribute.columnLength && $attribute.type.stringType)
    @jakarta.validation.constraints.Size(max=$attribute.columnLength)
#*      *##elseif ($attribute.columnPrecision)
    @jakarta.validation.constraints.Digits(integer=$attribute.columnPrecision, fraction =#if ($attribute.columnScale) $attribute.columnScale#else 0#end, message="${attribute.name} has a max size ($attribute.columnPrecision#if ($attribute.columnScale), $attribute.columnScale#end)")
#*      *##end
#*    *##end
#*    *##if ($attribute.version)
##
## Add the Version annotation on the attribute itself
##
    @jakarta.persistence.Version
#*    *##end
##
## Override attribute type if attribute is a LOB and lob type is specified
##
    public $typeName ${attribute.getterName}()
    {
        return this.$attribute.name;
    }

##
## Allow only if attribute is not a version attribute since they are
## set by the container - No setter method is made available.
##
    /**
$attribute.getDocumentation("     * ")
     * Set the $attribute.name property.
     * @param value the new value
     */
   #if (!$attribute.version) public#else protected#end void ${attribute.setterName}($typeName value)
    {
        this.${attribute.name} = value;
    }

#*  *##end
#**##end
#end

    // ------------- $entity.allEntityRelations.size() Relations ------------------
#foreach ($associationEnd in $entity.allEntityRelations)
#**##set ($target = $associationEnd.otherEnd)
##    // ${target.name} $target.getterSetterTypeName many2One=$associationEnd.many2One one2Many=$associationEnd.one2Many one2One=$associationEnd.one2One many2Many=$associationEnd.many2Many identifier=$associationEnd.hasStereotype("Identifier")
## Relationship is in the PK class already, if a composite identifier.
#**###if($target.navigable)
#**##if($target.navigable && (!$target.hasStereotype("Identifier") || !$entity.compositePrimaryKeyPresent))
#*  *##if ($associationEnd.many2One)
##
## MANY TO ONE RELATIONSHIP
##
## Default fetch type: EAGER
## Has optional feature
##
    /**
$target.getDocumentation("     * ")
     * Get the ${target.name}
     * @return $target.getterSetterTypeName
     */
##
## If target association is transient ONLY add Transient annotation
##
#*    *##if ($target.transient)
    @jakarta.persistence.Transient
#*    *##else
#*      *##if ($target.identifier && !$entity.compositePrimaryKeyPresent)
    @jakarta.persistence.Id
#*      *##end
#*      *##set ($argExists = false)
    @jakarta.persistence.ManyToOne(#if (!$target.optional)optional=false#set ($argExists = true)#end#if ($target.cascadeType)#if ($argExists), #end#**#cascade={${target.cascadeType}}#set ($argExists = true)#end#if ($target.lazy)#if ($argExists), #end#**#fetch=jakarta.persistence.FetchType.LAZY#end)
##
## Add the JoinColumns annotation if the target entity has a composite primary key
## Otherwise add the JoinColumn annotation.
##
#*      *##if (!$target.type.compositePrimaryKeyPresent)
##    // assocEnd=$associationEnd.fullyQualifiedName optional=$target.optional $target.insertEnabled $target.updateEnabled $associationEnd.insertEnabled $associationEnd.updateEnabled end=$associationEnd.optional target=$target.type.name assocEnd=$associationEnd.type.name
    @jakarta.persistence.JoinColumn(name="$target.columnName"#if ($associationEnd.columnDefinition), columnDefinition="$associationEnd.columnDefinition"#end#if (!$associationEnd.columnNullable), nullable=false#end, insertable=true, updatable=true)
#*      *##else
#*        *##set ($identifiers = $target.type.identifiers)
    // Order of the JoinColumns is EXTREMELY important - must match the order in the FK definition
##    // $target.type.name $target.identifier $target.type.compositePrimaryKeyPresent $target.type
    @jakarta.persistence.JoinColumns
    ({
#*        *##foreach ($attribute in $identifiers)
##        // $attribute.columnName $target.identifier $target.type.compositePrimaryKeyPresent $target.type
        @jakarta.persistence.JoinColumn(name="$associationEnd.getForeignKeyName($attribute.columnName)", referencedColumnName="${attribute.columnName}")#if($velocityCount != $identifiers.size()),#end

#*        *##end
    })
#*      *##end
#*      *##if ($hibernateExtensionEnabled)
#*        *##if ($target.hibernateCascadeExists)
##
## Set Hibernate cascade if explicitly defined
##
    @org.hibernate.annotations.Cascade({$target.hibernateCascadeType})
#*        *##end
#*        *##if ($target.foreignKeyConstraintDefined)
##
## Override the Hibernate foreign key constraint name
## Currently does not support composite PKs
##
    @org.hibernate.annotations.ForeignKey(name="$target.getForeignKeyConstraintName($target.type.identifier.columnName)")
#*        *##end
#*      *##end
#*    *##end
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

#*    *##if(!$target.readOnly)
    /**
$target.getDocumentation("     * ")
     * Set the ${target.name}
     * @param ${target.name}In
     */
    public void ${target.setterName}($target.getterSetterTypeName ${target.name}In)
    {
        this.${target.name} = ${target.name}In;
    }

#*    *##end
#*  *##elseif ($associationEnd.one2Many)
##
## ONE TO MANY RELATIONSHIP
##
## Include the mappedBy element for bidirectional relationships ONLY - uses the getter name instead of the property name (initial caps)
## Default fetch type: LAZY
## If orderBy element is not specified, container assumes PK ordering
##
    /**
$target.getDocumentation("     * ")
     * Get the ${target.name} Collection
     * @return $target.getterSetterTypeName
     */
##
## If target association is transient ONLY add Transient annotation
##
#*    *##if ($target.transient)
    @jakarta.persistence.Transient
#*    *##else
#*      *##if ($target.hasStereotype("Identifier") && !$entity.compositePrimaryKeyPresent)
    @jakarta.persistence.Id
#*      *##end
#*      *##set ($argExists = false)
##
## When the target entity is a mapped superclass AND Hibernate extensions is enabled
## then instead of the @OneToMany annotations, add the @CollectionOfElements instead.
## This is only applied when the target entity in the association is NOT an entity.
## In this situation, the target entity is a mapped superclass.
##
#*      *##if ($target.type.embeddableSuperclass && $hibernateExtensionEnabled)
    @org.hibernate.annotations.CollectionOfElements#if ($target.eager)(fetch=jakarta.persistence.FetchType.EAGER)#end

#*      *##else
##    // identifier=$target.hasStereotype("Identifier") Oid=$target.otherEnd.hasStereotype("Identifier") composite=$target.type.compositePrimaryKeyPresent $target
    @jakarta.persistence.OneToMany(#if ($target.cascadeType)cascade={${target.cascadeType}}#set ($argExists = true)#end#if ($associationEnd.navigable)#if ($argExists) ,#end#**#mappedBy="#if($target.otherEnd.hasStereotype("Identifier") && $target.type.compositePrimaryKeyPresent)pk.#end${associationEnd.name}"#set ($argExists = true)#end#if ($target.eager)#if ($argExists), #end#**#fetch=jakarta.persistence.FetchType.EAGER#end)
#*      *##end
##
## Set the JointTable annotation to limit the association table name length.
## This is only set if the relationship is unidirectional.
##
#*      *##if (!$associationEnd.navigable && $target.navigable)
    @jakarta.persistence.JoinTable
    (
        name="${associationEnd.association.tableName}",
        joinColumns={#set ($identifiers = $entity.identifiers)#foreach ($attribute in $identifiers)@jakarta.persistence.JoinColumn(name="$associationEnd.getForeignKeyName($attribute.columnName)", referencedColumnName="${attribute.columnName}")#if($velocityCount != $identifiers.size()), #end#end#**#},
        inverseJoinColumns={#set ($identifiers = $target.type.identifiers)#foreach ($attribute in $identifiers)@jakarta.persistence.JoinColumn(name="$target.getForeignKeyName($attribute.columnName)", referencedColumnName="${attribute.columnName}")#if($velocityCount != $identifiers.size()), #end#end#**#}
    )
#*      *##end
#*      *##if ($target.map)
    @jakarta.persistence.MapKey#if ($target.hasTaggedValue("andromda_persistence_collection_index"))(name="${target.collectionIndexName}")#end

#*      *##else
#*        *##if ($target.hasTaggedValue("andromda_persistence_orderBy"))
#*          *##if ($stringUtils.isNotBlank($target.orderByClause))
    @jakarta.persistence.OrderBy("$target.orderByClause")
#*          *##else
    @jakarta.persistence.OrderBy
#*          *##end
#*        *##elseif ($hibernateExtensionEnabled)
##
## Override the Hibernate foreign key constraint name
## Must define the name property.  If the constraint on the entity itself is not defined, then dont
## render the annotation at all.
##
#*          *##if ($associationEnd.owning)
#*            *##if ($associationEnd.foreignKeyConstraintDefined)
    @org.hibernate.annotations.ForeignKey(#if ($associationEnd.foreignKeyConstraintDefined)name="$associationEnd.getForeignKeyConstraintName($associationEnd.type.identifier.columnName)"#end#if ($target.foreignKeyConstraintDefined)#if ($associationEnd.foreignKeyConstraintDefined), #end#**#inverseName="$target.getForeignKeyConstraintName($target.type.identifier.columnName)"#end#**#)
#*            *##end
#*          *##end
#*          *##if ($target.list)
##
## Only add the IndexColumn annotation if Hibernate extensions is enabled
##
    @org.hibernate.annotations.IndexColumn(name="${target.collectionIndexName}")
#*          *##end
#*        *##end
#*      *##end
##
## Add the general Hibernate annotations if Hibernate extensions is enabled
##
#*      *##if ($hibernateExtensionEnabled)
#*        *##if ($target.associationCacheEnabled)
##
## Add Cache annotations if association cache and Hibernate extensions are both enabled
##
    @org.hibernate.annotations.Cache(usage=org.hibernate.annotations.CacheConcurrencyStrategy.${target.cacheType})
#*        *##end
#*        *##if ($target.collectionInterfaceSortedSet)
##
## Only add the Sort annotation if interface is SortedSet and Hibernate extentions are enabled
##
    @org.hibernate.annotations.Sort(type=org.hibernate.annotations.SortType.NATURAL)
#*        *##end
#*        *##if ($target.hibernateCascadeExists)
##
## Set Hibernate cascade if explicitly defined
##
    @org.hibernate.annotations.Cascade({$target.hibernateCascadeType})
#*        *##end
#*      *##end
#*    *##end
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

    /**
$target.getDocumentation("     * ")
     * Set the ${target.name}
     * @param ${target.name}In
     */
    public void ${target.setterName} (${target.getterSetterTypeName} ${target.name}In)
    {
        this.${target.name} = ${target.name}In;
    }

#*  *##elseif ($associationEnd.one2One)
##
## ONE TO ONE RELATIONSHIP
##
## Default fetch type: EAGER
## Add the optional feature on the owning side of a One-to-One relationship
##
    /**
$target.getDocumentation("     * ")
     * Get the ${target.name}
     * @return $target.getterSetterTypeName
##     *  target=$target $target.hasStereotype("Identifier") $associationEnd.identifier $target.identifier
     */
##
## If target association is transient ONLY add Transient annotation
##
#*    *##if ($target.transient)
    @jakarta.persistence.Transient
#*    *##else
#*      *##if ($target.identifier && !$entity.compositePrimaryKeyPresent && !$associationEnd.owning)
    @jakarta.persistence.Id
#*      *##end
#*      *##set ($argExists = false)
    @jakarta.persistence.OneToOne(#if($associationEnd.owning)#if (!$target.optional)optional=false#set ($argExists = true)#end#end#if ($target.cascadeType)#if ($argExists), #end#**#cascade={${target.cascadeType}}#set ($argExists = true)#end#if(!$associationEnd.owning)#if ($argExists), #end#**#mappedBy="#if($target.identifier && $entity.compositePrimaryKeyPresent)pk.#end${associationEnd.name}"#set ($argExists = true)#end#if ($target.lazy)#if ($argExists), #end#**#fetch=jakarta.persistence.FetchType.LAZY#end)
#*      *##if($associationEnd.owning)
##
## Add the JoinColumns annotation if the target entity has a composite primary key
## Otherwise add the JoinColumn annotation.
##
#*        *##if ($target.identifier)
    @jakarta.persistence.PrimaryKeyJoinColumn
#*        *##elseif (!$target.type.compositePrimaryKeyPresent)
    @jakarta.persistence.JoinColumn(name="${target.columnName}"#if ($associationEnd.columnDefinition), columnDefinition="${associationEnd.columnDefinition}"#end)
#*        *##else
#*          *##set ($identifiers = $target.type.identifiers)
    @jakarta.persistence.JoinColumns
    ({
#*          *##foreach ($attribute in $identifiers)
        @jakarta.persistence.JoinColumn(name="$associationEnd.getForeignKeyName($attribute.columnName)", referencedColumnName="${attribute.columnName}")#if($velocityCount != $identifiers.size()),#end

#*          *##end
    })
#*        *##end
#*      *##end
#*      *##if ($hibernateExtensionEnabled)
#*        *##if ($target.hibernateCascadeExists)
##
## Set Hibernate cascade if explicitly defined
##
    @org.hibernate.annotations.Cascade({$target.hibernateCascadeType})
#*        *##end
#*        *##if($associationEnd.owning && $target.foreignKeyConstraintDefined)
##
## Override the Hibernate foreign key constraint name
##
    @org.hibernate.annotations.ForeignKey(name="$target.getForeignKeyConstraintName($target.type.identifier.columnName)")
#*        *##end
#*      *##end
#*    *##end
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

#*    *##if(!$target.readOnly)
   /**
$target.getDocumentation("     * ")
    * Set the ${target.name}
    * @param ${target.name}In
    */
    public void ${target.setterName}($target.getterSetterTypeName ${target.name}In)
    {
        this.${target.name} = ${target.name}In;
#if($associationEnd.owning && $target.identifier)
        // Associated attribute should be set by @MapsId, but it isn't
        if (${target.name}In != null)
        {
#foreach ($identifier in $target.type.identifiers)
            ${identifier.setterName}(${target.name}In.${identifier.getterName}());
#end
        }
#end
    }

#*    *##end
#*  *##elseif ($associationEnd.many2Many)
##
## MANY TO MANY RELATIONSHIP
##
## Default fetch type: LAZY
##
    /**
$target.getDocumentation("     * ")
     * Get the ${target.name} Collection
     * @return $target.getterSetterTypeName
     */
##
## If target association is transient ONLY add Transient annotation
##
#*    *##if ($target.transient)
    @jakarta.persistence.Transient
#*    *##else
#*      *##if ($target.identifier && !$entity.compositePrimaryKeyPresent)
    @jakarta.persistence.Id
#*      *##end
#*      *##set ($argExists = false)
##
## When the target entity is a mapped superclass AND Hibernate extensions is enabled
## then instead of the @OneToMany annotations, add the @CollectionOfElements instead.
## This is only applied when the target entity in the association is NOT and entity.
## In this situation, the target entity is a mapped superclass.
##
#*      *##if ($target.type.embeddableSuperclass && $hibernateExtensionEnabled)
    @org.hibernate.annotations.CollectionOfElements#if ($target.eager)(fetch=jakarta.persistence.FetchType.EAGER)#end

#*      *##else
    @jakarta.persistence.ManyToMany(#if ($target.cascadeType)cascade={${target.cascadeType}}#set ($argExists = true)#end#if(!$associationEnd.owning)#if ($argExists), #end#**#mappedBy="#if($target.identifier && $entity.compositePrimaryKeyPresent)pk.#end${associationEnd.name}"#set ($argExists = true)#end#if ($target.eager)#if ($argExists), #end#**#fetch=jakarta.persistence.FetchType.EAGER#end)
#*      *##end
## Use Aggregation and Composition to determine owning side
#*      *##if ($associationEnd.association.tableName)
#*        *##if($associationEnd.owning)
##
## Add the JoinTable annotation on the owning side
##
    @jakarta.persistence.JoinTable
    (
        name="${associationEnd.association.tableName}",
        joinColumns={#set ($identifiers = $entity.identifiers)#foreach ($attribute in $identifiers)@jakarta.persistence.JoinColumn(name="$associationEnd.getForeignKeyName($attribute.columnName)", referencedColumnName="${attribute.columnName}")#if($velocityCount != $identifiers.size()), #end#end#**#},
        inverseJoinColumns={#set ($identifiers = $target.type.identifiers)#foreach ($attribute in $identifiers)@jakarta.persistence.JoinColumn(name="$target.getForeignKeyName($attribute.columnName)", referencedColumnName="${attribute.columnName}")#if($velocityCount != $identifiers.size()), #end#end#**#}
    )
#*        *##end
#*      *##end
#*      *##if ($target.map)
    @jakarta.persistence.MapKey#if ($target.hasTaggedValue("andromda_persistence_collection_index"))(name="${target.collectionIndexName}")#end

#*      *##else
#*        *##if ($target.hasTaggedValue("andromda_persistence_orderBy"))
#*          *##if ($stringUtils.isNotBlank($target.orderByClause))
    @jakarta.persistence.OrderBy("$target.orderByClause")
#*          *##else
    @jakarta.persistence.OrderBy
#*          *##end
#*        *##elseif ($hibernateExtensionEnabled)
##
## Only add the IndexColumn annotation if Hibernate extensions are enabled
##
#*          *##if ($target.list)
    @org.hibernate.annotations.IndexColumn(name="${target.collectionIndexName}")
#*          *##end
#*        *##end
#*      *##end
#*      *##if ($hibernateExtensionEnabled)
##
## Override the Hibernate foreign key constraint name
## Only generate the ForeignKey annotation if the constraint on the entity end is defined. The
## inverseName property cannot be defined without the name property.
##
#*        *##if($associationEnd.owning)
#*          *##if($associationEnd.foreignKeyConstraintDefined)
    @org.hibernate.annotations.ForeignKey(#if ($associationEnd.foreignKeyConstraintDefined)name="$associationEnd.getForeignKeyConstraintName($associationEnd.type.identifier.columnName)"#end#if ($target.foreignKeyConstraintDefined)#if ($associationEnd.foreignKeyConstraintDefined), #end#**#inverseName="$target.getForeignKeyConstraintName($target.type.identifier.columnName)"#end#**#)
#*          *##end
#*        *##end
#*        *##if ($target.associationCacheEnabled)
##
## Only add the Cache annotation if assocation cache and Hibernate extensions are both enabled
##
    @org.hibernate.annotations.Cache(usage=org.hibernate.annotations.CacheConcurrencyStrategy.${target.cacheType})
#*        *##end
#*        *##if ($target.collectionInterfaceSortedSet)
##
## Only add Sort annotation if collection interface is SortedSet and Hibernate extensions are enabled
##
    @org.hibernate.annotations.Sort(type=org.hibernate.annotations.SortType.NATURAL)
#*        *##end
#*        *##if ($target.hibernateCascadeExists)
##
## Set Hibernate cascade if explicitly defined
##
    @org.hibernate.annotations.Cascade({$target.hibernateCascadeType})
#*        *##end
#*      *##end
#*    *##end
    public $target.getterSetterTypeName ${target.getterName}()
    {
        return this.${target.name};
    }

    /**
$target.getDocumentation("     * ")
     * Set the ${target.name}
     * @param ${target.name}In
     */
    public void ${target.setterName} (${target.getterSetterTypeName} ${target.name}In)
    {
        this.${target.name} = ${target.name}In;
    }

#*  *##end
#**##end
#end
#foreach ($associationEnd in $entity.allEntityRelations)
#**##set ($target = $associationEnd.otherEnd)
#**##if($target.navigable)
##
## For manageable entities where the display attribute differs from identifier
## we need to specify a labels attribute which is transient (specified by annotation)
## on getter.  A display attribute differs from the identifier if modelled by
## the Unique stereotype.
##
#*  *##if ($target.type.manageable && $target.type.manageableDisplayAttribute.name != $target.type.identifier.name)
#*    *##if ($velocityCount == 1)
    // -------- Manageable Attribute Display -----------
#*    *##end
    /**
$target.getDocumentation("     * ")
     * Get the ${target.labelName}
     * @return ${target.type.manageableDisplayAttribute.getterSetterTypeName}
##     * @return #if ($target.many)java.util.Collection<${target.type.manageableDisplayAttribute.type.fullyQualifiedName}>#else${target.type.manageableDisplayAttribute.type.fullyQualifiedName}#end

     */
    @jakarta.persistence.Transient
    public ${target.type.manageableDisplayAttribute.getterSetterTypeName} ${target.getterLabelName}()
    {
        return this.${target.labelName};
    }

    /**
$target.getDocumentation("     * ")
     * Set the ${target.labelName}
     * @param ${target.labelName}In
     */
    public void ${target.setterLabelName} (${target.type.manageableDisplayAttribute.getterSetterTypeName} ${target.labelName}In)
    {
        this.${target.labelName} = ${target.labelName}In;
    }

#*  *##end
#**##end
#end
    // --------------- Constructors -----------------

    /**
     * Default empty no-arg constructor
     */
    public #if ($entity.entityImplementationRequired)${entity.entityEmbeddableName}#else${entity.entityName}#end()
    {
        // Default empty constructor
    }

## Autogenerate a constructor implementation with all updatable attributes.
#set ($allAttributes = $transform.filterByVisibility($entity.allInstanceAttributes, "public"))
##set ($inheritedAttributes = $transform.filterByVisibility($entity.inheritedInstanceAttributes, "public"))
#**##set ($updatableAttributes = $transform.filterUpdatableAttributes($allAttributes, $entity.compositePrimaryKeyPresent))
#if ($entity.syntheticCreateMethodAllowed && !$updatableAttributes.empty)
    /**
     * Constructor with all updatable Entity attributes except auto incremented identifiers.
     *
#if ($entity.compositePrimaryKeyPresent)
     * @param pk $entity.fullyQualifiedEntityCompositePrimaryKeyName The composite primary key class
#end
#**##foreach($attribute in $updatableAttributes)
     * @param $attribute.name $attribute.getterSetterTypeName value for the ${attribute.name} property required=$attribute.required lower=$attribute.lower
#**##end
     */
    public #if ($entity.entityImplementationRequired)${entity.entityEmbeddableName}#else${entity.entityName}#end($entity.getAttributesAsList($allAttributes, true, true, false))
    {
#if ($entity.compositePrimaryKeyPresent)
        setPk(pk);
#end
#**##foreach ($attribute in $updatableAttributes)
        this.$attribute.name = $attribute.name;
#**##end
    }
#end

## Autogenerate a constructor implementation with all required attributes.
##    // all=$allAttributes.size() synthetic=$entity.syntheticCreateMethodAllowed updatable=$updatableAttributes.size()
#set ($requiredAttributes = $transform.filterRequiredAttributes($allAttributes, $entity.compositePrimaryKeyPresent))
##    // all=$allAttributes.size() required=$requiredAttributes.size() updatable=$updatableAttributes.size()
##set ($updatableAttributes = $transform.filterAuditAttributes($updatableAttributes, $jpaFramework))
#if ($updatableAttributes.size()>$requiredAttributes.size() && $entity.syntheticCreateMethodAllowed && !$requiredAttributes.empty)
    /**
     * Constructor with required Entity attributes except auto incremented identifiers.
     *
#if ($entity.compositePrimaryKeyPresent)
     * @param pk $entity.fullyQualifiedEntityCompositePrimaryKeyName The composite primary key class
#end
#**##foreach($attribute in $requiredAttributes)
     * @param $attribute.name Value for the ${attribute.name} property
#**##end
     */
    public #if ($entity.entityImplementationRequired)${entity.entityEmbeddableName}#else${entity.entityName}#end($entity.getAttributesAsList($requiredAttributes, true, true, false))
    {
#if ($entity.compositePrimaryKeyPresent)
        setPk(pk);
#end
#**##foreach ($attribute in $requiredAttributes)
##if (!$jpaFramework || $attribute.name.equals("createDate") || $attribute.name.equals("createdBy") || $attribute.name.equals("updateDate") || $attribute.name.equals("updatedBy"))
        this.$attribute.name = $attribute.name;
##end
#**##end
    }
#end

#set ($relations = $entity.allEntityRelations)
#if (!$relations.empty)
#**##if ($entity.syntheticCreateMethodAllowed)
    /**
     * Constructor with all Entity attribute values and CMR relations.
     *
#if ($entity.compositePrimaryKeyPresent)
     * @param pk $entity.fullyQualifiedEntityCompositePrimaryKeyName The composite primary key class
#end
#*  *##foreach($attribute in $updatableAttributes)
     * @param $attribute.name $attribute.getterSetterTypeName value for the ${attribute.name} property
#*  *##end
#*  *##foreach ($relation in $relations)
     * @param $relation.otherEnd.name $relation.otherEnd.getterSetterTypeName value for the ${relation.otherEnd.name} relation
#*  *##end
     */
##    //  $entity.getAttributesAsList($allAttributes, true, true, false) $updatableAttributes.empty $relations.size()
#set ($attributeList = $entity.getAttributesAsList($allAttributes, true, true, false))
    public #if ($entity.entityImplementationRequired)${entity.entityEmbeddableName}#else${entity.entityName}#end($attributeList#if(!$stringUtils.isBlank($attributeList)), #end#foreach ($relation in $relations)${relation.otherEnd.getterSetterTypeName} $relation.otherEnd.name#if($velocityCount != $relations.size()), #end#end)
    {
#if ($entity.compositePrimaryKeyPresent)
        setPk(pk);
#end
#if (!$updatableAttributes.empty)
        // $updatableAttributes.size() updatableAttributes
#*  *##foreach ($attribute in $updatableAttributes)
        ${attribute.setterName}($attribute.name);
#*  *##end
#end

        // $relations.size() relations
#*  *##foreach ($relation in $relations)
## Relations that are part of composite PK are set in the PK object
#if (!$relation.otherEnd.identifier || !$entity.compositePrimaryKeyPresent)
        ${relation.otherEnd.setterName}($relation.otherEnd.name);
#end
#*  *##end
    }
#set ($requiredAssociations = $transform.filterRequiredAssociations($relations, $entity.compositePrimaryKeyPresent))
##    // relations=$relations.size() requiredAssociations=$requiredAssociations.size() requiredAttributes=$requiredAttributes.size() updatableAttributes=$updatableAttributes.size()
#if (($updatableAttributes.size()>$requiredAttributes.size() || $relations.size()>$requiredAssociations.size()) && !$requiredAssociations.empty && $entity.syntheticCreateMethodAllowed)
##if (($updatableAttributes.size()>$requiredAttributes.size() || $relations.size()>$requiredAssociations.size()) && $entity.syntheticCreateMethodAllowed && !$requiredAttributes.empty && !$requiredAssociations.empty)

    /**
     * Constructor with required Entity attribute values and required CMR relations.
     *
#if ($entity.compositePrimaryKeyPresent)
     * @param pk $entity.fullyQualifiedEntityCompositePrimaryKeyName The composite primary key class
#end
#*  *##foreach($attribute in $requiredAttributes)
     * @param $attribute.name $attribute.getterSetterTypeName value for the ${attribute.name} property
#*  *##end
#*  *##foreach ($relation in $requiredAssociations)
     * @param $relation.otherEnd.name $relation.otherEnd.getterSetterTypeName value for the ${relation.otherEnd.name} relation
#*  *##end
     */
##    //  $entity.getAttributesAsList($allAttributes, true, true, false) $updatableAttributes.empty $relations.size()
#set ($attributeList = $entity.getAttributesAsList($requiredAttributes, true, true, false))
    public #if ($entity.entityImplementationRequired)${entity.entityEmbeddableName}#else${entity.entityName}#end($attributeList#if(!$requiredAssociations.empty && !$attributeList.empty), #end#foreach ($relation in $requiredAssociations)${relation.otherEnd.getterSetterTypeName} $relation.otherEnd.name#if($velocityCount != $requiredAssociations.size()), #end#end)
    {
#if ($entity.compositePrimaryKeyPresent)
        setPk(pk);
#end
#if (!$requiredAttributes.empty)
        // $requiredAttributes.size() requiredAttributes
#*  *##foreach ($attribute in $requiredAttributes)
        ${attribute.setterName}($attribute.name);
#*  *##end
#end
##if (!$relations.empty)

        // $requiredAssociations.size() required association relations
#*  *##foreach ($relation in $requiredAssociations)
#if (!$relation.otherEnd.identifier || !$entity.compositePrimaryKeyPresent)
        ${relation.otherEnd.setterName}($relation.otherEnd.name);
#end
#*  *##end
##end
    }
#**##end
#end
#end

#foreach ($operation in $entity.getCreateMethods(true))
#**##set ($opArguments = $transform.getArgumentsAsList($operation.argumentNames))
    /**
$operation.getDocumentation("     * ")
     * Explicitly defined constuctor with specified args list.
#**##foreach($attribute in $opArguments)
     * @param $attribute $attribute.getterSetterTypeName value for the $attribute property
#**##end
     */
    public #if ($entity.entityImplementationRequired)${entity.entityEmbeddableName}#else${entity.entityName}#end($operation.typedArgumentList)
    {
#**##foreach($attribute in $opArguments)
        this.${attribute} = $attribute;
#**##end
    }

#end
#if ($entity.compositePrimaryKeyPresent)
    /**
     * Constructor with composite primary key arg only.
     *
     * @param pkIn $entity.fullyQualifiedEntityCompositePrimaryKeyName Composite primary key
     */
    public #if ($entity.entityImplementationRequired)${entity.entityEmbeddableName}#else${entity.entityName}#end($entity.fullyQualifiedEntityCompositePrimaryKeyName pkIn)
    {
        this.pk = pkIn;
    }

#end
    // -------- Common Methods -----------
#if ($entity.entityImplementationRequired)
#**##set ($entityName = $entity.entityEmbeddableName)
#else
#**##set ($entityName = $entity.entityName)
#end
##
## This was changed when the EJB3MappedSuperclassFacade was introduced.
## If normal entity, use identifier attributes
## If mapped superclass there are 2 options
##    If an identifier has been explicitly defined, then use the identifier
##    If an identifier has been dynamically created, then use normal attributes and not the identifier
##
#if ($entity.embeddableSuperclass)
#**##if ($entity.dynamicIdentifiersPresent)
#*  *##set ($attributeSet = $updatableAttributes)
#**##else
#*  *##set ($attributeSet = $entity.identifiers)
#**##end
#else
#**##set ($attributeSet = $entity.identifiers)
#end
#renderEqualsMethod($entity $entityName $attributeSet)
#renderHashCodeMethod($entity $attributeSet)
#if ($entity.embeddableSuperclass)
#**##if ($entity.dynamicIdentifiersPresent)
#*  *##set ($attributeSet = $updatableAttributes)
#**##else
#*  *##set ($attributeSet = $entity.allProperties)
#**##end
#else
#**##set ($attributeSet = $entity.allProperties)
#end
##    // $entity.allProperties.size() $attributeSet.size() $entity
#renderToStringMethod($entity $entityName $attributeSet)
#if (!$entity.entityImplementationRequired && !$entity.embeddableSuperclass && !$entity.requiresGeneralizationMapping)
#renderCompareToMethod($entity $entityName $entity.identifiers)
#end
#renderObjectIdMethod($entity $entity.identifiers)
}
#end