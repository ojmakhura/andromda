##
##  This macro will render any properties and associations.
##  $entity can be of type HibernateEntity or HibernateEmbeddedValue
##
#macro (renderPropertiesAndAssociations $entity $paramSqlPrefix)
## **** Generate attributes ****
#foreach ($attribute in $entity.attributes)
#if (!$attribute.identifier)
#set ($fullyQualifiedPropertyType = $attribute.type.fullyQualifiedHibernateType)
#if ($attribute.type.enumeration)
#set ($fullyQualifiedPropertyType = "$attribute.type.fullyQualifiedHibernateType, ${commonAssemblyName}")
#end
#if ($attribute.containsEmbeddedObject)
        <component name="$stringUtils.upperCamelCaseName($attribute.name)" class="${attribute.type.packageName}.${attribute.type.implementationName}, ${coreAssemblyName}">
## render the properties of the embedded type
#set ($sqlPrefix = $attribute.columnName)
#renderPropertiesAndAssociations($attribute.type $sqlPrefix)
        </component>
#elseif($attribute.formula)
        <property name="$stringUtils.upperCamelCaseName($attribute.name)" type="$fullyQualifiedPropertyType" formula="$attribute.formula" />
#else
        <property name="$stringUtils.upperCamelCaseName($attribute.name)" type="$fullyQualifiedPropertyType"#if(!$attribute.insertEnabled) insert="false"#end#if(!$attribute.updateEnabled) update="false"#end>
## do not specify sql-type for enumerations. NHibernate prefers to do it based on the underlying enum type.
            <column name="$attribute.concatColumnName($paramSqlPrefix, $attribute.columnName)" not-null="$attribute.required" unique="$attribute.unique"#if(!$attribute.type.enumeration) sql-type="$attribute.sqlType"#end#if($attribute.columnIndex) index="$attribute.columnIndex"#end/>
        </property>
#end

#end
#end
## **** Generate associations ****
#foreach ($sourceEnd in $entity.associationEnds)
#set ($otherEnd = $sourceEnd.otherEnd)
#if ($otherEnd.navigable || ($sourceEnd.child && $entity.foreignHibernateGeneratorClass))
#if ($sourceEnd.one2One)
#if ($sourceEnd.one2OneSecondary)
        <one-to-one name="$stringUtils.upperCamelCaseName($otherEnd.name)" class="$otherEnd.type.fullyQualifiedEntityImplementationName, ${coreAssemblyName}" outer-join="$otherEnd.outerJoin"#if ($otherEnd.hibernateCascade) cascade="$otherEnd.hibernateCascade"#end constrained="false"/>
#else
#if($sourceEnd.one2OnePrimary)
        <many-to-one name="$stringUtils.upperCamelCaseName($otherEnd.name)" class="$otherEnd.type.fullyQualifiedEntityImplementationName, ${coreAssemblyName}" outer-join="$otherEnd.outerJoin"#if ($otherEnd.hibernateCascade) cascade="$otherEnd.hibernateCascade"#end foreign-key="$otherEnd.foreignKeyConstraintName"#if($otherEnd.columnIndex) index="$otherEnd.columnIndex"#end>
            <column name="$otherEnd.columnName" not-null="$otherEnd.required" sql-type="$otherEnd.sqlType"#if ($otherEnd.required) unique="true"#end/>
        </many-to-one>
#else
        <one-to-one name="$stringUtils.upperCamelCaseName($otherEnd.name)" class="$otherEnd.type.fullyQualifiedEntityImplementationName, ${coreAssemblyName}" outer-join="$otherEnd.outerJoin" property-ref="$stringUtils.upperCamelCaseName($sourceEnd.name)"#if ($otherEnd.hibernateCascade) cascade="$otherEnd.hibernateCascade"#end foreign-key="$otherEnd.foreignKeyConstraintName"/>
#end
#end
#end
#if ($sourceEnd.one2Many)
#if ($otherEnd.set || $otherEnd.map)
        <$otherEnd.collectionType name="$stringUtils.upperCamelCaseName($otherEnd.name)" order-by="$otherEnd.orderByColumns" lazy="$otherEnd.lazy" outer-join="$otherEnd.outerJoin" inverse="$otherEnd.hibernateInverse"#if ($otherEnd.hibernateCascade) cascade="$otherEnd.hibernateCascade"#end#if ($otherEnd.whereClause) where="$otherEnd.whereClause"#end#if ($stringUtils.isNotBlank($otherEnd.sortType)) sort="$otherEnd.sortType"#end>
#elseif ($otherEnd.bag)
        <$otherEnd.collectionType name="$stringUtils.upperCamelCaseName($otherEnd.name)" order-by="$otherEnd.orderByColumns" lazy="$otherEnd.lazy" outer-join="$otherEnd.outerJoin" inverse="$otherEnd.hibernateInverse"#if ($otherEnd.hibernateCascade) cascade="$otherEnd.hibernateCascade"#end#if ($otherEnd.whereClause) where="$otherEnd.whereClause"#end>
#elseif ($otherEnd.list)
        <$otherEnd.collectionType name="$stringUtils.upperCamelCaseName($otherEnd.name)" lazy="$otherEnd.lazy" outer-join="$otherEnd.outerJoin" inverse="$otherEnd.hibernateInverse"#if ($otherEnd.hibernateCascade) cascade="$otherEnd.hibernateCascade"#end#if ($otherEnd.whereClause) where="$otherEnd.whereClause"#end>
#end
#if(($hibernateEnableCache.equalsIgnoreCase("true")) && ($hibernateEnableAssociationsCache.equalsIgnoreCase("true")))
            <cache usage="$sourceEnd.association.hibernateCacheType" />
#end
            <key foreign-key="$sourceEnd.foreignKeyConstraintName">
                <column name="$sourceEnd.columnName" sql-type="$sourceEnd.sqlType"/>
            </key>
#if ($otherEnd.indexedCollection)
            <index column="$otherEnd.collectionIndexName"#if($otherEnd.map) type="$otherEnd.collectionIndexType"#end/>
#end
            <one-to-many class="$otherEnd.type.fullyQualifiedEntityImplementationName, ${coreAssemblyName}"/>
        </$otherEnd.collectionType>
#elseif ($sourceEnd.many2One)
        <many-to-one name="$stringUtils.upperCamelCaseName($otherEnd.name)" class="$otherEnd.type.fullyQualifiedEntityImplementationName, ${coreAssemblyName}" outer-join="$otherEnd.outerJoin"#if ($otherEnd.hibernateCascade) cascade="$otherEnd.hibernateCascade"#end foreign-key="$otherEnd.foreignKeyConstraintName"#if($otherEnd.columnIndex) index="$otherEnd.columnIndex"#end>
            <column name="$otherEnd.columnName" not-null="$otherEnd.required" sql-type="$otherEnd.sqlType"/>
        </many-to-one>
#elseif ($sourceEnd.many2Many)
        <$otherEnd.collectionType name="$stringUtils.upperCamelCaseName($otherEnd.name)" table="$otherEnd.association.tableName" order-by="$sourceEnd.orderByColumns" outer-join="$otherEnd.outerJoin" lazy="$otherEnd.lazy" inverse="$otherEnd.hibernateInverse"#if ($otherEnd.hibernateCascade) cascade="$otherEnd.hibernateCascade"#end#if ($otherEnd.whereClause) where="$otherEnd.whereClause"#end>
            <key foreign-key="$sourceEnd.foreignKeyConstraintName">
                <column name="$sourceEnd.columnName" sql-type="$sourceEnd.sqlType"/>
            </key>
            <many-to-many class="$otherEnd.type.fullyQualifiedEntityImplementationName, ${coreAssemblyName}" foreign-key="$otherEnd.foreignKeyConstraintName">
                <column name="$otherEnd.columnName" sql-type="$otherEnd.sqlType"#if($otherEnd.columnIndex) index="$otherEnd.columnIndex"#end/>
            </many-to-many>
        </$otherEnd.collectionType>
#end
#end

#end
#end
##
##  This macro will render any sub mappings elements for the given $entity.
##
#macro (renderSubClass $entity)
## Should only get get invoked for inheritance class or subclass.
        <$entity.mappingClassName name="$entity.fullyQualifiedEntityImplementationName, ${coreAssemblyName}"#if($entity.tableRequired) table="$entity.tableName"#else discriminator-value="$entity.entityImplementationName"#end#if($entity.hibernateProxy) proxy="$entity.fullyQualifiedEntityImplementationName"#end dynamic-insert="$entity.dynamicInsert" dynamic-update="$entity.dynamicUpdate">
#if($entity.subclassKeyColumn)
            <key foreign-key="${entity.tableName}_INHERITANCE_FKC">
                <column name="$entity.subclassKeyColumn" sql-type="$identifier.sqlType"/>
            </key>
#end
#renderPropertiesAndAssociations($entity "")
#foreach ($subentity in $entity.specializations)
#renderSubClass($subentity)

#end
        </$entity.mappingClassName>
#end