#set ($generatedFile = "${service.packagePath}/${service.baseName}.cs")
// Name: ${service.baseName}.cs
// license-header cs merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: NSpringServiceBase.vsl in andromda-nspring-cartridge.

using System;
using AndroMDA.NHibernateSupport;

#if ($stringUtils.isNotBlank($service.packageName))
namespace $service.packageName
{
#end
    /// <summary>
    /// <p>
    /// Spring Service base class for <code>$service.fullyQualifiedName</code>,
    /// provides access to all services and entities referenced by this service.
    /// </p>
    ///
    /// @see $service.fullyQualifiedName
    /// </summary>
    public abstract class $service.baseName
#if($service.generalization)
        : $service.generalization.fullyQualifiedImplementationName
#else
        : $service.fullyQualifiedInterfaceName
#end
    {
        private static readonly log4net.ILog log = log4net.LogManager.GetLogger(typeof($service.baseName));

#foreach($entityRef in $service.entityReferences)
#set ($daoPropertyName = "$stringUtils.capitalize($entityRef.name)Dao")
        /// <summary>Property to access $daoPropertyName</summary>
        protected $entityRef.targetElement.fullyQualifiedDaoName $daoPropertyName
        {
            get { return ${springTypesPackage}.DaoFactory.Get$daoPropertyName(); }
        }

#end
#foreach ($operation in $service.operations)
        /// <summary>
        /// @see ${service.fullyQualifiedName}#${operation.getSignature(false)}
        /// </summary>
        $operation.visibility $operation.returnType.fullyQualifiedName $operation.signature
        {
#if ($requiredCheckEnabled)
#foreach ($argument in $operation.arguments)
#if ($argument.required && !$argument.type.primitive)
            if ($argument.name == null)
            {
                throw new ArgumentNullException(
                    "${service.fullyQualifiedName}.${operation.signature} - '${argument.name}' can not be null");
            }
#end
#end
#end
#if ($operation.constraintsPresent)
            this.$operation.preconditionCall;
#end
#set ($call = "${operation.implementationCall};")
## If transactionType is PROPAGATION_REQUIRED then wrap the call with Hibernate session and transaction
#if ($operation.transactionType == "PROPAGATION_REQUIRED")
#if ($operation.returnTypePresent)
#if ($operation.returnType.primitive)
            $operation.returnType.fullyQualifiedName result;
#else
            $operation.returnType.fullyQualifiedName result = null;
#end

#end
            SessionManagerFactory.SessionManager.HandleSessionStart();
            SessionManagerFactory.SessionManager.BeginTransaction();
            try
            {
#if ($operation.returnTypePresent)
                result = $call
#else
                $call
#end
                SessionManagerFactory.SessionManager.CommitTransaction();
            }
            catch (Exception ex)
            {
                SessionManagerFactory.SessionManager.RollbackTransaction();
                log.Error(ex);
                throw;
            }
            finally
            {
                SessionManagerFactory.SessionManager.HandleSessionEnd();
            }
#if ($operation.returnTypePresent)

            return result;
#end
#else
## If transactionType is not PROPAGATION_REQUIRED then make a simple call
#if ($operation.returnTypePresent)
            return $call;
#else
            $call;
#end
#end
        }

#if ($operation.constraintsPresent)
        /// <summary>
        /// Performs any precondition checks for {@link #${operation.call}}.
        /// </summary>
        private void $operation.preconditionSignature
        {
#renderPreconditions($operation)
        }

#end
        /// <summary>
        /// Performs the core logic for {@link #${operation.getSignature(false)}}
        /// <summary>
        protected abstract $operation.returnType.fullyQualifiedName $operation.implementationSignature;

#end
    }
#if ($stringUtils.isNotBlank($service.packageName))
}
#end