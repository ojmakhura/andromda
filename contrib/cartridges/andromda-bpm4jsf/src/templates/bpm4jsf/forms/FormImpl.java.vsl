#set ($generatedFile = "${action.fullyQualifiedFormImplementationPath}.java")
// license-header java merge-point
package $action.packageName;

/**
$action.getDocumentation(" * ")
 */
public class $action.formImplementationName
#if ($stringUtils.isNotBlank($action.formImplementationInterfaceList))
    implements $action.formImplementationInterfaceList
#end
{
    public ${action.formImplementationName}()
    {
#foreach ($field in $action.formFields)
#set ($lenient = !$field.strictDateFormat)
#if ($field.type.dateType)
        java.text.DateFormat $field.dateFormatter = new java.text.SimpleDateFormat("$field.format");
        ${field.dateFormatter}.setLenient($lenient);
        this.dateTimeFormatters.put("$field.name", $field.dateFormatter);
#elseif ($field.type.timeType)
        java.text.DateFormat $field.timeFormatter = new java.text.SimpleDateFormat("$field.format");
        this.dateTimeFormatters.put("$field.name", $field.timeFormatter);
#end
#end
    }
#foreach ($field in $action.formFields)

#if ($field.inputField)
#set ($fieldTypeName = "$fileTypeName")
#else
#set ($fieldTypeName = $field.type.fullyQualifiedName)
#end
    private $fieldTypeName $field.name;

    /**
$field.getDocumentation("     * ")
     */
    public $fieldTypeName ${field.getterName}()
    {
#if ($field.table)
#set ($upperCaseFieldName = $stringUtils.capitalize($field.name))
        return ${managedBeansPackage}.CollectionSorter.sort(this.$field.name, this.get${stringUtils.capitalize($field.tableSortColumnProperty)}(), this.is${upperCaseFieldName}SortAscending());
#else
        return this.${field.name};
#end
    }
    
    /**
     * Keeps track of whether or not the value of $field.name has
     * be populated at least once.
     */
    private boolean $field.formAttributeSetProperty = false;
    
    /**
     * Indicates whether or not the value for $field.name has been set at least
     * once.
     * 
     * @return true/false
     */
    public boolean is${stringUtils.capitalize($field.formAttributeSetProperty)}()
    {
        return this.$field.formAttributeSetProperty;
    }

    /**
$field.getDocumentation("     * ")
     */
    public void ${field.setterName}($fieldTypeName $field.name)
    {
        this.$field.name = $field.name;
        this.$field.formAttributeSetProperty = true;
    }
#if ($field.table)
    /**
     * The name of the sort column for the {@link #${field.name}} collection.
     */
    private String $field.tableSortColumnProperty;

    /**
     * Gets the name of the sort column for the {@link #${field.name}} collection.
     * 
     * @return the name of the sort column.
     */
    public String get${stringUtils.capitalize($field.tableSortColumnProperty)}()
    {
        return this.$field.tableSortColumnProperty;
    }

    /**
     * Sets the name of the {@link #${field.name}} sort column.
     * 
     * @param $field.tableSortColumnProperty the name of the column by which {@link #${field.name}}
     *        are sorted by.
     */
    public void set${stringUtils.capitalize($field.tableSortColumnProperty)}(final String $field.tableSortColumnProperty)
    {
        this.$field.tableSortColumnProperty = $field.tableSortColumnProperty;
    }
    
    /**
     * The flag indicating whether or not {@link #${field.name}} should be sorted
     * ascending.
     */
    private boolean $field.tableSortAscendingProperty = false;

    /**
     * Indicates whether or not {@link #${field.name}} should be sorted ascending
     * or not.
     * 
     * @return true/false
     */
    public boolean is${stringUtils.capitalize($field.tableSortAscendingProperty)}()
    {
        return this.$field.tableSortAscendingProperty;
    }

    /**
     * Sets whether or not {@link #${field.name}} should be sorted ascending.
     * 
     * @param $field.tableSortAscendingProperty true/false
     */
    public void set${stringUtils.capitalize($field.tableSortAscendingProperty)}(final boolean $field.tableSortAscendingProperty)
    {
        this.$field.tableSortAscendingProperty = $field.tableSortAscendingProperty;
    }
#else
    /**
     * Stores the values.
     */
    private java.lang.Object[] $field.valueListName;
    
    /**
     * Stores the labels
     */
    private java.lang.Object[] $field.labelListName;
#set ($listType = "java.lang.Object[]")
#set ($backingListName = $field.backingListName)
#set ($backingListMethod = $stringUtils.capitalize($backingListName))
#set ($valueListName = $field.valueListName)
#set ($valueListMethod = $stringUtils.capitalize($valueListName))
#set ($labelListName = $field.labelListName)
#set ($labelListMethod = $stringUtils.capitalize($labelListName))
    public $listType get${backingListMethod}()
    {
        $listType values = this.${valueListName};
        $listType labels = this.${labelListName};

        if (values == null || values.length == 0)
        {
            return values;
        }

        if (labels == null || labels.length == 0)
        {
            labels = values;
        }

        final int length = java.lang.Math.min(labels.length, values.length);
        javax.faces.model.SelectItem[] backingList = new javax.faces.model.SelectItem[length];

        for (int ctr = 0; ctr < length; ctr++)
        {
            backingList[ctr] = new javax.faces.model.SelectItem(java.lang.String.valueOf(labels[ctr]), java.lang.String.valueOf(values[ctr]));
        }
        return backingList;
    }

    public $listType get${valueListMethod}()
    {
        return this.$valueListName;
    }

    public void set${valueListMethod}($listType $valueListName)
    {
        this.$valueListName = $valueListName;
    }

    public $listType get${labelListMethod}()
    {
        return this.$labelListName;
    }

    public void set${labelListMethod}($listType $labelListName)
    {
        this.$labelListName = $labelListName;
    }

#set ($setBackingListMethodSignature = "set${backingListMethod}(java.util.Collection items, java.lang.String valueProperty, java.lang.String labelProperty)")
    public void $setBackingListMethodSignature
    {
        if (valueProperty == null || labelProperty == null)
        {
            throw new IllegalArgumentException("${action.formImplementationName}.${setBackingListMethodSignature} requires non-null arguments");
        }
        this.${valueListName} = null;
        this.${labelListName} = null;
        if (items != null)
        {
            this.${valueListName} = new java.lang.Object[items.size()];
            this.${labelListName} = new java.lang.Object[items.size()];

            try
            {
                int ctr = 0;
                for (final java.util.Iterator iterator = items.iterator(); iterator.hasNext(); ctr++)
                {
                    final java.lang.Object item = iterator.next();

                    this.${valueListName}[ctr] = org.apache.commons.beanutils.PropertyUtils.getProperty(item, valueProperty);
                    this.${labelListName}[ctr] = org.apache.commons.beanutils.PropertyUtils.getProperty(item, labelProperty);
                }
            }
            catch (final Throwable throwable)
            {
                throw new java.lang.RuntimeException(throwable);
            }
        }
    }

#end
#end

    /**
     * Stores any date or time formatters for this form.
     */
    private final java.util.Map dateTimeFormatters = new java.util.HashMap();

    /**
     * Gets any date and time formatters (keyed by property name)
     * for this form.
     *
     * @return the Map containing any date and time formatters.
     */
    public java.util.Map getDateTimeFormatters()
    {
        return this.dateTimeFormatters;
    }
}