<?xml version="1.0"?>

<translation-test>

    <translation name="query.Hibernate-QL"/>

    <expression>
        <from>
            context org::andromda::contracts::LegalAgreement::findByLegalPartyName(legalPartyName:String):Collection(LegalAgreement)
            body findByLegalPartyNameBody: allInstances() -> select ( la |
            la.legalAgreementParties->includesAll(la.legalAgreementParties->select( lap |
            StringUtils.isLike(lap.legalParty.legalPartyName,
            legalPartyName))))
        </from>
        <to>
            from org.andromda.contracts.LegalAgreement as la
            join fetch la.legalAgreementParties as lap
            where lower(lap.legalParty.legalPartyName) like :legalPartyName
        </to>
    </expression>

    <expression>
        <from>
              context org::andromda::contracts::Project::findByNameAndNumber(name:String,number:String) : Collection(Project)
            body findByNameAndNumberBody: allInstances()->select(
            p | StringUtils.isLike(p.projectName, name)
            and StringUtils.isLike(p.projectNumber, number) )
        </from>
        <to>
            from org.andromda.contracts.Project as p
            where lower(p.projectName) like :name and lower(p.projectNumber) like :number
        </to>
    </expression>

    <expression>
        <from>
            context org::andromda::contracts::Project::findByProjectTypeStatusAfterWentCurrentDate(
                type:String, status:String, wentCurrentDate:Date):Collection (Project) body findByProjectType :
                allInstances() -> select (
                    project |
                        project.type = type
                and project.status = status
                and project.wentCurrentDate >= wentCurrentDate )
        </from>
        <to>
            from org.andromda.contracts.Project as project
            where project.type = :type
            and project.status = :status
            and project.wentCurrentDate >= :wentCurrentDate
        </to>
    </expression>

    <expression>
        <from>
            context org::andromda::contracts::LegalAgreement::findByTypeAndStatuses(agreementStatusPks:Collection(String),anAgreementTypePk:String): Collection(LegalAgreement)
            body findByStatusesBody:
                allInstances() -> select(
                    la |
                agreementStatusPks -> includes(la.agreementStatus.agreementStatusPk)
                or agreementStatusPks -> isEmpty()
                and la.agreementTypePk = anAgreementTypePk )
        </from>
        <to>
            from org.andromda.contracts.LegalAgreement as la
            where la.agreementStatus.agreementStatusPk in (:agreementStatusPks) or size(:agreementStatusPks) = 0
            and la.agreementTypePk = :anAgreementTypePk
        </to>
    </expression>

    <expression>
        <from>
            context org::andromda::contracts::LegalAgreement::findAll():Collection(LegalAgreement)
            body : LegalAgreement.allInstances()
        </from>
        <to>
            from org.andromda.contracts.LegalAgreement as legalAgreement
        </to>
    </expression>

     <expression>
        <from>
            context org::andromda::contracts::LegalAgreement::findByTitlePartyTypeStatusPersonProject(
                aDocumentTitle:String,
                aLegalPartyName:String,
                anAgreementTypePk:String,
                anAgreementStatusPk:String,
                aPersonPk:Long,
                aProjectPk:Long):Collection(LegalAgreement)
            body :
            allInstances()->select(
                legalAgreement |
                    StringUtils.isLike(legalAgreement.documentTitle, aDocumentTitle)
                    and legalAgreement.legalAgreementParties -> includesAll(
                        legalAgreement.legalAgreementParties ->
                            select( legalAgreementParty |
                                StringUtils.isLike(legalAgreementParty.legalParty.legalPartyName, aLegalPartyName)))
                    and StringUtils.isLike(legalAgreement.agreementType.agreementTypePk, anAgreementTypePk)
                    and StringUtils.isLike(legalAgreement.agreementStatus.agreementStatusPk, anAgreementStatusPk)
                    and legalAgreement.person.personPk = aPersonPk
                    and legalAgreement.project.projectPk = aProjectPk)
        </from>
        <to>
            from org.andromda.contracts.LegalAgreement as legalAgreement
                join fetch legalAgreement.legalAgreementParties as legalAgreementParty
            where lower(legalAgreement.documentTitle) like :aDocumentTitle
            and lower(legalAgreementParty.legalParty.legalPartyName) like :aLegalPartyName
            and lower(legalAgreement.agreementType.agreementTypePk) like :anAgreementTypePk
            and lower(legalAgreement.agreementStatus.agreementStatusPk) like :anAgreementStatusPk
            and legalAgreement.person.personPk = :aPersonPk
            and legalAgreement.project.projectPk = :aProjectPk
        </to>
    </expression>

     <expression>
        <from>
            context org::andromda::contracts::LegalAgreement::findByLegalArgreementPks(legalAgreementPks:String):Collection(LegalAgreement)
            body : allInstances() -> select( legalAgreement | legalAgreementPks -> includes(legalAgreement.legalAgreementPk))
        </from>
        <to>
            from org.andromda.contracts.LegalAgreement as legalAgreement
            where legalAgreement.legalAgreementPk in (:legalAgreementPks)
        </to>
    </expression>
        
    <expression>
        <from>
            <![CDATA[
            context MedicalCertificate::findInvalidByPerson(personId:Long,date:Date):Collection(MedicalCertificate) 
            body findInvalidByPerson : 
                allInstances() -> select( certificate | 
                   certificate.person.id = personId 
                   and (certificate.validityStart > date or certificate.validityEnd < date)
                   or (certificate.validityStart = certificate.validityEnd)) 
                   -> sortedBy(certificate.person.id)
                   -> sortedBy(certificate.validityStart) 
            ]]>
        </from>
        <to>
            <![CDATA[
            from org.andromda.contracts.MedicalCertificate as certificate 
            where certificate.person.id = :personId 
            and (certificate.validityStart > :date or certificate.validityEnd < :date)  
            or (certificate.validityStart = certificate.validityEnd) 
            order by certificate.person.id, certificate.validityStart       
            ]]>          
        </to> 
    </expression>
    
    <expression>
        <from>
            context org::andromda::contracts::LegalAgreement::findAll():Collection(LegalAgreement)
            body : LegalAgreement.allInstances() -> sortedBy(documentTitle) -> sortedBy(expiredDate)
        </from>
        <to>
            from org.andromda.contracts.LegalAgreement as legalAgreement order by documentTitle, expiredDate
        </to>
    </expression>
    
    <expression>
        <from>
            <![CDATA[
            context MedicalCertificate::findInvalidByPerson(personId:Long,date:Date):Collection(MedicalCertificate) 
            body findInvalidByPerson : 
                allInstances() -> select( certificate | 
                   certificate.person.id = personId 
                   and (certificate.validityStart > date or certificate.validityEnd < date)
                   and certificate.notes -> size() >= 1)
            ]]>
        </from>
        <to>
            <![CDATA[
            from org.andromda.contracts.MedicalCertificate as certificate 
            where certificate.person.id = :personId 
            and (certificate.validityStart > :date or certificate.validityEnd < :date)  
            and size(certificate.notes) >= 1
            ]]>          
        </to> 
    </expression>

    <expression>
        <from>
            <![CDATA[
            context MedicalCertificate::findByCode(code:String):Collection(MedicalCertificate) 
            body : 
                allInstances() -> select( certificate | 
                   certificate.code.toLower() = code )
            ]]>
        </from>
        <to>
            <![CDATA[
            from org.andromda.contracts.MedicalCertificate as certificate 
            where lower(certificate.code) = :code
            ]]>          
        </to> 
    </expression>
    
     <expression>
        <from>
            <![CDATA[
            context MedicalCertificate::findByCode(code:String):Collection(MedicalCertificate) 
            body : 
                allInstances() -> select( certificate | 
                   certificate.code.toUpper() = code 
                   and certificate.code.size() > 0 )
            ]]>
        </from>
        <to>
            <![CDATA[
            from org.andromda.contracts.MedicalCertificate as certificate 
            where upper(certificate.code) = :code
            and length(certificate.code) > 0
            ]]>          
        </to> 
    </expression>
    
    <!--
    <expression>
        <from>
            <![CDATA[
            context MedicalCertificate::findBySmallestValidateStartDate():Collection(MedicalCertificate) 
            body : 
                allInstances() -> select( certificate | certificate.validityStart -> iterate
                    certificate.validityStart.min(certificate.validityStart)) 
            ]]>
        </from>
        <to>
            <![CDATA[
            from org.andromda.contracts.MedicalCertificate as certificate 
            where min(certificate.validityStart)      
            ]]>          
        </to> 
    </expression>
    -->

</translation-test>
